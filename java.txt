Adam D. Scott
JavaScript
Everywhere
Building Cross-Platform Applications with
GraphQL, React, React Native, and Electron

Praise for JavaScript Everywhere
JavaScript Everywhere is an incredible book that will give you everything you need to
build applications with JavaScript on any platform. The title is the truth: JavaScript
is everywhere, and this book performs the unique feat of putting everything
in context for developers at all levels. Read this book then write code
and make technology decisions with confidence.
—Eve Porcello, Software Developer and Instructor
at Moon Highway
JavaScript Everywhere is the perfect companion for navigating the ever-changing modern
JavaScript ecosystem. Adam teaches React, React Native, and GraphQL in a clear,
approachable way so you can build robust web, mobile, and desktop applications.
—Peggy Rayzis, Engineering Manager at Apollo GraphQL

Adam D. Scott
JavaScript Everywhere
Building Cross-Platform Applications with
GraphQL, React, React Native, and Electron
Beijing Boston Farnham Sebastopol Tokyo
978-1-492-04698-1
[LSI]
JavaScript Everywhere
by Adam D. Scott
Copyright © 2020 Adam D. Scott. All rights reserved.
Printed in the United States of America.
Published by O’Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA 95472.
O’Reilly books may be purchased for educational, business, or sales promotional use. Online editions are
also available for most titles (http://oreilly.com). For more information, contact our corporate/institutional
sales department: 800-998-9938 or corporate@oreilly.com.
Acquisitions Editor: Jennifer Pollock
Development Editor: Angela Rufino
Production Editor: Christopher Faucher
Copyeditor: Rachel Monaghan
Proofreader: Christina Edwards
Indexer: WordCo Indexing Services, Inc.
Interior Designer: David Futato
Cover Designer: Karen Montgomery
Illustrator: Rebecca Demarest
February 2020: First Edition
Revision History for the First Edition
2020-02-06: First Release
See http://oreilly.com/catalog/errata.csp?isbn=9781492046981 for release details.
The O’Reilly logo is a registered trademark of O’Reilly Media, Inc. JavaScript Everywhere, the cover image,
and related trade dress are trademarks of O’Reilly Media, Inc.
The views expressed in this work are those of the author, and do not represent the publisher’s views.
While the publisher and the author have used good faith efforts to ensure that the information and
instructions contained in this work are accurate, the publisher and the author disclaim all responsibility
for errors or omissions, including without limitation responsibility for damages resulting from the use of
or reliance on this work. Use of the information and instructions contained in this work is at your own
risk. If any code samples or other technology this work contains or describes is subject to open source
licenses or the intellectual property rights of others, it is your responsibility to ensure that your use
thereof complies with such licenses and/or rights.
For my dad, who both brought home my first hacked-together computer and proofread
every paper that I wrote. I wouldn’t be here without you. You are missed.

Table of Contents
Foreword. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xiii
Preface. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xv
1. Our Development Environment. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
Your Text Editor 2
The Terminal 2
Using a Dedicated Terminal Application 2
Using VSCode 2
Navigating the Filesystem 2
Command-Line Tools and Homebrew (Mac Only) 3
Node.js and NPM 4
Installing Node.js and NPM for macOS 4
Installing Node.js and NPM for Windows 5
MongoDB 5
Installing and Running MongoDB for macOS 6
Installing and Running MongoDB for Windows 6
Git 6
Expo 7
Prettier 7
ESLint 8
Making Things Look Nice 8
Conclusion 8
2. API Introduction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
What We’re Building 9
How We’re Going to Build This 10
Getting Started 11
vii
Conclusion 12
3. A Web Application with Node and Express. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
Hello World 13
Nodemon 14
Extending Port Options 15
Conclusion 16
4. Our First GraphQL API. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
Turning Our Server into an API (Sort Of) 17
GraphQL Basics 21
Schemas 21
Resolvers 23
Adapting Our API 23
Conclusion 30
5. Database. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
Getting Started with MongoDB 32
Connecting MongoDB to Our Application 34
Reading and Writing Data from Our Application 37
Conclusion 44
6. CRUD Operations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
Separating Our GraphQL Schema and Resolvers 45
Writing Our GraphQL CRUD Schema 49
CRUD Resolvers 49
Date and Time 51
Conclusion 53
7. User Accounts and Authentication. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
Application Authentication Flow 55
Encryption and Tokens 56
Encrypting Passwords 57
JSON Web Tokens 58
Integrating Authentication into Our API 59
User Schemas 59
Authentication Resolvers 61
Adding the User to the Resolver Context 64
Conclusion 67
8. User Actions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
Before We Get Started 69
viii | Table of Contents
Attach a User to New Notes 70
User Permissions for Updates and Deletes 72
User Queries 73
Toggling Note Favorites 76
Nested Queries 80
Conclusion 82
9. Details. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
Web Application and Express.js Best Practices 83
Express Helmet 83
Cross-Origin Resource Sharing 84
Pagination 84
Data Limitations 87
Other Considerations 88
Testing 88
Subscriptions 88
Apollo GraphQL Platform 88
Conclusion 89
10. Deploying Our API. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
Hosting Our Database 91
Deploying Our Application 97
Project Setup 97
Deployment 99
Testing 100
Conclusion 100
11. User Interfaces and React. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
JavaScript and UIs 102
Declarative Interfaces with JavaScript 103
Just Enough React 103
Conclusion 108
12. Building a Web Client with React. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
What We’re Building 109
How We’re Going to Build This 110
Getting Started 110
Building Out the Web Application 112
Routing 114
Linking 117
UI Components 118
Conclusion 120
Table of Contents | ix
13. Styling an Application. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
Creating a Layout Component 121
CSS 124
CSS-in-JS 124
Creating a Button Component 125
Adding Global Styles 127
Component Styles 129
Conclusion 132
14. Working with Apollo Client. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
Setting Up Apollo Client 136
Querying an API 138
Some Style 146
Dynamic Queries 148
Pagination 150
Conclusion 152
15. Web Authentication and State. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
Creating a Sign-up Form 153
React Forms and State 157
signUp Mutation 158
JSON Web Tokens and Local Storage 161
Redirects 162
Attaching Headers to Requests 162
Local State Management 163
Logging Out 166
Creating a Sign-In Form 168
Protected Routes 173
Conclusion 175
16. Create, Read, Update, and Delete Operations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177
Creating New Notes 177
Reading User Notes 183
Updating Notes 186
Deleting Notes 193
Toggling Favorites 195
Conclusion 199
17. Deploying a Web Application. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201
Static Websites 201
Our Deployment Pipeline 203
Hosting Source Code with Git 203
x | Table of Contents
Deploy with Netlify 205
Conclusion 206
18. Desktop Applications with Electron. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 207
What We’re Building 207
How We’re Going To Build This 208
Getting Started 208
Our First Electron App 209
macOS Application Window Details 211
Developer Tools 211
The Electron API 213
Conclusion 213
19. Integrating an Existing Web Application with Electron. . . . . . . . . . . . . . . . . . . . . . . . . . 215
Integrating Our Web Application 215
Warnings and Errors 216
Configuration 218
Content Security Policy 219
Conclusion 222
20. Electron Deployment. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 223
Electron Builder 223
Configuring Electron Builder 224
Build for Our Current Platform 225
App Icons 225
Building for Multiple Platforms 226
Code Signing 226
Conclusion 227
21. Mobile Applications with React Native. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 229
What We’re Building 230
How We’re Going To Build This 230
Getting Started 231
Conclusion 234
22. Mobile Application Shell. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 235
React Native Building Blocks 235
Style and Styled Components 237
Styled Components 240
Routing 242
Tabbed Routing with React Navigation 242
Stack Navigation 245
Table of Contents | xi
Adding Screen Titles 249
Icons 251
Conclusion 253
23. GraphQL and React Native. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 255
Creating List and Scrollable Content Views 256
Making a List Routable 261
GraphQL with Apollo Client 263
Writing GraphQL Queries 264
Adding a Loading Indicator 269
Conclusion 271
24. Mobile Application Authentication. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273
Authentication Routing Flow 273
Creating a Sign-in Form 282
Authentication with GraphQL Mutations 287
Authenticated GraphQL Queries 289
Adding a Sign-up Form 293
Conclusion 299
25. Mobile Application Distribution. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 301
app.json Configuration 301
Icons and App Loading Screens 303
App Icons 303
Splash Screens 304
Expo Publish 305
Creating Native Builds 306
iOS 307
Android 307
Distributing to App Stores 308
Conclusion 308
Afterword. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 309
A. Running the API Locally. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 311
B. Running the Web App Locally. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 313
Index. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 315
xii | Table of Contents
Foreword
In 1997 I was a junior in high school. A friend and I were goofing around with the
web-connected computer in our school library when he showed me that you could
click View → Source to see the underlying code of a web page. A few days later,
another friend showed me how to publish my own HTML. My mind was blown.
After that, I was hooked. I went around borrowing the bits of the websites I liked to
construct my own Franken-site. I spent much of my free time at the pieced-together
computer in my family’s dining room tinkering away. I even “wrote” (OK, copied and
pasted) my first JavaScript, to implement hover styles on links, which was not yet
doable with simple CSS.
And in a turn of events that I’ve come to think of as a nerdy and wholesome version
of the film Almost Famous, my homegrown music site gained reasonable popularity.
Because of this, I received promotional CDs in the mail and was put on the guest list
at concerts. More important to me, however, was that I was sharing my interests with
other people around the world. I was a bored suburban teenager, in love with music,
and was able to reach people I’d never meet. That was, and still is, such an empower‐
ing feeling.
Today, we can build powerful applications using only web technologies, but it can be
daunting to get started. APIs are an invisible background that serves up data. View →
Source shows concatenated and minified code. Authentication and security are mysti‐
fying. Putting all of these things together can be overwhelming. If we’re able to look
beyond these confusing details, we may notice that the same technologies I was fid‐
dling with 20-some years ago can now be used to build powerful web applications,
code native mobile applications, create powerful desktop applications, design 3D ani‐
mations, and even program robots.
xiii
As an educator, I’ve found that many of us learn best by building new things, taking
them apart, and adapting them for our own use cases. That is the goal of this book. If
you know some HTML, CSS, and JavaScript but are unsure of how to take those com‐
ponents and build the robust applications that you’ve dreamed up, this book is for
you. I’ll guide you through building an API that can power the user interfaces of a
web application, a native mobile application, and a desktop application. Most impor‐
tantly, you’ll gain an understanding of how all of these pieces fit together so that you
can build and create wonderful things.
I can’t wait to see what you make.
— Adam
xiv | Foreword
Preface
The idea for this book came to me after writing my first Electron desktop application.
Having made a career as a web developer, I was immediately smitten with the possi‐
bilities of using web technologies to build cross-platform applications. At the same
time, React, React Native, and GraphQL were all taking off. I sought out resources to
learn how all of these things fit together, but kept coming up short. This book repre‐
sents the guide that I wished I had.
The ultimate goal of this book is to introduce the possibilities of using a single pro‐
gramming language, JavaScript, to build all sorts of applications.
Who This Book Is For
This book is for intermediate-level developers who have some experience with
HTML, CSS, and JavaScript or ambitious beginners who are looking to learn the tools
necessary to bootstrap a business or side project.
How This Book Is Organized
The book is designed to walk you through developing an example application for a
variety of platforms. It can be broken down into the following sections:
• Chapter 1 guides you through setting up a JavaScript development environment.
• Chapters 2–10 cover building an API with Node, Express, MongoDB, and Apollo
Server.
• Chapters 11–25 review the details of building cross-platform user interfaces
using React, Apollo, and a variety of tools. Specifically:
— Chapter 11 introduces user interface development and React.
— Chapters 12–17 demonstrate how to build a web application with React,
Apollo Client, and CSS-in-JS.
xv
— Chapters 18–20 guide you through building simple Electron applications.
— Chapters 21–25 introduce using React Native and Expo to build mobile appli‐
cations for iOS and Android.
Conventions Used in This Book
The following typographical conventions are used in this book:
Italic
Indicates new terms, URLs, email addresses, filenames, and file extensions.
Constant width
Used for program listings, as well as within paragraphs to refer to program ele‐
ments such as variable or function names, databases, data types, environment
variables, statements, and keywords.
Constant width bold
Shows commands or other text that should be typed literally by the user.
Constant width italic
Shows text that should be replaced with user-supplied values or by values deter‐
mined by context.
This element signifies a tip or suggestion.
This element signifies a general note.
This element indicates a warning or caution.
xvi | Preface
Using Code Examples
Supplemental material (code examples, exercises, etc.) is available for download at
https://github.com/javascripteverywhere.
If you have a technical question or a problem using the code examples, please send
email to bookquestions@oreilly.com.
This book is here to help you get your job done. In general, if example code is offered
with this book, you may use it in your programs and documentation. You do not
need to contact us for permission unless you’re reproducing a significant portion of
the code. For example, writing a program that uses several chunks of code from this
book does not require permission. Selling or distributing examples from O’Reilly
books does require permission. Answering a question by citing this book and quoting
example code does not require permission. Incorporating a significant amount of
example code from this book into your product’s documentation does require
permission.
We appreciate, but generally do not require, attribution. An attribution usually
includes the title, author, publisher, and ISBN. For example: “JavaScript Everywhere
by Adam D. Scott (O’Reilly). Copyright 2020 Adam D. Scott, 978-1-492-04698-1.”
If you feel your use of code examples falls outside fair use or the permission given
above, feel free to contact us at permissions@oreilly.com.
O’Reilly Online Learning
For more than 40 years, O’Reilly Media has provided technol‐
ogy and business training, knowledge, and insight to help
companies succeed.
Our unique network of experts and innovators share their knowledge and expertise
through books, articles, conferences, and our online learning platform. O’Reilly’s
online learning platform gives you on-demand access to live training courses, indepth learning paths, interactive coding environments, and a vast collection of text
and video from O’Reilly and 200+ other publishers. For more information, please
visit http://oreilly.com.
Preface | xvii
How to Contact Us
Please address comments and questions concerning this book to the publisher:
O’Reilly Media, Inc.
1005 Gravenstein Highway North
Sebastopol, CA 95472
800-998-9938 (in the United States or Canada)
707-829-0515 (international or local)
707-829-0104 (fax)
We have a web page for this book, where we list errata, examples, and any additional
information. You can access this page at https://oreil.ly/javascript-everywhere.
Email bookquestions@oreilly.com to comment or ask technical questions about this
book.
For more information about our books, courses, conferences, and news, see our web‐
site at http://www.oreilly.com.
Find us on Facebook: http://facebook.com/oreilly
Follow us on Twitter: http://twitter.com/oreillymedia
Watch us on YouTube: http://www.youtube.com/oreillymedia
Acknowledgments
Thanks to all of the wonderful people at O’Reilly, past and present, who have been
universally welcoming and open to my ideas over the years. I want to particularly
thank my editor, Angela Rufino, who has given me feedback, encouragement, and
lots of helpful reminders. I want to also thank Mike Loukides, who has provided me
with both caffeine and great conversation. Lastly, thanks to Jennifer Pollock, for her
support and encouragement.
I am eternally grateful for the open source community, from which I have learned
and benefited. Without the individuals and organizations who have created and
maintained the many libraries I have written about, this book would not be possible.
Several technical reviewers helped make this book better, ensuring that things were
accurate. Thank you, Andy Ngom, Brian Sletten, Maximiliano Firtman, and Zeeshan
Chawdhary. It’s a heck of a code review to undertake and I sincerely appreciate their
efforts. Special thanks goes to my long-time colleague and friend, Jimmy Wilson, who
I called in at the 11th hour to review and provide feedback. It was a lot to ask, but as
with everything he does, he took it on with gusto. This book wouldn’t be what it is
without his help.
xviii | Preface
I’ve been incredibly lucky to surround myself with smart, passionate, supportive coworkers throughout my adult life. So many lessons big and small, both technical and
nontechnical, have come through my time with them. The full list is too long for
print, but I want to give a shout-out to Elizabeth Bond, John Paul Doguin, Marc
Esher, Jenn Lassiter, and Jessica Schafer.
Music was my constant companion as I wrote, and this book may not exist without
the wonderful sounds of Chuck Johnson, Mary Lattimore, Makaya McCraven, G.S.
Schray, Sam Wilkes, Hiroshi Yoshimura, and many others.
Finally, I want to thank my wife, Abbey, and my children, Riley, Harrison, and Har‐
low, with whom I sacrificed a lot of time to write this book. Thank you for putting up
with me while I was locked away in my office—or when I wasn’t, but my mind still
was. The four of you are the motivation for everything that I do.
Preface | xix

CHAPTER 1
Our Development Environment
John Wooden, the late coach of the UCLA men’s basketball team, is one of the most
successful coaches of all time, winning 10 national championships in a 12-year
period. His teams consisted of top recruits, including hall-of-fame players such as
Lew Alcindor (Kareem Abdul-Jabbar) and Bill Walton. On the first day of practice,
Wooden would sit down each of his new recruits, players who had been the best in
the United States in high school, and teach them to put on their socks properly. When
asked about this, Wooden stated that “it’s the little details that make the big things
come about.”
Chefs use the term mise en place, meaning “everything in its place,” to describe the
practice of preparing the tools and ingredients required for the menu prior to cook‐
ing. This preparation enables the kitchen’s cooks to successfully prepare meals during
busy rushes, as the small details have already been considered. Much like Coach
Wooden’s players and chefs preparing for a dinner rush, it is worth dedicating time to
setting up our development environment.
A useful development environment does not require expensive software or top-ofthe-line hardware. In fact, I’d encourage you to start simple, use open source soft‐
ware, and grow your tools with you. Though a runner prefers a specific brand of
sneakers and a carpenter may always reach for her favorite hammer, it took time and
experience to establish these preferences. Experiment with tools, observe others, and
over time you will create the environment that works best for you.
In this chapter we’ll install a text editor, Node.js, Git, MongoDB, and several helpful
JavaScript packages as well as locate our terminal application. It’s possible that you
already have a development environment that works well for you; however, we will
also be installing several required tools that will be used throughout the book. If
you’re like me and typically skip over the instruction manual, I’d still encourage you
to read through this guide.
1
If you find yourself stuck at any point, please reach out to the JavaScript Everywhere
community, via our Spectrum channel at spectrum.chat/jseverywhere.
Your Text Editor
Text editors are a lot like clothes. We all need them, but our preferences may vary
wildly. Some like simple and well constructed. Some prefer the flashy paisley pattern.
There’s no wrong decision, and you should use whatever makes you most
comfortable.
If you don’t already have a favorite, I highly recommend Visual Studio Code
(VSCode). It’s an open source editor that is available for Mac, Windows, and Linux.
Additionally, it offers built-in features to simplify development and is easily modified
with community extensions. It’s even built using JavaScript!
The Terminal
If you’re using VSCode, it comes with an integrated terminal. For most development
tasks, this may be all you need. Personally, I find using a dedicated terminal client
preferable as I find it easier to manage multiple tabs and use more dedicated window
space on my machine. I’d suggest trying both and finding what works best for you.
Using a Dedicated Terminal Application
All operating systems come with a built-in terminal application and this is a great
place to get started. On macOS it is called, fittingly enough, Terminal. On the Win‐
dows operating system, starting with Windows 7, the program is PowerShell. The
name of the terminal for Linux distributions may vary, but often includes “Terminal.”
Using VSCode
To access the terminal in VSCode, click Terminal → New Terminal. This will present
you with a terminal window. The prompt will be present in the same directory as the
current project.
Navigating the Filesystem
Once you’ve found your terminal, you’ll need the critical ability to navigate the file‐
system. You can do this using the cd command, which stands for “change directory.”
2 | Chapter 1: Our Development Environment
Command-Line Prompts
Terminal instructions often include a $ or > at the start of the line.
These are used to designate the prompt and should not be copied.
In this book, I’ll indicate the terminal prompt with a dollar sign ($).
When entering instructions into your terminal application, do not
type the $.
When you open your terminal application, you’ll be presented with a cursor prompt,
where you may enter commands. By default, you’re in your computer’s home direc‐
tory. If you haven’t already, I’d recommend making a Projects folder that is a subdirectory within your home directory. This folder can house all of your development
projects. You create a Projects directory and navigate into that folder like so:
# first type cd, this will ensure you are in your root directory
$ cd
# next, if you don't already have a Projects directory, you can create one
# this will create Projects as a subfolder in your system's root directory
$ mkdir Projects
# finally you can cd into the Projects directory
$ cd Projects
In the future, you can navigate to your Projects directory as follows:
$ cd # ensure you are in the root directory
$ cd Projects
Now let’s say you have a folder called jseverywhere in your Projects directory. You can
type cd jseverywhere from the Projects directory to navigate into that folder. To nav‐
igate backward into a directory (in this case, to Projects), you would type cd .. (the
cd command followed by two periods).
All together, this would look something like:
> $ cd # ensure you are in your root directory
> $ cd Projects # navigate from root dir to Projects dir
/Projects > $ cd jseverywhere # navigate from Projects dir to jsevewehre dir
/Projects/jseverwhere > $ cd .. # navigate back from jseverwhere to Projects
/Projects > $ # Prompt is currently in the Projects dir
If this is new to you, spend some time navigating through your files until you’re com‐
fortable. I’ve found that filesystem issues are a common tripping point for budding
developers. Having a grasp of this will provide you with a solid foundation for estab‐
lishing your workflows.
Command-Line Tools and Homebrew (Mac Only)
Certain command-line utilities are only available to macOS users once Xcode is
installed. You can jump through this hoop, without installing Xcode, by installing
Command-Line Tools and Homebrew (Mac Only) | 3
xcode-select via your terminal. To do so, run the following command and click
through the install prompts:
$ xcode-select --install
Homebrew is a package manager for macOS. It makes installing development depen‐
dencies, like programming languages and databases, as simple as running a
command-line prompt. If you use a Mac, it will dramatically simplify your develop‐
ment environment. To install Homebrew, either head over to brew.sh to copy and
paste the install command, or type the following in a single line:
$ /usr/bin/ruby -e "$(curl -fsSL
https://raw.githubusercontent.com/Homebrew/install/master/install)"
Node.js and NPM
Node.js is “a JavaScript runtime, built on Chrome’s V8 JavaScript Engine.” In practical
terms this means that Node is a platform that allows developers to write JavaScript
outside of a browser environment. Node.js comes with NPM, the default package
manager. NPM enables you to install thousands of libraries and JavaScript tools
within your projects.
Managing Node.js Versions
If you plan on managing a large number of Node projects, you may
find that you also need to manage multiple versions of Node on
your machine. If that’s the case, I recommend using Node Version
Manager (NVM) to install Node. NVM is a script that enables you
to manage multiple active Node versions. For Windows users, I
recommend nvm-windows. I won’t be covering Node versioning,
but it is a helpful tool. If this is your first time working with Node, I
recommend proceeding with the following instructions for your
system.
Installing Node.js and NPM for macOS
macOS users can install Node.js and NPM using Homebrew. To install Node.js, type
the following command into your terminal:
$ brew update
$ brew install node
With Node installed, open your terminal application to verify it is working.
$ node --version
## Expected output v12.14.1, your version number may differ
$ npm --version
## Expected output 6.13.7, your version number may differ
4 | Chapter 1: Our Development Environment
If you see a version number after typing those commands, congratulations—you’ve
successfully installed Node and NPM for macOS!
Installing Node.js and NPM for Windows
For Windows, the most straightforward way to install Node.js is to visit nodejs.org
and download the installer for your operating system.
First, visit nodejs.org and install the LTS version (12.14.1 at the time of writing), fol‐
lowing the installation steps for your operating system. With Node installed, open
your terminal application to verify it is working.
$ node --version
## Expected output v12.14.1, your version number may differ
$ npm --version
## Expected output 6.13.7, your version number may differ
What is LTS?
LTS stands for “long-term support,” meaning that the Node.js
Foundation has committed to providing support and security
updates for that major version number (in this case 12.x). The stan‐
dard support window lasts for three years after the version’s initial
release. In Node.js, even-numbered releases are LTS versions. I rec‐
ommend using an even-numbered release for application
development.
If you see a version number after typing those commands, congratulations—you’ve
successfully installed Node and NPM for Windows!
MongoDB
MongoDB is the database that we will be using while developing our API. Mongo is a
popular choice for working with Node.js, because it treats our data as JSON (Java‐
Script Object Notation) documents. This means that it’s comfortable for JavaScript
developers to work with from the get-go.
Official MongoDB Installation Documentation
The MongoDB documentation offers a regularly updated guide for
installing MongoDB Community Edition across operating systems.
If you run into issues with the installation, I recommend consulting
the documentation at docs.mongodb.com/manual/administration/
install-community.
MongoDB | 5
Installing and Running MongoDB for macOS
To install MongoDB for macOS, first install with Homebrew:
$ brew update
$ brew tap mongodb/brew
$ brew install mongodb-community@4.2
To start MongoDB, we can run it as a macOS service:
$ brew services start mongodb-community
This will start the MongoDB service and keep it running as a background process.
Note that anytime you restart your machine and plan to develop with Mongo, you
may need to run this command again to restart the MongoDB service. To verify that
MongoDB has installed and is running, type ps -ef | grep mongod into your termi‐
nal. This will list the currently running Mongo processes.
Installing and Running MongoDB for Windows
To install MongoDB for Windows, first download the installer from the MongoDB
Download Center. Once the file has downloaded, run the installer following the
installation wizard. I recommend choosing the Complete setup type, configuring it as
a Service. All other values can remain as the defaults.
Once installation is complete, we may need to create the directory in which Mongo
will write our data. Within your terminal, run the following commands:
$ cd C:\
$ md "\data\db"
To verify that MongoDB has installed and start the Mongo service:
1. Locate the Windows Services console.
2. Find the MongoDB service.
3. Right-click the MongoDB service.
4. Click Start.
Note that anytime you restart your machine and plan to develop with Mongo, you
may need to restart the MongoDB service.
Git
Git is the most popular version control software, allowing you to do things like copy
code repositories, merge code with others, and create branches of your own code that
do not impact one another. Git will be helpful for “cloning” this book’s sample code
6 | Chapter 1: Our Development Environment
repositories, meaning it will allow you to directly copy a folder of sample code.
Depending on your operating system, Git may already be installed. Type the follow‐
ing into your terminal window:
$ git --version
If a number is returned, congrats—you’re all set! If not, visit git-scm.com to install Git,
or use Homebrew for macOS. Once you’ve completed the installation steps, once
again type git --version into your terminal to verify that it has worked.
Expo
Expo is a toolchain that simplifies the bootstrapping and development of iOS and
Android projects with React Native. We will need to install the Expo command-line
tool and, optionally (though recommended), the Expo app for iOS or Android. We’ll
cover this in more detail in the mobile application portion of the book, but if you’re
interested in getting a head start, visit expo.io to learn more. To install the commandline tools, type the following into your terminal:
npm install -g expo-cli
Using the -g global flag will make the expo-cli tool globally available to your
machine’s Node.js installation.
To install the Expo mobile application, visit the Apple App Store or Google Play Store
on your device.
Prettier
Prettier is a code formatting tool with support for a number of languages, including
JavaScript, HTML, CSS, GraphQL, and Markdown. It makes it easy to follow basic
formatting rules, meaning that when you run the Prettier command, your code is
automatically formatted to follow a standard set of best practices. Even better, you
can configure your editor to do this automatically every time you save a file. This
means that you’ll never again have a project with issues like inconsistent spaces and
mixed quotes.
I recommend installing Prettier globally on your machine and configuring a plug-in
for your editor. To install Prettier globally, go to your command-line and type:
npm install -g prettier
Once you’ve installed Prettier, visit Prettier.io to find the plug-in for your text editor.
With the editor plug-in installed, I recommend adding the following settings within
your editor’s settings file:
"editor.formatOnSave": true,
"prettier.requireConfig": true
Expo | 7
These settings will automatically format files on save whenever a .prettierrc configura‐
tion file is within the project. The .prettierrc file specifies options for Prettier to fol‐
low. Now whenever that file is present, your editor will automatically reformat your
code to meet the conventions of the project. Each project within this book will
include a .prettierrc file.
ESLint
ESLint is a code linter for JavaScript. A linter differs from a formatter, such as Prettier,
in that a linter also checks for code quality rules, such as unused variables, infinite
loops, and unreachable code that falls after a return. As with Prettier, I recommend
installing the ESLint plug-in for your favorite text editor. This will alert you to errors
in real time as you write your code. You can find a list of editor plug-ins on the
ESLint website.
Similar to Prettier, projects can specify the ESLint rules they would like to follow
within an .eslintrc file. This provides project maintainers with fine-grained control
over their code preferences and a means to automatically enforce coding standards.
Each of the projects within this book will include a helpful but permissive set of
ESLint rules, aimed at helping you to avoid common pitfalls.
Making Things Look Nice
This is optional, but I’ve found that I enjoy programming just a bit more when I find
my setup aesthetically pleasing. I can’t help it; I have a degree in the arts. Take some
time and test out different color themes and typefaces. Personally, I’ve grown to love
the Dracula Theme, which is a color theme available for nearly every text editor and
terminal, along with Adobe’s Source Code Pro typeface.
Conclusion
In this chapter we’ve set up a working and flexible JavaScript development environ‐
ment on our computer. One of the great joys of programming is personalizing your
environment. I encourage you to experiment with the themes, colors, and tools that
you use to make this environment your own. In the next section of the book, we will
put this environment to work by developing our API application.
8 | Chapter 1: Our Development Environment
CHAPTER 2
API Introduction
Picture yourself seated in a booth at a small, local restaurant where you’ve decided to
order a sandwich. The server writes your order on a slip of paper and passes that
paper to the cook. The cook reads the order, takes individual ingredients to build the
sandwich, and passes the sandwich to the server. The server then brings the sandwich
to you to eat. If you would then like some dessert, the process repeats.
An application programming interface (API) is a set of specifications that allows one
computer program to interact with another. A web API works in much the same way
as ordering a sandwich. A client requests some data, that data travels to a web server
application over the HyperText Transfer Protocol (HTTP), the web server application
takes the requests and processes the data, and the data is then sent to the client over
HTTP.
In this chapter we’ll explore the broad topic of web APIs and get started with our
development by cloning the starter API project to our local machine. Before we do
that, however, let’s explore the requirements of the application that we’ll be building.
What We’re Building
Throughout the book we’ll be building a social note application called Notedly. Users
will be able to create an account, write notes in plain text or Markdown, edit their
notes, view a feed of other users’ notes, and “favorite” the notes of other users. In this
portion of the book, we’ll be developing the API to support this application.
In our API:
• Users will be able to create notes, as well as read, update, and delete the notes
they’ve created.
9
• Users will be able to view a feed of notes created by other users, and read individ‐
ual notes created by others, though they will not be able to update or delete them.
• Users will be able to create an account, log in, and log out.
• Users will be able to retrieve their profile information as well as the public profile
information of other users.
• Users will be able to favorite the notes of other users as well as retrieve a list of
their favorites.
Markdown
Markdown is a popular text markup language that is common in
the programming community as well as in text applications such as
iA Writer, Ulysses, Byword, and many more. To learn more about
Markdown, take a look at the Markdown Guide website.
Though this sounds like a lot, I’ll be breaking it down into small chunks throughout
this portion of the book. Once you’ve learned to perform these types of interactions,
you’ll be able to apply them to building all sorts of APIs.
How We’re Going to Build This
To build our API we’ll be using the GraphQL API query language. GraphQL is an
open source specification, first developed at Facebook in 2012. The advantage of
GraphQL is that it allows the client to request precisely the data it needs, dramatically
simplifying and limiting the number of requests. This also provides a distinct perfor‐
mance advantage when we’re sending data to mobile clients, as we only need to send
the data that the client needs. We’ll be exploring how to write, develop, and consume
GraphQL APIs throughout much of the book.
What about REST?
If you’re familiar with Web API terminology, you’ve likely heard of
REST (Representational State Transfer) APIs. The REST architec‐
ture has been (and continues to be) the dominant format for APIs.
These APIs differ from GraphQL by relying upon the URL struc‐
ture and query parameters to make requests to a server. While
REST remains relevant, the simplicity of GraphQL, the robustness
of tooling around GraphQL, and the potential performance gains
of sending limited data over the wire make GraphQL my prefer‐
ence for modern platforms.
10 | Chapter 2: API Introduction
Getting Started
Before we can start development, we need to make a copy of the project starter files to
our machine. The project’s source code contains all of the scripts and references to
third-party libraries that we will need to develop our application. To clone the code to
your local machine, open the terminal, navigate to the directory where you keep your
projects, git clone the project repository, and install the dependencies with npm
install. It may also be helpful to create a notedly directory to keep all of the book’s
code organized:
$ cd Projects
$ mkdir notedly && cd notedly
$ git clone git@github.com:javascripteverywhere/api.git
$ cd api
$ npm install
Installing Third-Party Dependencies
By making a copy of the book’s starter code and running npm
install in the directory, you avoid having to run npm install
again for any of the individual third-party dependencies.
The code is structured as follows:
/src
This is the directory where you should perform your development as you follow
along with the book.
/solutions
This directory contains the solutions for each chapter. If you get stuck, these are
available for you to consult.
/final
This directory contains the final working project.
Now that you have the code on your local machine, you’ll need to make a copy of the
project’s .env file. This file is a place to keep environment-specific information or
project secrets, such as the database URL, client IDs, and passwords. Because of this
you never want to check it into source control. You’ll need your own copy of the .env
file. To do this, type the following into your terminal, from the api directory:
cp .env.example .env
You should now see an .env file in the directory. You don’t yet need to do anything
with this file, but we’ll be adding information to it as we progress through the devel‐
opment of our API backend. The .gitignore file included with the project will ensure
that you do not inadvertently commit your .env file.
Getting Started | 11
Help, I Don’t See the .env File!
By default, operating systems hide files that start with a period, as
these are typically used by the system, not end users. If you don’t
see the .env file, try opening the directory in your text editor. The
file should be visible in the file explorer of your editor. Alternately,
typing ls -a into your terminal window will list the files in the
current working directory.
Conclusion
APIs provide an interface for data to flow from a database to applications. In doing
so, they are the backbone of modern applications. By using GraphQL we can quickly
develop modern, scalable API-based applications. In the next chapter we’ll begin our
API development by building a web server, using Node.js and Express.
12 | Chapter 2: API Introduction
CHAPTER 3
A Web Application with Node and Express
Before implementing our API, we’re going to build a basic server-side web applica‐
tion to serve as the basis for the backend of our API. We’ll be using the Express.js
framework, a “minimalist web framework for Node.js,” meaning that it does not ship
with a lot of features, but is highly configurable. We’ll be using Express.js as the foun‐
dation of our API server, but Express can also be used to build fully featured serverside web applications.
User interfaces, such as websites and mobile applications, communicate with web
servers when they need to access data. This data could be anything from the HTML
required to render a page in a web browser to the results of a user’s search. The client
interface communicates with the server using HTTP. The data request is sent from
the client via HTTP to the web application that is running on the server. The web
application then processes the request and returns the data to the client, again over
HTTP.
In this chapter we’ll build a small server-side web application, which will be the basis
for our API. To do this, we’ll use the Express.js framework to build a simple web
application that sends a basic request.
Hello World
Now that you understand the basics of server-side web applications, let’s jump in.
Within the src directory of our API project, create a file named index.js and add the
following:
const express = require('express');
const app = express();
app.get('/', (req, res) => res.send('Hello World'));
13
app.listen(4000, () => console.log('Listening on port 4000!'));
In this example, first we require the express dependency and create the app object,
using the imported Express.js module. We then use the app object’s get method to
instruct our application to send a response of “Hello World” when a user accesses the
root URL (/). Lastly, we instruct our application to run on port 4000. This will allow
us to view the application locally at the URL http://localhost:4000.
Now to run the application, type node src/index.js in your terminal. After doing
so, you should see a log in your terminal that reads Listening on port 4000!. If
that’s the case, you should be able to open a browser window to http://localhost:4000
and see the result in Figure 3-1.
Figure 3-1. e results of our Hello World server code in the browser
Nodemon
Now, let’s say that the output of this example doesn’t properly express our excitement.
We want to change our code so that it adds an exclamation mark to our response. Go
ahead and do that, changing the res.send value to read Hello World!!!. The full
line should now be:
app.get('/', (req, res) => res.send('Hello World!!!'));
If you go to your web browser and refresh the page, you’ll notice that the output
hasn’t changed. This is because any changes we make to our web server require us to
restart it. To do so, switch back to your terminal and press Ctrl + C to stop the server.
14 | Chapter 3: A Web Application with Node and Express
Now restart it by again typing node index.js. Now, when you navigate back to your
browser and refresh the page, you should see the updated response.
As you can imagine, stopping and restarting our server for every change can quickly
become tedious. Thankfully, we can use the Node package nodemon to automatically
restart the server on changes. If you take a look at the project’s package.json file, you’ll
see a dev command within the scripts object, which instructs nodemon to watch our
index.js file:
"scripts": {
 ...
 "dev": "nodemon src/index.js"
 ...
}
package.json Scripts
There are a handful of other helper commands within the scripts
object. We will explore those in future chapters.
Now, to start the application from the terminal, type:
npm run dev
Navigating to your browser and refreshing the page, you’ll see that things are working
as before. To confirm that nodemon automatically restarts the server, let’s once again
update our res.send value so that it reads:
res.send('Hello Web Server!!!')
Now, you should be able to refresh the page in your browser and see the update
without manually restarting the server.
Extending Port Options
Currently our application is served on port 4000. This works great for local develop‐
ment, but we will need the flexibility to set this to a different port number when
deploying the application. Let’s take the steps to update this now. We’ll start by adding
a port variable:
const port = process.env.PORT || 4000;
This change will allow us to dynamically set the port in the Node environment, but
fall back to port 4000 when no port is specified. Now let’s adjust our app.listen code
to work with this change and use a template literal to log the correct port:
Extending Port Options | 15
app.listen(port, () =>
 console.log(`Server running at http://localhost:${port}`)
);
Our final code should now read:
const express = require('express');
const app = express();
const port = process.env.PORT || 4000;
app.get('/', (req, res) => res.send('Hello World!!!'));
app.listen(port, () =>
 console.log(`Server running at http://localhost:${port}`)
);
With this, we now have the basics of our web server code up and running. To test that
everything is working, verify that no errors are present in your console and reload
your web browser at http://localhost:4000.
Conclusion
Server-side web applications are the foundation of API development. In this chapter,
we built a basic web application using the Express.js framework. When developing
Node-based web applications, you have a wide array of frameworks and tools to
choose from. Express.js is a great choice due to its flexibility, community support, and
maturity as a project. In the next chapter, we’ll turn our web application into an API.
16 | Chapter 3: A Web Application with Node and Express
CHAPTER 4
Our First GraphQL API
Presumably, if you are reading this, you are a human being. As a human you have a
number of interests and passions. You also have family members, friends, acquaintan‐
ces, classmates, and colleagues. Those people also have their own social relationships,
interests, and passions. Some of these relationships and interests overlap, while others
do not. All together, we each have a connected graph of the people in our lives.
These types of interconnected data are exactly the challenge that GraphQL initially
set out to solve in API development. By writing a GraphQL API we are able to effi‐
ciently connect data, which reduces the complexity and number of requests while
allowing us to serve a client precisely the data they need.
Does that all sound like a bit of overkill for a notes application? Perhaps it does, but as
you’ll see, the tools and techniques provided by the GraphQL JavaScript ecosystem
both enable and simplify all types of API development.
In this chapter we’ll build a GraphQL API, using the apollo-server-express pack‐
age. To do so, we’ll explore fundamental GraphQL topics, write a GraphQL schema,
develop code to resolve our schema functions, and access our API using the
GraphQL Playground user interface.
Turning Our Server into an API (Sort Of)
Let’s begin our API development by turning our Express server into a GraphQL
server using the apollo-server-express package. Apollo Server is an open source
GraphQL server library that works with a large number of Node.js server frame‐
works, including Express, Connect, Hapi, and Koa. It enables us to serve data as a
GraphQL API from a Node.js application and also provides helpful tooling such as
the GraphQL Playground, a visual helper for working with our API in development.
17
To write our API we’ll be modifying the web application code we wrote in the previ‐
ous chapter. Let’s start by including the apollo-server-express package. Add the
following to the top of your src/index.js file:
const { ApolloServer, gql } = require('apollo-server-express');
Now that we’ve imported apollo-server, we’ll set up a basic GraphQL application.
GraphQL applications consist of two primary components: a schema of type defini‐
tions and resolvers, which resolve the queries and mutations performed against the
data. If that all sounds like nonsense, that’s OK. We’ll implement a “Hello World” API
response and will further explore these GraphQL topics throughout the development
of our API.
To begin, let’s construct a basic schema, which we will store in a variable called type
Defs. This schema will describe a single Query named hello that will return a string:
// Construct a schema, using GraphQL schema language
const typeDefs = gql`
 type Query {
 hello: String
 }
`;
Now that we’ve set up our schema, we can add a resolver that will return a value to
the user. This will be a simple function that returns the string “Hello world!”:
// Provide resolver functions for our schema fields
const resolvers = {
 Query: {
 hello: () => 'Hello world!'
 }
};
Lastly, we’ll integrate Apollo Server to serve our GraphQL API. To do so, we’ll add
some Apollo Server–specific settings and middleware and update our app.listen
code:
// Apollo Server setup
const server = new ApolloServer({ typeDefs, resolvers });
// Apply the Apollo GraphQL middleware and set the path to /api
server.applyMiddleware({ app, path: '/api' });
app.listen({ port }, () =>
 console.log(
 `GraphQL Server running at http://localhost:${port}${server.graphqlPath}`
 )
);
18 | Chapter 4: Our First GraphQL API
Putting it all together, our src/index.js file should now look like this:
const express = require('express');
const { ApolloServer, gql } = require('apollo-server-express');
// Run the server on a port specified in our .env file or port 4000
const port = process.env.PORT || 4000;
// Construct a schema, using GraphQL's schema language
const typeDefs = gql`
 type Query {
 hello: String
 }
`;
// Provide resolver functions for our schema fields
const resolvers = {
 Query: {
 hello: () => 'Hello world!'
 }
};
const app = express();
// Apollo Server setup
const server = new ApolloServer({ typeDefs, resolvers });
// Apply the Apollo GraphQL middleware and set the path to /api
server.applyMiddleware({ app, path: '/api' });
app.listen({ port }, () =>
 console.log(
 `GraphQL Server running at http://localhost:${port}${server.graphqlPath}`
 )
);
If you’ve left the nodemon process running, you can head straight to your browser;
otherwise, you must type npm run dev within the terminal application to start the
server. Then visit http://localhost:4000/api, where you’ll be greeted with the GraphQL
Playground (Figure 4-1). This web app, which comes bundled with Apollo Server, is
one of the great benefits of working with GraphQL. From here, you can run
GraphQL queries and mutations and see the results. You can also click the Schema
tab to access automatically created documentation for the API.
Turning Our Server into an API (Sort Of) | 19
Figure 4-1. e GraphQL Playground
GraphQL Playground has a dark colored default syntax theme.
Throughout the book, I’ll be using the “light” theme for its higher
contrast. This is configurable in GraphQL Playground’s settings,
which can be accessed by clicking the gear icon.
We can now write our query against our GraphQL API. To do so, type the following
into the GraphQL Playground:
query {
 hello
}
When you click the Play button, the query should return the following (Figure 4-2):
{
 "data": {
 "hello": "Hello world!"
 }
}
20 | Chapter 4: Our First GraphQL API
Figure 4-2. e hello query
And that’s it! We now have a working GraphQL API that we’ve accessed via the
GraphQL Playground. Our API takes a query of hello and returns the string Hello
world!. More importantly, we now have the structure in place to build a fully featured
API.
GraphQL Basics
In the previous section we dove right in and developed our first API, but let’s take a
few moments to step back and look at the different pieces of a GraphQL API. The two
primary building blocks of a GraphQL API are schemas and resolvers. By understand‐
ing these two components, you can apply them more effectively to your API design
and development.
Schemas
A schema is a written representation of our data and interactions. By requiring a
schema, GraphQL enforces a strict plan for our API. This is because your API can
only return data and perform interactions that are defined within the schema.
The fundamental component of GraphQL schemas are object types. In the previous
example we created a GraphQL object type of Query with a field of hello, which
returned a scalar type of String. GraphQL contains five built-in scalar types:
GraphQL Basics | 21
String
A string with UTF-8 character encoding
Boolean
A true or false value
Int
A 32-bit integer
Float
A floating-point value
ID
A unique identifier
With these basic components we can construct a schema for an API. We do so by first
defining the type. Let’s imagine that we’re creating an API for a pizza menu. In doing
so, we might define a GraphQL schema type of Pizza like so:
type Pizza {
}
Now, each pizza has a unique ID, a size (such as small, medium, or large), a number
of slices, and optional toppings. The Pizza schema might look something like this:
type Pizza {
 id: ID
 size: String
 slices: Int
 toppings: [String]
}
In this schema, some field values are required (such as ID, size, and slices), while oth‐
ers may be optional (such as toppings). We can express that a field must contain a
value by using an exclamation mark. Let’s update our schema to represent the
required values:
type Pizza {
 id: ID!
 size: String!
 slices: Int!
 toppings: [String]
}
In this book, we’ll be writing a basic schema, which will enable us to perform the vast
majority of operations found in a common API. If you’d like to explore all of the
GraphQL schema options, I’d encourage you to read the GraphQL schema
documentation.
22 | Chapter 4: Our First GraphQL API
Resolvers
The second piece of our GraphQL API will be resolvers. Resolvers perform exactly
the action their name implies; they resolve the data that the API user has requested.
We will write these resolvers by first defining them in our schema and then imple‐
menting the logic within our JavaScript code. Our API will contain two types of
resolvers: queries and mutations.
Queries
A query requests specific data from an API, in its desired format. In our hypothetical
pizza API we may write a query that will return a full list of pizzas on the menu and
another that will return detailed information about a single pizza. The query will then
return an object, containing the data that the API user has requested. A query never
modifies the data, only accesses it.
Mutations
We use a mutation when we want to modify the data in our API. In our pizza exam‐
ple, we may write a mutation that changes the toppings for a given pizza and another
that allows us to adjust the number of slices. Similar to a query, a mutation is also
expected to return a result in the form of an object, typically the end result of the per‐
formed action.
Adapting Our API
Now that you have a good understanding of the components of GraphQL, let’s adapt
our initial API code for our notes application. To begin, we’ll write some code to read
and create notes.
The first thing we’ll need is a little bit of data for our API to work with. Let’s create an
array of “note” objects, which we’ll use as the basic data served by our API. As our
project evolves, we’ll replace this in-memory data representation with a database. For
now, we will store our data in a variable named notes. Each note in the array will be
an object with three properties, id, content, and author:
let notes = [
 { id: '1', content: 'This is a note', author: 'Adam Scott' },
 { id: '2', content: 'This is another note', author: 'Harlow Everly' },
 { id: '3', content: 'Oh hey look, another note!', author: 'Riley Harrison' }
];
Adapting Our API | 23
Now that we have some data, we’ll adapt our GraphQL API to work with it. Let’s
begin by focusing on our schema. Our schema is GraphQL’s representation of our
data and how it will be interacted with. We know that we will have notes, which will
be queried and mutated. These notes will, for now, contain an ID, content, and an
author field. Let’s create a corresponding note type within our typeDefs GraphQL
schema. This will represent the properties of a note within our API:
type Note {
 id: ID!
 content: String!
 author: String!
}
Now, let’s add a query that will allow us to retrieve the list of all notes. Let’s update the
Query type to include a notes query, which will return the array of note objects:
type Query {
 hello: String!
 notes: [Note!]!
}
Now, we can update our resolver code to perform the work of returning the array of
data. Let’s update our Query code to include the following notes resolver, which
returns the raw data object:
Query: {
 hello: () => 'Hello world!',
 notes: () => notes
 },
If we now go to the GraphQL playground, running at http://localhost:4000/api, we can
test the notes query. To do so, type the following query:
query {
 notes {
 id
 content
 author
 }
}
24 | Chapter 4: Our First GraphQL API
Then, when you click the Play button, you should see a data object returned, which
contains the data array (Figure 4-3).
Figure 4-3. e notes query
To try out one of the coolest aspects of GraphQL, we can remove any of our reques‐
ted fields, such as id or author. When we do so, the API returns precisely the data
that we’ve requested. This allows the client that consumes the data to control the
amount of data sent within each request and limit that data to exactly what is
required (Figure 4-4).
Adapting Our API | 25
Figure 4-4. A notes query with only content data requested
Now that we can query our full list of notes, let’s write some code that will allow us to
query for a single note. You can imagine the usefulness of this from a user interface
perspective, for displaying a view that contains a single, specific note. To do so, we’ll
want to request a note with a specific id value. This will require us to use an argument
in our GraphQL schema. An argument allows the API consumer to pass specific val‐
ues to the resolver function, providing the necessary information for it to resolve.
Let’s add a note query, which will take an argument of id, with the type ID. We’ll
update our Query object within our typeDefs to the following, which includes the
new note query:
type Query {
 hello: String
 notes: [Note!]!
 note(id: ID!): Note!
}
With our schema updated, we can write a query resolver to return the requested note.
To do this, we’ll need to be able to read the API user’s argument values. Helpfully,
Apollo Server passes the following useful parameters to our resolver functions:
parent
The result of the parent query, which is useful when nesting queries.
args
These are the arguments passed by the user in the query.
26 | Chapter 4: Our First GraphQL API
context
Information passed along from the server application to the resolver functions.
This could include things such as the current user or database information.
info
Information about the query itself.
We’ll be exploring these further as needed within our code. If you’re curious, you can
learn more about these parameters in Apollo Server’s documentation. For now, we’ll
need only the information contained within the second parameter, args.
The note query will take the note id as an argument and find it within our array of
note objects. Add the following to the query resolver code:
note: (parent, args) => {
 return notes.find(note => note.id === args.id);
}
The resolver code should now look as follows:
const resolvers = {
 Query: {
 hello: () => 'Hello world!',
 notes: () => notes,
 note: (parent, args) => {
 return notes.find(note => note.id === args.id);
 }
 }
};
To run our query, let’s go back to our web browser and visit the GraphQL Playground
at http://localhost:4000/api. We can now query a note with a specific id as follows:
query {
 note(id: "1") {
 id
 content
 author
 }
}
When you run this query, you should receive the results of a note with the requested
id value. If you attempt to query for a note that doesn’t exist, you should receive a
result with a value of null. To test this, try changing the id value to return different
results.
Adapting Our API | 27
Let’s wrap up our initial API code by introducing the ability to create a new note,
using a GraphQL mutation. In that mutation, the user will pass in the note’s content.
For now, we’ll hardcode the author of the note. Let’s begin by updating our typeDefs
schema with a Mutation type, which we will call newNote:
type Mutation {
 newNote(content: String!): Note!
}
We’ll now write a mutation resolver, which will take in the note content as an argu‐
ment, store the note as an object, and add it in memory to our notes array. To do this,
we’ll add a Mutation object to our resolvers. Within the Mutation object, we’ll add a
function called newNote, with parent and args parameters. Within this function,
we’ll take the argument content and create an object with id, content, and author
keys. As you may have noticed, this matches the current schema of a note. We will
then push this object to our notes array and return the object. Returning the object
allows the GraphQL mutation to receive a response in the intended format. Go ahead
and write this code as follows:
Mutation: {
 newNote: (parent, args) => {
 let noteValue = {
 id: String(notes.length + 1),
 content: args.content,
 author: 'Adam Scott'
 };
 notes.push(noteValue);
 return noteValue;
 }
}
Our src/index.js file will now read like so:
const express = require('express');
const { ApolloServer, gql } = require('apollo-server-express');
// Run our server on a port specified in our .env file or port 4000
const port = process.env.PORT || 4000;
let notes = [
 { id: '1', content: 'This is a note', author: 'Adam Scott' },
 { id: '2', content: 'This is another note', author: 'Harlow Everly' },
 { id: '3', content: 'Oh hey look, another note!', author: 'Riley Harrison' }
];
// Construct a schema, using GraphQL's schema language
const typeDefs = gql`
 type Note {
 id: ID!
 content: String!
 author: String!
28 | Chapter 4: Our First GraphQL API
 }
 type Query {
 hello: String
 notes: [Note!]!
 note(id: ID!): Note!
 }
 type Mutation {
 newNote(content: String!): Note!
 }
`;
// Provide resolver functions for our schema fields
const resolvers = {
 Query: {
 hello: () => 'Hello world!',
 notes: () => notes,
 note: (parent, args) => {
 return notes.find(note => note.id === args.id);
 }
 },
 Mutation: {
 newNote: (parent, args) => {
 let noteValue = {
 id: String(notes.length + 1),
 content: args.content,
 author: 'Adam Scott'
 };
 notes.push(noteValue);
 return noteValue;
 }
 }
};
const app = express();
// Apollo Server setup
const server = new ApolloServer({ typeDefs, resolvers });
// Apply the Apollo GraphQL middleware and set the path to /api
server.applyMiddleware({ app, path: '/api' });
app.listen({ port }, () =>
 console.log(
 `GraphQL Server running at http://localhost:${port}${server.graphqlPath}`
 )
);
Adapting Our API | 29
With the schema and resolver updated to accept a mutation, let’s try it out in
GraphQL Playground at http://localhost:4000/api. In the playground, click the + sign
to create a new tab and write the mutation as follows:
mutation {
 newNote (content: "This is a mutant note!") {
 content
 id
 author
 }
}
When you click the Play button, you should receive a response containing the con‐
tent, ID, and author of our new note. You can also see that the mutation worked by
rerunning the notes query. To do so, either switch back to the GraphQL Playground
tab containing that query, or type the following:
query {
 notes {
 content
 id
 author
 }
}
When this query runs, you should now see four notes, including the recently added
one.
Data Storage
We are currently storing our data in memory. This means that any‐
time we restart our server, we will lose that data. We’ll be persisting
our data using a database in the next chapter.
We’ve now successfully implemented our query and mutation resolvers and tested
them within the GraphQL Playground user interface.
Conclusion
In this chapter we’ve successfully built a GraphQL API, using the apollo-serverexpress module. We can now run queries and mutations against an in-memory data
object. This setup provides us a solid foundation on which to build any API. In the
next chapter we’ll explore the ability to persist data by using a database.
30 | Chapter 4: Our First GraphQL API
CHAPTER 5
Database
When I was a kid, I obsessively collected sports cards of all types. A big part of col‐
lecting the cards was organizing them. I kept the star players in one box, basketball
superstar Michael Jordan had an entire box dedicated to his cards, and the rest of my
cards were kept organized by sport, and suborganized by team. This organization
method enabled me to store the cards safely and easily find the card that I was look‐
ing for at any given time. Little did I know, but a storage system like this is the tangi‐
ble equivalent to a database. At its core, a database allows us to store information and
retrieve it later.
When I first started out with web development, I found databases intimidating. I
would see instructions for running a database and entering obscure SQL commands,
and it felt like an additional level of abstraction that I couldn’t wrap my head around.
Thankfully, I was eventually able to scale the wall and am no longer intimidated by a
SQL table join, so if you are where I was, I want you to know that it is possible to
navigate the world of databases.
In this book we’ll be using MongoDB as our database of choice. I’ve chosen Mongo
because it is a popular choice in the Node.js ecosystem and is a great database to get
started with for anyone who is new to the topic. Mongo stores our data in “docu‐
ments” that work like JavaScript objects. This means that we will be able to write and
retrieve information in a format that is familiar to any JavaScript developer. However,
if you have a database that you strongly prefer, such as PostgreSQL, the topics cov‐
ered in this book are transferable to any type of system with a little work.
Before we can work with Mongo, we will need to ensure that the MongoDB server is
running locally. This is something that is required throughout development. To do so,
follow the instructions for your system in Chapter 1.
31
Getting Started with MongoDB
With Mongo running, let’s explore how we can interact with Mongo directly from our
terminal, using the Mongo shell. Begin by opening the MongoDB shell by typing the
mongo command:
$ mongo
After running this command, you should see information about your MongoDB
shell, the local server connection, and some additional information printed to the ter‐
minal. We can now interact directly with MongoDB from within the terminal appli‐
cation. We can create a database as well as switch to a new database with the use
command. Let’s create a database called learning:
$ use learning
In my card collection, described at the beginning of the chapter, I kept my cards
organized in separate boxes. MongoDB brings with it the same concept, called collec‐
tions. A collection is how we group similar documents together. For example, a blog
application may have a collection for posts, another for users, and a third for com‐
ments. If we were to compare a collection to a JavaScript object, it would be the toplevel object, while documents are the individual objects within. We can visualize it
like so:
collection: {
 document: {},
 document: {},
 document: {}.
 ...
}
With this information in hand, let’s create a document within a collection in our
learning database. We’ll create a pizza collection where we will store documents
with a pizza type. Enter the following into the MongoDB shell:
$ db.pizza.save({ type: "Cheese" })
If this is successful, we should see a returned result that reads:
WriteResult({ "nInserted" : 1 })
We can also write multiple entries into the database at once:
$ db.pizza.save([{type: "Veggie"}, {type: "Olive"}])
Now that we’ve written some documents to our database, let’s retrieve them. To do so,
we’ll use MongoDB’s find method. To see all of the documents in the collection, run a
find command with empty parameters:
$ db.pizza.find()
32 | Chapter 5: Database
We should now see all three entries in the database. In addition to storing the data,
MongoDB automatically assigns a unique ID to each entry. The results should look
something like this:
{ "_id" : ObjectId("5c7528b223ab40938c7dc536"), "type" : "Cheese" }
{ "_id" : ObjectId("5c7529fa23ab40938c7dc53e"), "type" : "Veggie" }
{ "_id" : ObjectId("5c7529fa23ab40938c7dc53f"), "type" : "Olive" }
We can also find individual documents, both by property values as well as with Mon‐
go’s assigned ID:
$ db.pizza.find({ type: "Cheese" })
$ db.pizza.find({ _id: ObjectId("A DOCUMENT ID HERE") })
Not only do we want to be able to find documents, but it’s also useful to be able to
update them. We can do so by using Mongo’s update method, which accepts a first
parameter of a document to change and a second parameter of the change to the
document. Let’s update our Veggie pizza to be a Mushroom pizza:
$ db.pizza.update({ type: "Veggie" }, { type: "Mushroom" })
Now, if we run db.pizza.find(), we should see that your document has been
updated:
{ "_id" : ObjectId("5c7528b223ab40938c7dc536"), "type" : "Cheese" }
{ "_id" : ObjectId("5c7529fa23ab40938c7dc53e"), "type" : "Mushroom" }
{ "_id" : ObjectId("5c7529fa23ab40938c7dc53f"), "type" : "Olive" }
As with updating a document, we can also remove one using Mongo’s remove
method. Let’s remove the mushroom pizza from our database:
$ db.pizza.remove({ type: "Mushroom" })
Now if we perform a db.pizza.find() query, we will see only two entries within our
collection. If we decided that we no longer wanted to include any of the data, we
could run the remove method without an empty object parameter, which will wipe
out our entire collection:
$ db.pizza.remove({})
We’ve now successfully used the MongoDB shell to create a database, add documents
to a collection, update those documents, and remove them. These fundamental data‐
base operations will provide a solid footing as we integrate a database into our
project. In development, we can also access our database using the MongoDB shell.
This can prove helpful for tasks such as debugging and manually removing or updat‐
ing entries.
Getting Started with MongoDB | 33
Connecting MongoDB to Our Application
Now that you’ve learned a bit about using MongoDB from the shell, let’s connect it to
our API application. To do this, we’ll be using the Mongoose Object Document Map‐
per (ODM). Mongoose is a library that simplifies working with MongoDB in Node.js
applications by reducing and streamlining boilerplate code, through the use of its
schema-based modeling solution. Yes, you read that right—another schema! As you’ll
see, once we’ve defined our database schema, working with MongoDB via Mongoose
is similar to the types of commands we wrote within the Mongo shell.
We will first need to update our .env file with the URL of our local database. This will
allow us to set the database URL in whatever environment we are working (such as
local development and production). The default URL of a local MongoDB server is
mongodb://localhost:27017, to which we’ll add the name of our database. So, within
our .env file, we will set a DB_HOST variable with the URL of our Mongo database
instance as follows:
DB_HOST=mongodb://localhost:27017/notedly
The next step in working with a database in our application is to connect to it. Let’s
write some code that will connect our application to our database at startup. To do
this, we’ll first create a new file within the src directory, named db.js. Within db.js we’ll
write our database connection code. We’ll also include a function to close our data‐
base connection, which will prove useful for testing the application.
In src/db.js, enter the following:
// Require the mongoose library
const mongoose = require('mongoose');
module.exports = {
 connect: DB_HOST => {
 // Use the Mongo driver's updated URL string parser
 mongoose.set('useNewUrlParser', true);
 // Use findOneAndUpdate() in place of findAndModify()
 mongoose.set('useFindAndModify', false);
 // Use createIndex() in place of ensureIndex()
 mongoose.set('useCreateIndex', true);
 // Use the new server discovery and monitoring engine
 mongoose.set('useUnifiedTopology', true);
 // Connect to the DB
 mongoose.connect(DB_HOST);
 // Log an error if we fail to connect
 mongoose.connection.on('error', err => {
 console.error(err);
 console.log(
 'MongoDB connection error. Please make sure MongoDB is running.'
 );
 process.exit();
34 | Chapter 5: Database
 });
 },
 close: () => {
 mongoose.connection.close();
 }
};
Now we’ll update our src/index.js to call this connection. To do so, we will first import
our .env configuration as well as the db.js file. Within the imports, at the top of the
file, add these imports:
require('dotenv').config();
const db = require('./db');
I like to store the DB_HOST value that is defined in the .env file as a variable. Add this
variable directly below the port variable definition:
const DB_HOST = process.env.DB_HOST;
We can then call our connection, by adding the following to the src/index.js file:
db.connect(DB_HOST);
The src/index.js file will now read as follows:
const express = require('express');
const { ApolloServer, gql } = require('apollo-server-express');
require('dotenv').config();
const db = require('./db');
// Run the server on a port specified in our .env file or port 4000
const port = process.env.PORT || 4000;
// Store the DB_HOST value as a variable
const DB_HOST = process.env.DB_HOST;
let notes = [
 {
 id: '1',
 content: 'This is a note',
 author: 'Adam Scott'
 },
 {
 id: '2',
 content: 'This is another note',
 author: 'Harlow Everly'
 },
 {
 id: '3',
 content: 'Oh hey look, another note!',
 author: 'Riley Harrison'
 }
];
Connecting MongoDB to Our Application | 35
// Construct a schema, using GraphQL's schema language
const typeDefs = gql`
 type Note {
 id: ID
 content: String
 author: String
 }
 type Query {
 hello: String
 notes: [Note]
 note(id: ID): Note
 }
 type Mutation {
 newNote(content: String!): Note
 }
`;
// Provide resolver functions for our schema fields
const resolvers = {
 Query: {
 hello: () => 'Hello world!',
 notes: () => notes,
 note: (parent, args) => {
 return notes.find(note => note.id === args.id);
 }
 },
 Mutation: {
 newNote: (parent, args) => {
 let noteValue = {
 id: notes.length + 1,
 content: args.content,
 author: 'Adam Scott'
 };
 notes.push(noteValue);
 return noteValue;
 }
 }
};
const app = express();
// Connect to the database
db.connect(DB_HOST);
// Apollo Server setup
const server = new ApolloServer({ typeDefs, resolvers });
// Apply the Apollo GraphQL middleware and set the path to /api
server.applyMiddleware({ app, path: '/api' });
36 | Chapter 5: Database
app.listen({ port }, () =>
 console.log(
 `GraphQL Server running at http://localhost:${port}${server.graphqlPath}`
 )
);
Though the actual functionality has not changed, if you run npm run dev, the appli‐
cation should successfully connect to the database and run without errors.
Reading and Writing Data from Our Application
Now that we can connect to our database, let’s write the code needed to read and
write data to it from within the application. Mongoose allows us to define how the
data will be stored in our database as a JavaScript object, and we can then store and
act upon data that fits that model structure. With this in mind, let’s create our object,
referred to as a Mongoose schema.
First, create a folder within our src directory called models to house this schema file.
In this folder, create a file named note.js. Within src/models/note.js, we’ll start by
defining the basic setup of the file:
// Require the mongoose library
const mongoose = require('mongoose');
// Define the note's database schema
const noteSchema = new mongoose.Schema();
// Define the 'Note' model with the schema
const Note = mongoose.model('Note', noteSchema);
// Export the module
module.exports = Note;
Next, we will define our schema, within the noteSchema variable. Similar to the inmemory data example, our current schema will, for now, include the content of the
note as well as a hardcoded string representing the author. We’ll also include the
option to include timestamps for our notes, which will be automatically stored when
a note is created or edited. We’ll be adding functionality to our note schema as we go.
Our Mongoose schema will be structured as follows:
// Define the note's database schema
const noteSchema = new mongoose.Schema(
 {
 content: {
 type: String,
 required: true
 },
 author: {
 type: String,
Reading and Writing Data from Our Application | 37
 required: true
 }
 },
 {
 // Assigns createdAt and updatedAt fields with a Date type
 timestamps: true
 }
);
Data Permanence
We’ll be updating and changing our data model throughout devel‐
opment, at times removing all of the data from our database. As a
result, I wouldn’t recommend using this API to store important
things like class notes, a list of your friends’ birthdays, or the direc‐
tions to your favorite pizza place.
Our overall src/models/note.js file should now read as follows:
// Require the mongoose library
const mongoose = require('mongoose');
// Define the note's database schema
const noteSchema = new mongoose.Schema(
 {
 content: {
 type: String,
 required: true
 },
 author: {
 type: String,
 required: true
 }
 },
 {
 // Assigns createdAt and updatedAt fields with a Date type
 timestamps: true
 }
);
// Define the 'Note' model with the schema
const Note = mongoose.model('Note', noteSchema);
// Export the module
module.exports = Note;
38 | Chapter 5: Database
To simplify importing our models into our Apollo Server Express application, we’ll
add an index.js file to the src/models directory. This will combine our models into a
single JavaScript module. While this isn’t strictly necessary, I find it to be a good pat‐
tern to follow as applications and database models grow. In src/models/index.js we’ll
import our note model and add it to a models object to be exported:
const Note = require('./note');
const models = {
 Note
};
module.exports = models;
We can now incorporate our database models into our Apollo Server Express applica‐
tion code by importing our models into the src/index.js file:
const models = require('./models');
With our database model code imported, we can adapt our resolvers to save and read
from the database, rather than an in-memory variable. To do this, we’ll rewrite the
notes query to pull the notes from the database by using the MongoDB find method:
notes: async () => {
 return await models.Note.find();
},
With our server running, we can visit the GraphQL Playground in our browser and
run our notes query:
query {
 notes {
 content
 id
 author
 }
}
The expected result will be an empty array, since we have yet to add any data to our
database (Figure 5-1):
{
 "data": {
 "notes": []
 }
}
Reading and Writing Data from Our Application | 39
Figure 5-1. A notes query
To update our newNote mutation to add a note to our database, we’ll use our Mon‐
goDB model’s create method, which we’ll accept an object. For now, we will continue
to hardcode the author’s name:
newNote: async (parent, args) => {
 return await models.Note.create({
 content: args.content,
 author: 'Adam Scott'
 });
}
We can now visit the GraphQL Playground and write a mutation that will add a note
to our database:
mutation {
 newNote (content: "This is a note in our database!") {
 content
 author
 id
 }
}
40 | Chapter 5: Database
Our mutation will return a new note, which contains the content we placed in our
argument, the author’s name, as well as a MongoDB-generated ID (Figure 5-2).
Figure 5-2. A mutation creates a new note in the database
If we now rerun our notes query, we should see our note retrieved from the database!
(See Figure 5-3.)
Figure 5-3. Our notes query returns the data from the database
Reading and Writing Data from Our Application | 41
The last step is to rewrite our notes query to pull a specific note from our database,
using the unique ID that MongoDB assigns to each entry. To do so, we’ll use Mon‐
goose’s findbyId method:
note: async (parent, args) => {
 return await models.Note.findById(args.id);
}
We can now write a query, using the unique ID we see in our notes query or newNote
mutation, to retrieve an individual note from our database. To do so, we’ll write a
note query with an id argument (Figure 5-4):
query {
 note(id: "5c7bff794d66461e1e970ed3") {
 id
 content
 author
 }
}
Your Note ID
The ID used in the previous example is unique to my local data‐
base. Be sure to copy an ID from your own query or mutation
results.
Figure 5-4. A query for an individual note
Our final src/index.js file will look as follows:
const express = require('express');
const { ApolloServer, gql } = require('apollo-server-express');
require('dotenv').config();
const db = require('./db');
const models = require('./models');
42 | Chapter 5: Database
// Run our server on a port specified in our .env file or port 4000
const port = process.env.PORT || 4000;
const DB_HOST = process.env.DB_HOST;
// Construct a schema, using GraphQL's schema language
const typeDefs = gql`
 type Note {
 id: ID
 content: String
 author: String
 }
 type Query {
 hello: String
 notes: [Note]
 note(id: ID): Note
 }
 type Mutation {
 newNote(content: String!): Note
 }
`;
// Provide resolver functions for our schema fields
const resolvers = {
 Query: {
 hello: () => 'Hello world!',
 notes: async () => {
 return await models.Note.find();
 },
 note: async (parent, args) => {
 return await models.Note.findById(args.id);
 }
 },
 Mutation: {
 newNote: async (parent, args) => {
 return await models.Note.create({
 content: args.content,
 author: 'Adam Scott'
 });
 }
 }
};
const app = express();
db.connect(DB_HOST);
// Apollo Server setup
const server = new ApolloServer({ typeDefs, resolvers });
// Apply the Apollo GraphQL middleware and set the path to /api
Reading and Writing Data from Our Application | 43
server.applyMiddleware({ app, path: '/api' });
app.listen({ port }, () =>
 console.log(
 `GraphQL Server running at http://localhost:${port}${server.graphqlPath}`
 )
);
We can now read and write data from our database with our GraphQL API! Try
adding more notes, viewing the full list of notes using the notes query, and viewing
the content of individual notes by utilizing the note query.
Conclusion
In this chapter you learned to use MongoDB and the Mongoose library with our API.
A database, such as MongoDB, allows us to securely store and retrieve our applica‐
tion’s data. An object modeling library, such as Mongoose, simplifies working with a
database by providing tools for database queries and data validation. In the next
chapter, we’ll update our API to have full CRUD (create, read, update, and delete)
functionality with our database content.
44 | Chapter 5: Database
CHAPTER 6
CRUD Operations
The first time I heard the term “CRUD application,” I wrongfully assumed that it
referred to an application that did something dirty or tricky. Admittedly, “CRUD”
sounds as if it refers to something that would be scraped off the bottom of a shoe. In
fact, the acronym was first popularized in the early 1980s by British technology
author James Martin in reference to applications that create, read, update, and delete
data. Though the term has been around for well over a quarter of a century, it still
applies to many applications developed today. Consider the applications that you
interact with daily—to-do lists, spreadsheets, content management systems, text edi‐
tors, social media websites, and several others—and chances are that many of them
fall into the CRUD application format. A user creates some data, accesses or reads
data, and may update or delete that data.
Our Notedly application will follow the CRUD pattern. Users will be able to create,
read, update, and delete their own notes. In this chapter, we’ll implement the essential
CRUD functionality of our API by connecting our resolvers and database.
Separating Our GraphQL Schema and Resolvers
Currently our src/index.js file is home to our Express/Apollo server code as well as
our API’s schema and resolvers. As you can imagine, this could get a bit unwieldy as
our codebase grows. Before this happens, let’s take some time to do a minor refactor
that separates our schema, resolvers, and server code.
To begin, let’s move our GraphQL schema to its own file. First, we’ll make a new file
called src/schema.js in the src folder and then move our schema content, found in our
typeDefs variable, to that file. To do so, we’ll also need to import the gql schema lan‐
guage that comes with the apollo-server-express package and export our schema
45
as a module, using Node’s module.exports method. While we’re at it, we can also
remove the hello query, which we won’t need in our final application:
const { gql } = require('apollo-server-express');
module.exports = gql`
 type Note {
 id: ID!
 content: String!
 author: String!
 }
 type Query {
 notes: [Note!]!
 note(id: ID!): Note!
 }
 type Mutation {
 newNote(content: String!): Note!
 }
`;
We can now update our src/index.js file to use this external schema file by importing
it and removing the gql import from apollo-server-express like so:
const { ApolloServer } = require('apollo-server-express');
const typeDefs = require('./schema');
Now that we have isolated our GraphQL schema to its own file, let’s do something
similar for our GraphQL resolver code. Our resolver code will encompass the vast
majority of our API’s logic, so first we’ll create a folder to house this code, called
resolvers. Within the src/resolvers directory we’ll begin with three files: src/resolvers/
index.js, src/resolvers/query.js, and src/resolvers/mutation.js. Similar to the pattern we
followed in our database models, the src/resolvers/index.js file will be used to import
our resolver code into a single exported module. Go ahead and set up this file like so:
const Query = require('./query');
const Mutation = require('./mutation');
module.exports = {
 Query,
 Mutation
};
Now you can set up the src/resolvers/query.js for the API query code:
module.exports = {
 notes: async () => {
 return await models.Note.find()
 },
 note: async (parent, args) => {
46 | Chapter 6: CRUD Operations
 return await models.Note.findById(args.id);
 }
}
Then move the mutation code to the src/resolvers/mutation.js file:
module.exports = {
 newNote: async (parent, args) => {
 return await models.Note.create({
 content: args.content,
 author: 'Adam Scott'
 });
 }
}
Next, the server to import the resolver code by adding the following line to the src/
index.js file:
const resolvers = require('./resolvers');
The final step in refactoring our resolvers is to connect them to our database models.
As you may have noticed, our resolver modules reference these models, but have no
way of accessing them. To fix this problem, we’ll use a concept that Apollo Server calls
context, which allows us to pass specific information along from our server code to an
individual resolver with each request. For now, this may feel excessive, but it will be
useful for incorporating user authentication into our application. To do this, we’ll
update our Apollo Server setup code in src/index.js with a context function that will
return our database models:
// Apollo Server setup
const server = new ApolloServer({
 typeDefs,
 resolvers,
 context: () => {
 // Add the db models to the context
 return { models };
 }
});
Now we’ll update each of our resolvers to make use of this context by adding
{ models } as the third parameter in each function.
Do the following in src/resolvers/query.js:
module.exports = {
 notes: async (parent, args, { models }) => {
 return await models.Note.find()
 },
 note: async (parent, args, { models }) => {
 return await models.Note.findById(args.id);
 }
}
Separating Our GraphQL Schema and Resolvers | 47
Move the mutation code to the src/resolvers/mutation.js file:
module.exports = {
 newNote: async (parent, args, { models }) => {
 return await models.Note.create({
 content: args.content,
 author: 'Adam Scott'
 });
 }
}
Our src/index.js file will now be simplified as follows:
const express = require('express');
const { ApolloServer } = require('apollo-server-express');
require('dotenv').config();
// Local module imports
const db = require('./db');
const models = require('./models');
const typeDefs = require('./schema');
const resolvers = require('./resolvers');
// Run our server on a port specified in our .env file or port 4000
const port = process.env.PORT || 4000;
const DB_HOST = process.env.DB_HOST;
const app = express();
db.connect(DB_HOST);
// Apollo Server setup
const server = new ApolloServer({
 typeDefs,
 resolvers,
 context: () => {
 // Add the db models to the context
 return { models };
 }
});
// Apply the Apollo GraphQL middleware and set the path to /api
server.applyMiddleware({ app, path: '/api' });
app.listen({ port }, () =>
 console.log(
 `GraphQL Server running at http://localhost:${port}${server.graphqlPath}`
 )
);
48 | Chapter 6: CRUD Operations
Writing Our GraphQL CRUD Schema
Now that we’ve refactored our code for flexibility, let’s begin implementing our CRUD
operations. We are already able to Create and Read notes, which leaves us with imple‐
menting our Update and Delete functionality. First, we’ll want to update our schema.
Since update and delete operations will make changes to our data, they will be muta‐
tions. Our update note will require an ID argument to locate the note as well as the
new note content. The update query will then return the newly updated note. For our
delete operation, our API will return a Boolean value of true to inform us that the
note deletion was successful.
Update the Mutation schema in src/schema.js as follows:
type Mutation {
 newNote(content: String!): Note!
 updateNote(id: ID!, content: String!): Note!
 deleteNote(id: ID!): Boolean!
}
With these additions, our schema is now ready to perform CRUD operations.
CRUD Resolvers
With our schema in place, we can now update our resolvers to either remove or
update a note. Let’s begin with our deleteNote mutation. To delete a note, we will use
Mongoose’s findOneAndRemove method and pass it the id of the item that we want to
delete. If our item is found and deleted, we’ll return true to the client, but if our item
fails to delete, we’ll return false.
In src/resolvers/mutation.js, add the following, within the module.exports object:
deleteNote: async (parent, { id }, { models }) => {
 try {
 await models.Note.findOneAndRemove({ _id: id});
 return true;
 } catch (err) {
 return false;
 }
},
Now we can run our mutation in the GraphQL Playground. In a new tab in the Play‐
ground, write the following mutation, being sure to use an ID from one of the notes
in your database:
mutation {
 deleteNote(id: "5c7d1aacd960e03928804308")
}
Writing Our GraphQL CRUD Schema | 49
If the note was successfully deleted, you should receive a response of true:
{
 "data": {
 "deleteNote": true
 }
}
If you pass a nonexistent ID, you’ll receive a response of "deleteNote": false.
With our delete functionality in place, let’s write our updateNote mutation. To do
this, we will use Mongoose’s findOneAndUpdate method. This method will take an
initial parameter of a query to find the correct note in the database, followed by a sec‐
ond parameter where we’ll $set new note content. Lastly, we’ll pass a third parameter
of new: true, which instructs the database to return the updated note content to us.
In src/resolvers/mutation.js, add the following within the module.exports object:
updateNote: async (parent, { content, id }, { models }) => {
 return await models.Note.findOneAndUpdate(
 {
 _id: id,
 },
 {
 $set: {
 content
 }
 },
 {
 new: true
 }
 );
},
We can now visit the GraphQL Playground in our browser to try out our updateNote
mutation. In a new tab in the playground, write a mutation with the parameters of an
id and content:
mutation {
 updateNote(
 id: "5c7d1f0a31191c4413edba9d",
 content: "This is an updated note!"
 ){
 id
 content
 }
}
If our mutation worked as intended, the GraphQL response should read as follows:
{
 "data": {
 "updateNote": {
50 | Chapter 6: CRUD Operations
 "id": "5c7d1f0a31191c4413edba9d",
 "content": "This is an updated note!"
 }
 }
}
If we pass an incorrect ID, the response fails and we will receive an internal server
error with an Error updating note message.
We are now able to create, read, update, and delete notes. With this we have full
CRUD functionality in our API.
Date and Time
When we created our database schema, we requested that Mongoose automatically
store timestamps to record when entries are created and updated in the database.
This information will be useful in our application, as it will allow us to show the user
when a note was created or last edited within our user interface. Let’s add createdAt
and updatedAt fields to our schema so we can return these values.
You may recall that GraphQL allows for the default types of String, Boolean, Int,
Float, and ID. Unfortunately GraphQL does not come with a built-in date scalar
type. We could use the String type, but this would mean that we wouldn’t be taking
advantage of the type validation that GraphQL offers, ensuring that our dates and
times are actually dates and times. Instead, we’ll create a custom scalar type. A cus‐
tom type allows us to define a new type and validate it against every query and muta‐
tion that requests data of that type.
Let’s update our GraphQL schema in src/schema.js by adding a custom scalar at the
top of our GQL string literal:
module.exports = gql`
 scalar DateTime
 ...
`;
Now, within the Note type, add the createdAt and updatedAt fields:
type Note {
 id: ID!
 content: String!
 author: String!
 createdAt: DateTime!
 updatedAt: DateTime!
}
Date and Time | 51
The last step is to validate this new type. While we can write our own validation, for
our use case we’ll use the graphql-iso-date package. To do so we’ll add validation to
any resolver function that requests a value with a type of DateTime.
In the src/resolvers/index.js file, import the package and add a DateTime value to the
exported resolvers like so:
const Query = require('./query');
const Mutation = require('./mutation');
const { GraphQLDateTime } = require('graphql-iso-date');
module.exports = {
 Query,
 Mutation,
 DateTime: GraphQLDateTime
};
Now if we visit the GraphQL Playground in our browser and refresh the page, we can
validate that our custom types work as intended. If we consult our schema, we can see
that the createdAt and updatedAt fields have a type of DateTime. As Figure 6-1
shows, the documentation of this type states that it is a “date-time string at UTC.”
Figure 6-1. Our schema now features DateTime types
52 | Chapter 6: CRUD Operations
To test this, let’s write a newNote mutation in the GraphQL Playground that includes
our date fields:
mutation {
 newNote (content: "This is a note with a custom type!") {
 content
 author
 id
 createdAt
 updatedAt
 }
}
This will return createdAt and updatedAt values as an ISO-formatted date. If we
then run an updateNote mutation against the same note, we’ll see an updatedAt value
that differs from the createdAt date.
For more information on defining and validating custom scalar types, I recommend
Apollo Server’s “Custom scalars and enums” documentation.
Conclusion
In this chapter we added create, read, update, and delete (CRUD) functionality to our
API. CRUD applications are an incredibly common pattern used by many applica‐
tions. I encourage you to look at the applications that you interact with daily and
think about how their data may fit into this pattern. In the next chapter, we will add
functionality to our API to create and authenticate user accounts.
Conclusion | 53

CHAPTER 7
User Accounts and Authentication
Picture yourself walking down a dark alley. You are on your way to join the “Secret
Club for Super Cool People” (if you’re reading this, you are a well-deserving mem‐
ber). As you enter the hidden door to the club, you are greeted by a receptionist who
hands you a form to complete. On the form, you must enter your name and a pass‐
word, which will be known only by you and the receptionist.
Once you have completed the form, you hand it back to the receptionist, who goes to
the back room of the club. In the back room, the receptionist uses a secret key to
encrypt your password and then stores the encrypted password in a locked file vault.
The receptionist then stamps a coin, on which is pressed your unique membership
ID. Upon returning to the front room, the receptionist hands you the coin, which you
tuck away in your pocket. Now each time you return to the club, you need only show
your coin to gain entrance.
This interaction may sound like something out of a low-budget spy movie, but it’s
nearly identical to the process that is followed each time we sign up for a web applica‐
tion. In this chapter, we’ll learn how to build GraphQL mutations that will allow a
user to create an account and sign in to our application. We’ll also learn how to
encrypt the user’s password and return a token to the user, which they can use to ver‐
ify their identity when they interact with our application.
Application Authentication Flow
Before we get started, let’s step back and map out the flow users will follow when they
sign up for an account and log in to an existing account. If you don’t yet understand
all of the concepts covered here, don’t worry: we will approach them bit by bit. First,
let’s review the account creation flow:
55
1. A user enters their intended email, username, and password into a field in a user
interface (UI), such as the GraphQL Playground, a web application, or a mobile
application.
2. The UI sends a GraphQL mutation to our server with the user’s information.
3. The server encrypts the password and stores the user’s information in the
database.
4. The server returns a token to the UI, which contains the user’s ID.
5. The UI stores this token, for a specified period of time, and sends it with every
request to the server to verify the user.
Now let’s look at the user sign-in flow:
1. A user enters their email or username and password into a field in a UI.
2. The UI sends a GraphQL mutation to our server with this information.
3. The server decrypts the password stored in the database and compares it with the
one the user entered.
4. If the passwords match, the server returns a token to the UI, which contains the
user’s ID.
5. The UI stores this token, for a specified period of time, and sends it with every
request to the server.
As you can see, these flows are very similar to our “secret club” flow. In this chapter
we’ll focus on implementing the API portions of these interactions.
Password Reset Flow
You’ll notice that our application does not allow users to change
their password. We could allow users to reset their password with a
single mutation resolver, but it is much more secure to verify the
reset request via email first. For brevity’s sake we won’t be imple‐
menting password reset functionality in this book, but if you are
interested in examples and resources for creating a password reset
flow, please visit the JavaScript Everywhere Spectrum community.
Encryption and Tokens
In our exploration of the user authentication flow, I mentioned encryption and
tokens. These sound like mythological dark arts, so let’s take a moment to look at
each of these in more detail.
56 | Chapter 7: User Accounts and Authentication
Encrypting Passwords
To effectively encrypt user passwords, we should use a combination of hashing and
salting. Hashing is the act of obscuring a string of text by turning it into a seemingly
random string. Hashing functions are “one way,” meaning that once the text is hashed
it cannot be reverted to the original string. When a password is hashed, the plain text
of the password is never stored in our database. Salting is the act of generating a ran‐
dom string of data that will be used in addition to the hashed password. This ensures
that even if two user passwords are the same, the hashed and salted versions will be
unique.
bcrypt is a popular hashing function based on the blowfish cipher and commonly
used within a range of web frameworks. In Node.js development we can use the
bcrypt module to both salt and hash our passwords.
In our application code we would require the bcrypt module and write a function to
handle the salting and hashing.
Salting and Hashing Examples
The following example is for illustrative purposes. We will integrate
password salting and hashing with bcrypt later in the chapter.
// require the module
const bcrypt = require('bcrypt');
// the cost of processing the salting data, 10 is the default
const saltRounds = 10;
// function for hashing and salting
const passwordEncrypt = async password => {
 return await bcrypt.hash(password, saltRounds)
};
In this example, I could pass a password of PizzaP@rty99, which generates a salt of
$2a$10$HF2rs.iYSvX1l5FPrX697O and the hashed and salted password of $2a
$10$HF2rs.iYSvX1l5FPrX697O9dYF/O2kwHuKdQTdy.7oaMwVga54bWG (which is the salt
plus an encrypted password string).
Now when checking a user’s password against the hashed and salted password, we
will use the bcrypt’s compare method:
// password is a value provided by the user
// hash is retrieved from our DB
const checkPassword = async (plainTextPassword, hashedPassword) => {
 // res is either true or false
 return await bcrypt.compare(hashedPassword, plainTextPassword)
};
Encryption and Tokens | 57
With the user passwords encrypted, we are able to safely store them in a database.
JSON Web Tokens
As a user it would be extremely frustrating if we needed to enter our username and
password each time we wanted to access a single protected page of a site or applica‐
tion. Instead, we can securely store a user’s ID on their device within a JSON Web
Token. With each request the user makes from the client, they can send that token,
which the server will use to identify the user.
A JSON Web Token (JWT) consists of three parts:
Header
General information about the token and type of signing algorithm that is being
used
Payload
The information that we’ve intentionally stored within the token (such as the
username or ID)
Signature
A means to verify the token
If we were to look at the token, it would appear to be made up of random characters
with each part separated by a period: xx-header-xx.yy-payload-yy.zz-signaturezz.
In our application code we can use the jsonwebtoken module to generate and vali‐
date our tokens. To do this we pass in the information we wish to store, along with a
secret password, which would typically be stored within our .env file.
const jwt = require('jsonwebtoken');
// generate a JWT that stores a user id
const generateJWT = await user => {
 return await jwt.sign({ id: user._id }, process.env.JWT_SECRET);
}
// validate the JWT
const validateJWT = await token => {
 return await jwt.verify(token, process.env.JWT_SECRET);
}
58 | Chapter 7: User Accounts and Authentication
JWTs Versus Sessions
If you’ve worked with user authentication in web applications
before, you’ve likely come across user sessions. Session information
is stored locally, typically in a cookie, and verified against an inmemory data store (such as Redis, though traditional databases can
be used as well). There is much debate about which is better, JWTs
or sessions, but I’ve found that JWTs offer the most flexibility, par‐
ticularly when integrating with nonweb environments such as
native mobile applications. Though sessions work well with
GraphQL, JWTs are also the recommended approach in the
GraphQL Foundation and Apollo Server documentation.
By using JWTs, we can securely return and store a user’s ID with the client
application.
Integrating Authentication into Our API
Now that you have a solid understanding of the components of user authentication,
we’ll implement the ability for users to sign up and sign in to our application. To do
this we’ll be updating both our GraphQL and Mongoose schemas, writing signUp and
signIn mutation resolvers that generate a user token, and validating the token on
each request to the server.
User Schemas
To begin we will update our GraphQL schema by adding a User type and updating
the Note type’s author field to reference the User. To do so, update the src/schema.js
file as follows:
type Note {
id: ID!
content: String!
author: User!
createdAt: DateTime!
updatedAt: DateTime!
}
type User {
id: ID!
username: String!
email: String!
avatar: String
notes: [Note!]!
}
When a user signs up for our application, they will submit a username, email address,
and password. When a user signs in to our application, they will send a mutation
Integrating Authentication into Our API | 59
containing their username or email address along with a password. If a sign-up or
sign-in mutation is successful, the API will return a token as a string. To accomplish
this in our schema, we will need to add two new mutations to our src/schema.js file,
each of which will return a String, which will be our JWT:
type Mutation {
 ...
 signUp(username: String!, email: String!, password: String!): String!
 signIn(username: String, email: String, password: String!): String!
}
Now that our GraphQL schema has been updated, we also need to update our data‐
base models. To do this we’ll create a Mongoose schema file in src/models/user.js. This
file will be set up similarly to our note model file, with fields for username, email,
password, and avatar. We will also require the username and email fields to be unique
in our database by setting index: { unique: true }.
To create the user database model, enter the following in your src/models/user.js file:
const mongoose = require('mongoose');
const UserSchema = new mongoose.Schema(
 {
 username: {
 type: String,
 required: true,
 index: { unique: true }
 },
 email: {
 type: String,
 required: true,
 index: { unique: true }
 },
 password: {
 type: String,
 required: true
 },
 avatar: {
 type: String
 }
 },
 {
 // Assigns createdAt and updatedAt fields with a Date type
 timestamps: true
 }
);
const User = mongoose.model('User', UserSchema);
module.exports = User;
60 | Chapter 7: User Accounts and Authentication
With our user model file in place, we now must update the src/models/index.js to
export the model:
const Note = require('./note');
const User = require('./user');
const models = {
 Note,
 User
};
module.exports = models;
Authentication Resolvers
With our GraphQL and Mongoose schemas written, we can implement the resolvers
that will allow a user to sign up and sign in to our application.
First, we need to add a value to the JWT_SECRET variable in our .env file. This value
should be a string without spaces. It will be used to sign our JWT, which allows us to
verify them when they are decoded.
JWT_SECRET=YourPassphrase
Once we have created this variable, we can import the required packages within our
mutation.js file. We will utilize the third-party bcrypt, jsonwebtoken, mongoose, and
dotenv packages as well as importing Apollo Server’s AuthenticationError and For
biddenError utilities. Additionally, we’ll import the gravatar utility function, which
I’ve included with the project. This will generate a Gravatar image URL from a user’s
email address.
In src/resolvers/mutation.js, enter the following:
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const {
 AuthenticationError,
 ForbiddenError
} = require('apollo-server-express');
require('dotenv').config();
const gravatar = require('../util/gravatar');
Now we can write our signUp mutation. This mutation will accept a username, email
address, and password as parameters. We will normalize the email address and user‐
name by trimming any whitespace and converting it to all lowercase. Next, we will
encrypt the user’s password using the bcrypt module. We will also generate a Grava‐
tar image URL for user avatars by using our helper library. Once we have performed
these actions, we will store the user in the database and return a token to the user. We
Integrating Authentication into Our API | 61
can set this all up within a try/catch block, so that our resolver returns an intention‐
ally vague error to the client if there are any issues with the sign-up process.
To accomplish all of this, write the signUp mutation as follows within the src/
resolvers/mutation.js file:
signUp: async (parent, { username, email, password }, { models }) => {
 // normalize email address
 email = email.trim().toLowerCase();
 // hash the password
 const hashed = await bcrypt.hash(password, 10);
 // create the gravatar url
 const avatar = gravatar(email);
 try {
 const user = await models.User.create({
 username,
 email,
 avatar,
 password: hashed
 });
 // create and return the json web token
 return jwt.sign({ id: user._id }, process.env.JWT_SECRET);
 } catch (err) {
 console.log(err);
 // if there's a problem creating the account, throw an error
 throw new Error('Error creating account');
 }
},
Now, if we switch over to the GraphQL Playground in our browser, we can try out
our signUp mutation. To do so we’ll write a GraphQL mutation with username, email,
and password values:
mutation {
 signUp(
 username: "BeeBoop",
 email: "robot@example.com",
 password: "NotARobot10010!"
 )
}
When we run the mutation, our server will return a token like this (Figure 7-1):
"data": {
 "signUp": "eyJhbGciOiJIUzI1NiIsInR5cCI6..."
}
}
62 | Chapter 7: User Accounts and Authentication
Figure 7-1. e signUp mutation in the GraphQL Playground
The next step will be to write our signIn mutation. This mutation will accept the
user’s username, email, and password. It will then find the user in the database, based
on the username or email address. Once the user is located, it will decrypt the pass‐
word stored in the database and compare it with the one the user has entered. If the
user and password match, our application will return a token to the user. If they don’t
match, we’ll want to throw an error.
Write this mutation as follows in the src/resolvers/mutation.js file:
signIn: async (parent, { username, email, password }, { models }) => {
 if (email) {
 // normalize email address
 email = email.trim().toLowerCase();
 }
 const user = await models.User.findOne({
 $or: [{ email }, { username }]
 });
 // if no user is found, throw an authentication error
 if (!user) {
 throw new AuthenticationError('Error signing in');
 }
 // if the passwords don't match, throw an authentication error
 const valid = await bcrypt.compare(password, user.password);
 if (!valid) {
 throw new AuthenticationError('Error signing in');
 }
 // create and return the json web token
 return jwt.sign({ id: user._id }, process.env.JWT_SECRET);
}
Integrating Authentication into Our API | 63
We can now visit the GraphQL Playground in our browser and try out the signIn
mutation, using the account we created with our signUp mutation:
mutation {
 signIn(
 username: "BeeBoop",
 email: "robot@example.com",
 password: "NotARobot10010!"
 )
}
Again, if successful, our mutation should resolve with a JWT (Figure 7-2):
{
 "data": {
 "signIn": "<TOKEN VALUE>"
 }
}
Figure 7-2. e signIn mutation in the GraphQL Playground
With these two resolvers in place, users will be able to both sign up for and sign in to
our application using JWTs. To experiment with this, try adding more accounts and
even intentionally entering incorrect information, such as passwords that do not
match, to see what the GraphQL API returns.
Adding the User to the Resolver Context
Now that a user can use a GraphQL mutation to receive a unique token, we’ll need to
verify that token on each request. Our expectation will be that our client, whether it
be web, mobile, or desktop, will send the token with the request in an HTTP header
named Authorization. We can then read the token from the HTTP header, decode it
using our JWT_SECRET variable, and pass along the user’s information with the context
to each GraphQL resolver. By doing this, we can determine if a signed-in user is mak‐
ing a request, and if so, which user it is.
64 | Chapter 7: User Accounts and Authentication
First, import the jsonwebtoken module into the src/index.js file:
const jwt = require('jsonwebtoken');
With the module imported, we can add a function that will verify the validity of the
token:
// get the user info from a JWT
const getUser = token => {
 if (token) {
 try {
 // return the user information from the token
 return jwt.verify(token, process.env.JWT_SECRET);
 } catch (err) {
 // if there's a problem with the token, throw an error
 throw new Error('Session invalid');
 }
 }
};
Now, within each GraphQL request we will grab the token from the header of the
request, attempt to verify the validity of the token, and add the user’s information to
the context. Once this is done, each GraphQL resolver will have access to the user ID
we stored in the token.
// Apollo Server setup
const server = new ApolloServer({
 typeDefs,
 resolvers,
 context: ({ req }) => {
 // get the user token from the headers
 const token = req.headers.authorization;
 // try to retrieve a user with the token
 const user = getUser(token);
 // for now, let's log the user to the console:
 console.log(user);
 // add the db models and the user to the context
 return { models, user };
 }
});
Though we’re not yet performing user interactions, we can test our user context
within the GraphQL Playground. In the lower-left corner of the GraphQL Play‐
ground UI, there is a space labeled HTTP Headers. In that portion of the UI, we can
add a header that contains a JWT that was returned in either our signUp or signIn
mutation as follows (Figure 7-3):
{
 "Authorization": "<YOUR_JWT>"
}
Adding the User to the Resolver Context | 65
Figure 7-3. e authorization header in the GraphQL Playground
We can test this authorization header by passing it along with any query or mutation
in the GraphQL Playground. To do this, we’ll write a simple notes query and include
the Authorization header (Figure 7-4).
query {
 notes {
 id
 }
}
Figure 7-4. e authorization header and query in the GraphQL Playground
66 | Chapter 7: User Accounts and Authentication
If our authentication is successful, we should see an object containing the user’s ID
logged to our terminal application’s output, as shown in Figure 7-5.
Figure 7-5. e user object in our terminal’s console.log output
With all of these pieces in place, we are now able to authenticate users in our API.
Conclusion
User account creation and sign-in flows can feel mysterious and overwhelming, but
by taking it piece by piece, we can implement a stable and secure authentication flow
in our API. In this chapter, we created both sign-up and sign-in user flows. These are
a small fragment of the account management ecosystem, but will provide us with a
stable foundation on which to build. In the next chapter we’ll implement user-specific
interactions in our API, which will assign ownership to notes and activities within the
application.
Conclusion | 67

CHAPTER 8
User Actions
Imagine you had just joined a club (remember the “Secret Club for Super Cool Peo‐
ple”?), but when you showed up for the first time there was nothing to do. The club
was a big, empty room with people wandering in and out with no way of interacting
with the club or one another. I’m a bit of an introvert, so this doesn’t sound that bad,
but I wouldn’t be willing to pay a membership fee for it.
Right now our API is essentially a big, useless club. We have a way to create data and a
way for users to sign in, but nothing allows a user to own that data. In this chapter,
we’ll be addressing this by adding user interactions. We’ll write the code that will
enable a user to own the notes they create, limit who can delete or modify a note, and
enable users to “favorite” a note that they like. Additionally, we’ll enable API users to
make nested queries, allowing our UIs to write simple queries that relate users to
notes.
Before We Get Started
In this chapter, we’ll be making some pretty significant changes to our notes files.
Since we have a small amount of data in our database, you may find it easier to
remove the existing notes from your local database. This isn’t necessary, but can
reduce confusion as you work through this chapter.
To do this, we’ll go into the MongoDB shell, ensure that we’re referencing the notedly
database (the name of the database in our .env file), and use MongoDB’s .remove()
method. From your terminal, type the following:
$ mongo
$ use notedly
$ db.notes.remove({})
69
Attach a User to New Notes
In the previous chapter we updated our src/index.js file so that when a user makes a
request, we check for a JWT. If the token exists, we decode it and add the current user
to our GraphQL context. This allows us to send the user’s information to each
resolver function that we call. We’ll update our existing GraphQL mutations to verify
the user’s information. To do this we’ll utilize Apollo Server’s AuthenticationError
and ForbiddenError methods, which will allow us to throw appropriate errors. These
will help us both debug in development as well as send appropriate responses to the
client.
Before we get started, we’ll need to import the mongoose package into our mutations.js
resolver file. This will allow us to appropriately assign cross-referencing MongoDB
object IDs to our fields. Update the module imports at the top of src/resolvers/
mutation.js as follows:
const mongoose = require('mongoose');
Now, in our newNote mutation, we’ll add user as a function parameter, then check to
see if a user is passed into the function. If a user ID is not found, we’ll throw an
AuthenticationError, as a person must be signed in to our service to create a new
note. Once we have verified that the request has been made by an authenticated user,
we can create the note in the database. In doing so, we will now assign the author the
user ID that is passed to the resolver. This will allow us to reference the creating user
from the note itself.
In src/resolvers/mutation.js, add the following:
// add the users context
newNote: async (parent, args, { models, user }) => {
 // if there is no user on the context, throw an authentication error
 if (!user) {
 throw new AuthenticationError('You must be signed in to create a note');
 }
 return await models.Note.create({
 content: args.content,
 // reference the author's mongo id
 author: mongoose.Types.ObjectId(user.id)
 });
},
The last step is to apply the cross-referencing to the data in our database. To do this,
we will need to update the author field of our MongoDB notes schema. In /src/
models/note.js, update the author field as follows:
author: {
 type: mongoose.Schema.Types.ObjectId,
 ref: 'User',
70 | Chapter 8: User Actions
 required: true
}
With this reference in place, all new notes will accurately record and cross-reference
the author from the context of the request. Let’s try this out by writing a newNote
mutation in the GraphQL Playground:
mutation {
 newNote(content: "Hello! This is a user-created note") {
 id
 content
 }
}
When writing the mutation, we also must be sure to pass a JWT in the
Authorization header (see Figure 8-1):
{
 "Authorization": "<YOUR_JWT>"
}
How to Retrieve a JWT
If you don’t have the JWT handy, you can perform a signIn muta‐
tion to retrieve one.
Figure 8-1. A newNote mutation in the GraphQL Playground
Attach a User to New Notes | 71
For now, our API doesn’t return the author information, but we can verify that the
author was added correctly by looking up the note in the MongoDB shell. In a termi‐
nal window, type the following:
mongo
db.notes.find({_id: ObjectId("A DOCUMENT ID HERE")})
The returned value should include an author key, with a value of an object ID.
User Permissions for Updates and Deletes
Now we can add user checks to our deleteNote and updateNote mutations as well.
These will require that we check both that a user is passed to the context and whether
that user is the owner of the note. To accomplish this, we’ll check if the user ID stored
in the author field of our database matches the user ID that is passed into the resolver
context.
In src/resolvers/mutation.js, update the deleteNote mutation as follows:
deleteNote: async (parent, { id }, { models, user }) => {
 // if not a user, throw an Authentication Error
 if (!user) {
 throw new AuthenticationError('You must be signed in to delete a note');
 }
 // find the note
 const note = await models.Note.findById(id);
 // if the note owner and current user don't match, throw a forbidden error
 if (note && String(note.author) !== user.id) {
 throw new ForbiddenError("You don't have permissions to delete the note");
 }
 try {
 // if everything checks out, remove the note
 await note.remove();
 return true;
 } catch (err) {
 // if there's an error along the way, return false
 return false;
 }
},
Now, also in src/resolvers/mutation.js, update the updateNote mutation as follows:
updateNote: async (parent, { content, id }, { models, user }) => {
 // if not a user, throw an Authentication Error
 if (!user) {
 throw new AuthenticationError('You must be signed in to update a note');
 }
 // find the note
72 | Chapter 8: User Actions
 const note = await models.Note.findById(id);
 // if the note owner and current user don't match, throw a forbidden error
 if (note && String(note.author) !== user.id) {
 throw new ForbiddenError("You don't have permissions to update the note");
 }
 // Update the note in the db and return the updated note
 return await models.Note.findOneAndUpdate(
 {
 _id: id
 },
 {
 $set: {
 content
 }
 },
 {
 new: true
 }
 );
},
User Queries
With our existing mutations updated to include user checks, let’s also add some userspecific queries. To do this, we’ll add three new queries:
user
Given a specific username, returns the user’s information
users
Returns a list of all users
me
Returns the user information for the current user
Before we write the query resolver code, add these queries to the GraphQL src/
schema.js file like so:
type Query {
 ...
 user(username: String!): User
 users: [User!]!
 me: User!
}
Now in the src/resolvers/query.js file, write the following resolver query code:
module.exports = {
 // ...
 // add the following to the existing module.exports object:
User Queries | 73
 user: async (parent, { username }, { models }) => {
 // find a user given their username
 return await models.User.findOne({ username });
 },
 users: async (parent, args, { models }) => {
 // find all users
 return await models.User.find({});
 },
 me: async (parent, args, { models, user }) => {
 // find a user given the current user context
 return await models.User.findById(user.id);
 }
}
Let’s see how these look in our GraphQL Playground. First, we can write a user query
to look up the information of a specific user. Be sure to use a username that you’ve
already created:
query {
 user(username:"adam") {
 username
 email
 id
 }
}
This will return a data object, containing the username, email, and ID values for the
specified user (Figure 8-2).
Figure 8-2. e user query in the GraphQL Playground
74 | Chapter 8: User Actions
Now to look up all of the users in our database, we can use the users query, which
will return a data object containing the information of all users (Figure 8-3):
query {
 users {
 username
 email
 id
 }
}
Figure 8-3. e users query in GraphQL Playground
Now we can use a JWT, passed in the HTTP header, to look up information about the
signed-in user, using the me query.
First, be sure to include the token in the HTTP header portion of the GraphQL
Playground:
{
 "Authorization": "<YOUR_JWT>"
}
Now, perform the me query like so (Figure 8-4):
query {
 me {
 username
 email
 id
User Queries | 75
 }
}
Figure 8-4. e me query in GraphQL Playground
With these resolvers in place, we can now query our API for user information.
Toggling Note Favorites
We have one last piece of functionality to add to our user interactions. You may recall
that our application specifications stated that “users will be able to favorite the notes
of other users as well as retrieve a list of their favorites.” Similar to Twitter “hearts”
and Facebook “likes,” we’d like our users to be able to mark (and unmark) a note as a
favorite. To implement this behavior, we’ll follow our standard pattern of updating
the GraphQL schema, then the database model, and lastly the resolver function.
First, we will update our GraphQL schema in ./src/schema.js by adding two new prop‐
erties to our Note type. favoriteCount will track the total number of “favorites” that
a note has received. favoritedBy will contain an array of users who have favorited a
note.
type Note {
 // add the following properties to the Note type
 favoriteCount: Int!
 favoritedBy: [User!]
}
76 | Chapter 8: User Actions
We’ll also add the list of favorites to our User type:
type User {
 // add the favorites property to the User type
 favorites: [Note!]!
}
Next, we will add a mutation in ./src/schema.js called toggleFavorite, which will
resolve by either adding or removing a favorite for the specified note. This mutation
will take a note ID as a parameter and return the specified note.
type Mutation {
 // add toggleFavorite to the Mutation type
 toggleFavorite(id: ID!): Note!
}
Next, we need to update our note model to include the favoriteCount and
favoritedBy properties in our database. favoriteCount will be a Number type with a
default value of 0. favoritedBy will be an array of objects, containing references to
user object IDs in our database. Our full ./src/models/note.js file will look as follows:
const noteSchema = new mongoose.Schema(
 {
 content: {
 type: String,
 required: true
 },
 author: {
 type: String,
 required: true
 },
 // add the favoriteCount property
 favoriteCount: {
 type: Number,
 default: 0
 },
 // add the favoritedBy property
 favoritedBy: [
 {
 type: mongoose.Schema.Types.ObjectId,
 ref: 'User'
 }
 ]
 },
 {
 // Assigns createdAt and updatedAt fields with a Date type
 timestamps: true
 }
);
With our GraphQL schema and database models updated, we can write the
toggleFavorite mutation. This mutation will receive a note ID as a parameter and
Toggling Note Favorites | 77
check to see if the user is already listed in the favoritedBy array. If the user is listed,
we will remove the favorite by decreasing the favoriteCount and removing the user
from the list. If the user has not yet favorited the note, we will increment the favori
teCount by 1 and add the current user to the favoritedBy array. To do all of this, add
the following code to the src/resolvers/mutation.js file:
toggleFavorite: async (parent, { id }, { models, user }) => {
 // if no user context is passed, throw auth error
 if (!user) {
 throw new AuthenticationError();
 }
 // check to see if the user has already favorited the note
 let noteCheck = await models.Note.findById(id);
 const hasUser = noteCheck.favoritedBy.indexOf(user.id);
 // if the user exists in the list
 // pull them from the list and reduce the favoriteCount by 1
 if (hasUser >= 0) {
 return await models.Note.findByIdAndUpdate(
 id,
 {
 $pull: {
 favoritedBy: mongoose.Types.ObjectId(user.id)
 },
 $inc: {
 favoriteCount: -1
 }
 },
 {
 // Set new to true to return the updated doc
 new: true
 }
 );
 } else {
 // if the user doesn't exist in the list
 // add them to the list and increment the favoriteCount by 1
 return await models.Note.findByIdAndUpdate(
 id,
 {
 $push: {
 favoritedBy: mongoose.Types.ObjectId(user.id)
 },
 $inc: {
 favoriteCount: 1
 }
 },
 {
 new: true
 }
 );
78 | Chapter 8: User Actions
 }
},
With this code in place, let’s test our ability to toggle a note favorite in the GraphQL
Playground. Let’s do this with a freshly created note. We’ll begin by writing a newNote
mutation, being sure to include an Authorization header with a valid JWT
(Figure 8-5):
mutation {
 newNote(content: "Check check it out!") {
 content
 favoriteCount
 id
 }
}
Figure 8-5. A newNote mutation
You’ll notice that the favoriteCount of this new note is automatically set to 0,
because that’s the default value we set in our data model. Now, let’s write a
toggleFavorite mutation to mark it as a favorite, passing the ID of the note as a
parameter. Again, be sure to include the Authorization HTTP header, with a valid
JWT.
mutation {
 toggleFavorite(id: "<YOUR_NOTE_ID_HERE>") {
 favoriteCount
Toggling Note Favorites | 79
 }
}
After you run this mutation, the value of the note’s favoriteCount should be 1. If you
rerun the mutation, the favoriteCount will reduce to 0 (Figure 8-6).
Figure 8-6. e toggleFavorite mutation
Users can now mark and unmark notes as favorites. More importantly, I hope that
this functionality demonstrates how you can add new features to a GraphQL applica‐
tion’s API.
Nested Queries
One of the great things about GraphQL is that we can nest queries, allowing us to
write a single query that returns precisely the data we need, rather than multiple
queries. Our GraphQL schema’s User type includes a list of notes by the author in an
array format, while our Notes type includes a reference to its author. As a result, we
can pull a list of notes from a user query or get the author information from a note
query.
This means that we can write a query that looks like this:
query {
 note(id: "5c99fb88ed0ca93a517b1d8e") {
 id
80 | Chapter 8: User Actions
 content
 # the information about the author note
 author {
 username
 id
 }
 }
}
If we currently try to run a nested query like the preceding one, we’ll receive an error.
This is because we haven’t yet written the resolver code that performs the database
lookup for this information.
To enable this functionality, we’ll add two new files in our src/resolvers directory.
In src/resolvers/note.js, add the following:
module.exports = {
 // Resolve the author info for a note when requested
 author: async (note, args, { models }) => {
 return await models.User.findById(note.author);
 },
 // Resolved the favoritedBy info for a note when requested
 favoritedBy: async (note, args, { models }) => {
 return await models.User.find({ _id: { $in: note.favoritedBy } });
 }
};
In src/resolvers/user.js, add this:
module.exports = {
 // Resolve the list of notes for a user when requested
 notes: async (user, args, { models }) => {
 return await models.Note.find({ author: user._id }).sort({ _id: -1 });
 },
 // Resolve the list of favorites for a user when requested
 favorites: async (user, args, { models }) => {
 return await models.Note.find({ favoritedBy: user._id }).sort({ _id: -1 });
 }
};
Now we need to update our src/resolvers/index.js to import and export these new
resolver modules. Overall the src/resolvers/index.js file should now look as follows:
const Query = require('./query');
const Mutation = require('./mutation');
const Note = require('./note');
const User = require('./user');
const { GraphQLDateTime } = require('graphql-iso-date');
module.exports = {
 Query,
 Mutation,
 Note,
Nested Queries | 81
 User,
 DateTime: GraphQLDateTime
};
Now if we write a nested GraphQL query or mutation, we will receive the informa‐
tion that we expect. You can try this out by writing the following note query:
query {
 note(id: "<YOUR_NOTE_ID_HERE>") {
 id
 content
 # the information about the author note
 author {
 username
 id
 }
 }
}
This query should correctly resolve with the author’s username and ID. Another
practical example would be to return information about users who have “favorited” a
note:
mutation {
 toggleFavorite(id: "<YOUR NOTE ID>") {
 favoriteCount
 favoritedBy {
 username
 }
 }
}
With nested resolvers in place, we can write precise queries and mutations that return
exactly the data that we need.
Conclusion
Congratulations! In this chapter our API graduated to being something that users can
truly interact with. This API demonstrates the true power of GraphQL by integrating
user actions, adding new features, and nesting resolvers. We’ve also followed a triedand-true pattern for adding new code to our projects: first write the GraphQL
schema, then write the database model, and finally write the resolver code to query or
update the data. By breaking down the process into these three steps, we can add all
sorts of features to our applications. In the next chapter we’ll look at the final steps
needed to make our API production ready, including pagination and security.
82 | Chapter 8: User Actions
CHAPTER 9
Details
When the now-near-ubiquitous air freshener Febreze was first released, it was a dud.
The original ads showed people using the product to remove specific bad smells, such
as cigarette smoke, resulting in poor sales. Faced with this disappointing outcome, the
marketing team shifted focus to using Febreze as a finishing detail. Now, the ads
depicted someone cleaning a room, fluffing the pillows, and completing the tasks of
refreshing a room with a spritz of Febreze. This reframing of the product caused sales
to skyrocket.
This is a great example of the fact that details matter. Right now we have a working
API, but it’s lacking the finishing touches that will allow us to put it into production.
In this chapter we’ll implement some web and GraphQL application security and user
experience best practices. These details, far exceeding a spritz of air freshener, will be
critical to the safety, security, and usability of our application.
Web Application and Express.js Best Practices
Express.js is the underlying web application framework that powers our API. We can
make a few small tweaks to our Express.js code to provide a solid basis for our
application.
Express Helmet
The Express Helmet middleware is a collection of small security-minded middleware
functions. These will adjust our application’s HTTP headers to be more secure. While
many of these are specific to browser-based applications, enabling Helmet is a simple
step to protect our application from common web vulnerabilities.
83
To enable Helmet, we’ll require the middleware in our application and instruct
Express to use it early in our middleware stack. In the ./src/index.js file, add the
following:
// first require the package at the top of the file
const helmet = require('helmet')
// add the middleware at the top of the stack, after const app = express()
app.use(helmet());
By adding the Helmet middleware, we’re quickly enabling common web security best
practices for our application.
Cross-Origin Resource Sharing
Cross-Origin Resource Sharing (CORS) is the means by which we allow resources to
be requested from another domain. Because our API and UI code will live separately,
we’ll want to enable credentials from other origins. If you’re interested in learning the
ins and outs of CORS, I highly recommend the Mozilla CORS Guide.
To enable CORS, we’ll use the Express.js CORS middleware package in our .src/
index.js file:
// first require the package at the top of the file
const cors = require('cors');
// add the middleware after app.use(helmet());
app.use(cors());
By adding the middleware in this way, we are enabling cross-origin requests from all
domains. This works well for us for now, as we’re in development mode and will
likely be using domains generated by our hosting providers, but by using the middle‐
ware, we could also limit the requests to those of specific origins.
Pagination
Currently our notes and users queries return the full list of notes and users in the
database. This works fine for local development, but as our application grows it will
become unsustainable, as a query that returns potentially hundreds (or thousands) of
notes is expensive and will slow down our database, server, and network. Instead, we
can paginate those queries, returning only a set number of results.
There are two common types of pagination that we could implement. The first type,
oset pagination, works by the client passing an offset number and returning a limited
amount of data. For example, if each page of data were limited to 10 records, and we
wanted to request the third page of data, we could pass an offset of 20. While this is
the most straightforward approach conceptually, it can run into scaling and perfor‐
mance issues.
84 | Chapter 9: Details
The second type of pagination is cursor-based pagination, in which a time-based cur‐
sor or unique identifier is passed as a starting point. We then request a specific
amount of data that follows this record. This approach gives us the greatest control
over our pagination. Additionally, because Mongo’s object IDs are ordered (they
begin with a 4-byte time value), we can easily utilize them as our cursor. To learn
more about Mongo’s object ID, I recommend reading the corresponding MongoDB
documentation.
If this sounds overly conceptual to you, that’s OK. Let’s walk through implementing a
paginated feed of notes as a GraphQL query. First, let’s define what we’ll be creating,
followed by our schema updates, and lastly our resolver code. For our feed we’ll want
to query our API while optionally passing a cursor as a parameter. The API should
then return a limited amount of data, a cursor point representing the last item in the
data set, and a Boolean value if there is an additional page of data to query.
With this description, we can update our src/schema.js file to define this new query.
First, we’ll need to add a NoteFeed type to our file:
type NoteFeed {
 notes: [Note]!
 cursor: String!
 hasNextPage: Boolean!
}
Next, we’ll add our noteFeed query:
type Query {
 # add noteFeed to our existing queries
 noteFeed(cursor: String): NoteFeed
}
With our schema updated, we can write the resolver code for our query. In ./src/
resolvers/query.js, add the following to the exported object:
noteFeed: async (parent, { cursor }, { models }) => {
 // hardcode the limit to 10 items
 const limit = 10;
 // set the default hasNextPage value to false
 let hasNextPage = false;
 // if no cursor is passed the default query will be empty
 // this will pull the newest notes from the db
 let cursorQuery = {};
 // if there is a cursor
 // our query will look for notes with an ObjectId less than that of the cursor
 if (cursor) {
 cursorQuery = { _id: { $lt: cursor } };
 }
 // find the limit + 1 of notes in our db, sorted newest to oldest
 let notes = await models.Note.find(cursorQuery)
Pagination | 85
 .sort({ _id: -1 })
 .limit(limit + 1);
 // if the number of notes we find exceeds our limit
 // set hasNextPage to true and trim the notes to the limit
 if (notes.length > limit) {
 hasNextPage = true;
 notes = notes.slice(0, -1);
 }
 // the new cursor will be the Mongo object ID of the last item in the feed array
 const newCursor = notes[notes.length - 1]._id;
 return {
 notes,
 cursor: newCursor,
 hasNextPage
 };
}
With this resolver in place, we can query our noteFeed, which will return a maxi‐
mum of 10 results. In the GraphQL Playground, we can write a query as follows to
receive a list of notes, their object IDs, their “created at” timestamp, the cursor, and
the next page boolean:
query {
 noteFeed {
 notes {
 id
 createdAt
 }
 cursor
 hasNextPage
 }
}
Since we have more than 10 notes in our database, this returns a cursor as well as a
hasNextPage value of true. With that cursor, we can query the second page of the
feed:
query {
 noteFeed(cursor: "<YOUR OBJECT ID>") {
 notes {
 id
 createdAt
 }
 cursor
 hasNextPage
 }
}
86 | Chapter 9: Details
We can continue to do this for each cursor where the hasNextPage value is true.
With this implementation in place, we’ve created a paginated feed of notes. This will
both allow our UI to request a specific feed of data as well as reduce the burden on
our server and database.
Data Limitations
In addition to establishing pagination, we’ll want to limit the amount of data that can
be requested through our API. This prevent queries that could overload our server or
database.
A simple first step in this process is to limit the amount of data that a query can
return. Two of our queries, users and notes, return all of the matching data from the
database. We could address this by setting a limit() method on our database queries.
For example, in our .src/resolvers/query.js file, we can update our notes query as
follows:
notes: async (parent, args, { models }) => {
 return await models.Note.find().limit(100);
}
While limiting data is a solid start, currently our queries can be written with an
unlimited depth. This means that a single query could be written to retrieve a list of
notes, the author information for each of those notes, the list of favorites of each
author, the author information for each of those favorites, and so on. That’s a lot of
data in one query, and we could keep going! To prevent these types of overnested
queries, we can limit the depth of queries against our API.
Additionally, we might have complex queries that are not overly nested, but still
require heavy computation to return the data. We can protect against these types of
requests by limiting query complexity.
We can implement these limits by using the graphql-depth-limit and graphqlvalidation-complexity packages in our ./src/index.js file:
// import the modules at the top of the file
const depthLimit = require('graphql-depth-limit');
const { createComplexityLimitRule } = require('graphql-validation-complexity');
// update our ApolloServer code to include validationRules
const server = new ApolloServer({
 typeDefs,
 resolvers,
 validationRules: [depthLimit(5), createComplexityLimitRule(1000)],
 context: async ({ req }) => {
 // get the user token from the headers
 const token = req.headers.authorization;
 // try to retrieve a user with the token
Data Limitations | 87
 const user = await getUser(token);
 // add the db models and the user to the context
 return { models, user };
 }
});
With these package additions, we’ve added extra query protection to our API. For
more information on securing a GraphQL API from malicious queries, check out the
fantastic article from Max Stoiber, CTO of Spectrum.
Other Considerations
After building our API, you should have a solid understanding of the fundamentals
of GraphQL development. If you’re eager to dig in more on the topics, some excellent
places to go next would be testing, GraphQL subscriptions, and Apollo Engine.
Testing
OK, I’ll admit it: I feel guilty for not writing about tests in this book. Testing our code
is important because it allows us to comfortably make changes and improves our col‐
laboration with other developers. One of the great things about our GraphQL setup is
that resolvers are simply functions, taking some parameters and returning data. This
makes our GraphQL logic straightforward to test.
Subscriptions
Subscriptions are an incredibly powerful feature of GraphQL, which offers a straight‐
forward way to integrate the publish-subscribe pattern in our application. This means
that a UI can subscribe to be notified or updated when data is published on the
server. This makes GraphQL servers an ideal solution for applications that work with
real-time data. For more information about GraphQL subscriptions, take a look at the
Apollo Server documentation.
Apollo GraphQL Platform
Throughout the development of our API, we’ve been using the Apollo GraphQL
library. In future chapters we’ll also be using the Apollo client libraries to interface
with our API. I’ve chosen these libraries because they are industry standards and
offer a great developer experience for working with GraphQL. If you take your appli‐
cation to production, Apollo, the company who maintains these libraries, also offers a
platform that provides monitoring and tooling for GraphQL APIs. You can learn
more at Apollo’s website.
88 | Chapter 9: Details
Conclusion
In this chapter we added some finishing touches to our application. Though there are
many other options we could implement, at this point we have developed a solid
MVP (minimum viable product). In this state, we are ready to launch our API! In the
next chapter, we’ll deploy our API to a public web server.
Conclusion | 89

CHAPTER 10
Deploying Our API
Imagine if each time a user wanted to access our API to create, read, update, or delete
a note we had to go meet them, laptop in tow. Currently, this is how our API works,
as it is running only on our individual computer. We can resolve this by deploying our
application to a web server.
In this chapter we’ll take two steps:
1. First, we’ll set up a remote database that our API can access.
2. Second, we’ll deploy our API code to a server and connect it to the database.
Once we’ve followed these steps, we can access our API from any web-connected
computer, including the web, desktop, and mobile interfaces that we will develop.
Hosting Our Database
For the first step we’ll use a hosted database solution. For our Mongo database, we’ll
be using MongoDB Atlas. This is a fully managed cloud offering backed by the orga‐
nization behind Mongo itself. Additionally, they offer a free tier that will work well
for our initial deployment. Let’s walk through the steps of deploying to MongoDB
Atlas.
First, visit mongodb.com/cloud/atlas and create an account. Once you’ve created an
account, you’ll be prompted to create a database. From this screen you can manage
the settings of your sandbox database, but I recommend sticking with the defaults for
now. These are:
• Amazon’s AWS as the database host, though Google’s Cloud Platform and Micro‐
soft’s Azure are also offered as options
91
• The closest region with a “free tier” option
• Cluster Tier with a default value of “M0 Sandbox (Shared RAM, 512MB
Storage)”
• Additional Settings, which we can leave as the defaults
• Cluster Name, which we can leave as the default
From here, click Create Cluster, at which point it will take a few minutes for Mongo
to set up the database (Figure 10-1).
Figure 10-1. e MongoDB Atlas database creation screen
92 | Chapter 10: Deploying Our API
Next, you’ll see the Clusters page, where you can manage your individual database
cluster (Figure 10-2).
Figure 10-2. MongoDB Atlas Cluster
Hosting Our Database | 93
From the Clusters screen, click Connect, where you’ll be prompted to set up your
connection security. The first step will be to whitelist your IP address. Because our
application will have a dynamic IP address, you’ll need to open this to any IP address
by using 0.0.0.0/0. With all IP addresses whitelisted, you’ll then need to set up a
secure username and password for accessing the data (Figure 10-3).
Figure 10-3. MongoDB Atlas IP whitelist and user account management
94 | Chapter 10: Deploying Our API
Once your IP has been whitelisted and your user account has been created, you’ll
choose the connection method for the database. In this case, it will be an “Applica‐
tion” connection (Figure 10-4).
Figure 10-4. Selecting a connection type in MongoDB Atlas
Hosting Our Database | 95
From here, you can copy the connection string, which we’ll be using in our produc‐
tion .env file (Figure 10-5).
Figure 10-5. MongoDB Atlas’s database connection string
Mongo Passwords
MongoDB Atlas hex-encodes special characters within passwords.
This means that if you use (and you should!) any nonalpha or
numeric value, you will need to use the hex value for that code
when adding your password to the connection string. The site
ascii.cl offers the corresponding hex codes for all special characters.
For example, if your password was Pizz@2! you would need to
encode the @ and ! characters. You do this with a % followed by the
hex value. The resulting password would be Pizz%402%21.
96 | Chapter 10: Deploying Our API
With our MongoDB Atlas managed database up and running, we now have a hosted
data store for our application. In the next step we’ll host our application code and
connect it to our database.
Deploying Our Application
The next step in our deployment setup is to deploy our application code. For the pur‐
pose of this book we will use the cloud application platform Heroku. I’ve chosen Her‐
oku due to its excellent user experience and generous free tier, but other cloud
platforms such as Amazon Web Services, Google Cloud Platform, Digital Ocean, or
Microsoft Azure all provide alternative hosting environments for Node.js applica‐
tions.
Before we begin, you will need to visit Heroku’s website and create an account. Once
your account has been created, you’ll need to install the Heroku command-line tools
for your operating system.
For macOS you can install the Heroku command-line tools using Homebrew as
follows:
$ brew tap heroku/brew && brew install heroku
For Windows users, visit the Heroku command-line tools guide and download the
appropriate installer.
Project Setup
With the Heroku command-line tools installed, we can set up our project within the
Heroku website. Create a new Heroku project by clicking New → Create New App
(Figure 10-6).
Figure 10-6. e Heroku New App dialog
Deploying Our Application | 97
From here you’ll be prompted to give the application a unique name, after which you
can click the Create App button (Figure 10-7). Going forward, use this name any‐
where you see YOUR_APP_NAME.
Figure 10-7. Provide a unique application name
98 | Chapter 10: Deploying Our API
Now we can add environment variables. Similar to how we used our .env file locally,
we can manage our production environment variables within the Heroku website
interface. To do so, click Settings followed by the Reveal Config Vars button. From
this screen, add the following configuration variables (Figure 10-8):
NODE_ENV production
JWT_SECRET A_UNIQUE_PASSPHRASE
DB_HOST YOUR_MONGO_ATLAS_URL
Figure 10-8. Heroku’s environment variable configuration
With our application configured, we’re ready to deploy our code.
Deployment
Now we’re ready to deploy our code to Heroku’s servers. To do this, we can use
straightforward Git commands from our terminal application. We’ll set Heroku as a
remote endpoint, then add and commit our changes, and finally push our code to
Heroku. To do this, run the following commands within your terminal application:
$ heroku git:remote -a <YOUR_APP_NAME>
$ git add .
$ git commit -am "application ready for production"
$ git push heroku master
Deploying Our Application | 99
You should see output in your terminal while Heroku builds and deploys the files.
Once complete, Heroku will use the run script within our package.json file to run our
application on their servers.
Testing
Once our application has been successfully deployed, we will be able to make
GraphQL API requests to our remote server. By default, the GraphQL Playground UI
is disabled in production, but we can test our application using curl from our termi‐
nal application. To run a curl request, enter the following in your terminal
application:
$ curl \
 -X POST \
 -H "Content-Type: application/json" \
 --data '{ "query": "{ notes { id } }" }' \
 https://YOUR_APP_NAME.herokuapp.com/api
If the test is successful, we should receive a response containing an empty notes
array, since our production database does not yet contain any data:
{"data":{"notes":[]}}
With this, we have deployed our application!
Conclusion
In this chapter we used cloud services to deploy a database and our application code.
Services such as MongoDB Atlas and Heroku enable developers to launch small
applications and scale them anywhere from hobby projects to heavily trafficked busi‐
ness. With our API deployed, we have successfully developed the backend services of
our applications’ stack. In the following chapters, we will focus on the UIs of our app.
100 | Chapter 10: Deploying Our API
CHAPTER 11
User Interfaces and React
In 1979 Steve Jobs famously visited Xerox Parc, where he saw a demo of the Xerox
Alto personal computer. While other computers at the time were controlled by typed
commands, the Alto utilized a mouse and featured a graphic interface of windows,
which could be opened and closed. Jobs went on to borrow these ideas in the creation
of the original Apple Macintosh. The popularity of the original Mac led to the prolif‐
eration of computer UIs. Today, in a typical day we may interact with dozens of
graphic user interfaces, which may include personal computers as well as smart‐
phones, tablets, ATMs, game consoles, payment kiosks, and many more. UIs now
surround us, working across all sorts of devices, content types, screen sizes, and inter‐
action formats.
As an example, I recently traveled to a different city for a meeting. That morning, I
woke up and checked my flight status on my phone. I drove to the airport in my car,
where a screen showed a map and allowed me to choose the music that I was listening
to. On the way, I stopped at an ATM to retrieve some cash, punching in my PIN and
tapping out instructions on a touchscreen. When I arrived at the airport, I checked in
to my flight at a flight kiosk. As I waited at the gate, I responded to a few emails on
my tablet. On the flight, I read a book on an e-ink display device. Once I landed, I
summoned a ride through an application on my phone and stopped for lunch, tap‐
ping out my custom order on a display screen. In the meeting, a slide deck was pro‐
jected onto the screen, while many of us took notes on our laptops. Back at my hotel,
later that evening, I browsed the television and movie offerings found through the
hotel’s television on-screen guide. My day was full of many UIs and screen sizes used
to complete tasks related to core elements of life such as transportation, finance, and
entertainment.
101
In this chapter we’ll take a brief look at the history of JavaScript user interface devel‐
opment. With that background knowledge, we’ll then explore the basics of React, the
JavaScript library that we’ll be using throughout the remainder of the book.
JavaScript and UIs
Originally designed in the mid-1990s (infamously, in 10 days) to enhance web inter‐
faces, JavaScript provided an embedded scripting language in the web browser. This
allowed web designers and developers to add small interactions to a web page that
weren’t possible with HTML alone. Unfortunately, browser vendors each had varying
implementations of JavaScript, making it difficult to rely on. This is one of the factors
that led to the proliferation of applications designed to work in a single browser.
In the mid-2000s jQuery (as well as similar libraries, such as MooTools) took off in
popularity. jQuery allowed developers to write JavaScript with a simple API that
worked well across browsers. Soon we were all removing, adding, replacing, and ani‐
mating things on our web pages. Around the same time, Ajax (short for “asynchro‐
nous JavaScript and XML”) allowed us to fetch data from a server and inject it into
the page. The combination of these two technologies provided an ecosystem to create
powerful interactive web applications.
As the complexity of these applications grew, the need for organization and boiler‐
plate code grew in parallel. By the early 2010s frameworks such as Backbone, Angu‐
lar, and Ember came to dominate the JavaScript application landscape. These
frameworks worked by imposing structure and implementing common application
patterns into the framework code. These frameworks were often modeled after the
Model, View, Controller (MVC) pattern of software design. Each framework was pre‐
scriptive about all of the layers of the web application, providing a structured way to
handle templating, data, and user interactions. While this had many benefits, it also
meant that the effort of integrating new or nonstandard technologies could be quite
high.
Meanwhile, desktop applications continued to be written in system-specific program‐
ming languages. This meant that developers and teams were often forced to make
either/or style choices (either a Mac app or a Windows app, either a web app or a
desktop app, etc.). Mobile applications were in a similar position. The rise of respon‐
sive web design meant that designers and developers could create truly incredible
sites and applications for the mobile web browser, but choosing to build a web-only
application locked them out of the mobile platform app stores. Apple’s iOS applica‐
tions were written in Objective C (and more recently Swift), while Android relied
upon the Java programming language (not to be confused with our friend JavaScript).
This meant that the web, consisting of HTML, CSS, and JavaScript, was the only truly
cross-platform user interface platform.
102 | Chapter 11: User Interfaces and React
Declarative Interfaces with JavaScript
In the early 2010s developers at Facebook began to face challenges in the organization
and management of their JavaScript code. In response, the software engineer Jordan
Walke wrote React, inspired by Facebook’s PHP library, XHP. React differed from
other popular JavaSript frameworks in that it focused solely on the rendering of the
UI. To do this, React took a “declarative” programming approach, meaning that it
provides an abstraction that allows developers to focus on describing what the state of
the UI should be.
With the rise of React, and similar libraries such as Vue.js, we have seen a shift in the
way that developers are writing UIs. These frameworks provide a means to manage
the state of a UI at the component level. This allows applications to feel smooth and
seamless to users, while providing an excellent development experience. With tooling
such as Electron for building desktop apps and React Native for cross-platform native
mobile applications, developers and teams are now able to leverage these paradigms
in all of their applications.
Just Enough React
Throughout the remaining chapters, we’ll be relying on the React library to build our
UIs. You do not need to have any prior experience with React to follow along, but it
may help to get a sense of the syntax before jumping in. To do this, we’ll use createreact-app to scaffold out a new project. create-react-app is a tool developed by the
React team that allows us to quickly set up a new React project and helpfully abstracts
away the underlying build tooling, such as Webpack and Babel.
In your terminal application cd into your projects directory and run the following
commands, which will create a new React application in a folder named just-enoughreact:
$ npx create-react-app just-enough-react
$ cd just-enough-react
Running these commands will output a directory in just-enough-react, which con‐
tains all of the project structure, code dependencies, and development scripts to build
a full-featured application. Start the application by running:
$ npm start
Declarative Interfaces with JavaScript | 103
Our React application will now be visible in our browser at http://localhost:3000
(Figure 11-1).
Figure 11-1. Typing npm start will launch the default create-react-app in the browser
We can now begin to edit our application by making changes to the src/App.js file.
This file contains our primary React component. After requiring some dependencies,
it consists of a function that returns some HTML-like markup:
function App() {
 return (
 // markup is here
 )
}
The markup used within the component is something called JSX. JSX is an XMLbased syntax, similar to HTML, which allows us to precisely describe our UI and cou‐
ple it with user actions within our JavaScript files. If you know HTML, picking up
JSX is a matter of learning a few minor differences. The big difference in this example
is that HTML’s class property is replaced by className to avoid collisions with
JavaScript’s native class syntax.
104 | Chapter 11: User Interfaces and React
JSX? Yuck!
If, like me, you come from a background of web standards and a
strict decoupling of concerns, this may feel very icky to you. I
admit that the first time that I encountered JSX, I immediately took
a strong disliking to it. However, the coupling of UI logic with the
rendering output presents many compelling advantages that may
grow on you over time.
Let’s begin to customize our app by removing most of the boilerplate code and reduc‐
ing it to a simple “Hello World!”:
import React from 'react';
import './App.css';
function App() {
 return (
 <div className="App">
 <p>Hello world!</p>
 </div>
 );
}
export default App;
You may notice the enclosing <div> tag that wraps all of our JSX content. Each React
UI component must be contained within a parent HTML element or use a React frag‐
ment, which represents a non-HTML element container, such as:
function App() {
 return (
 <React.Fragment>
 <p>Hello world!</p>
 </React.Fragment>
 );
}
One of the most powerful things about React is that we can use JavaScript directly
within our JSX by enclosing it within curly brackets, {}. Let’s update our App function
to make use of some variables:
function App() {
 const name = 'Adam'
 const now = String(new Date())
 return (
 <div className="App">
 <p>Hello {name}!</p>
 <p>The current time is {now}</p>
 <p>Two plus two is {2+2}</p>
 </div>
Just Enough React | 105
 );
}
In the preceding example, you can see that we’re making use of JavaScript directly in
our interface. How cool is that?
Another useful feature of React is the ability to turn each UI feature into its own com‐
ponent. A good rule of thumb is if an aspect of the UI behaves in an independent
manner, it should be separated out into its own component. Let’s create a new com‐
ponent. To begin, create a new file at src/Sparkle.js and declare a new function:
import React from 'react';
function Sparkle() {
 return (
 <div>
 </div>
 );
}
export default Sparkle;
Now let’s add some functionality. Whenever a user clicks a button it will add a sparkle
emoji to our page (critical functionality for any application). In order to do this, we’ll
import React’s useState component and define some initial state for our component,
which will be an empty string (in other words, no sparkle).
import React, { useState } from 'react';
function Sparkle() {
 // declare our initial component state
 // this a variable of 'sparkle' which is an empty string
 // we've also defined an 'addSparkle' function, which
 // we'll call in our click handler
 const [sparkle, addSparkle] = useState('');
 return (
 <div>
 <p>{sparkle}</p>
 </div>
 );
}
export default Sparkle;
106 | Chapter 11: User Interfaces and React
What Is State?
We’ll cover state in more detail in Chapter 15, but for now it may
be helpful to know that the state of a component represents the
current status of any information that may change within the com‐
ponent. For example, if a UI component has a checkbox, it has a
state of true when checked and false when it is not checked.
Now we can complete our component by adding a button with onClick functionality.
Note the camel casing, which is required within JSX:
import React, { useState } from 'react';
function Sparkle() {
 // declare our initial component state
 // this a variable of 'sparkle' which is an empty string
 // we've also defined an 'addSparkle' function, which
 // we'll call in our click handler
 const [sparkle, addSparkle] = useState('');
 return (
 <div>
 <button onClick={() => addSparkle(sparkle + '\u2728')}>
 Add some sparkle
 </button>
 <p>{sparkle}</p>
 </div>
 );
}
export default Sparkle;
To use our component we can import it into our src/App.js file and declare it as a JSX
element as follows:
import React from 'react';
import './App.css';
// import our Sparkle component
import Sparkle from './Sparkle'
function App() {
 const name = 'Adam';
 let now = String(new Date());
 return (
 <div className="App">
 <p>Hello {name}!</p>
 <p>The current time is {now}</p>
 <p>Two plus two is {2+2}</p>
 <Sparkle />
 </div>
 );
Just Enough React | 107
}
export default App;
Now if you visit our application in the browser, you should see our button and be able
to click it to add sparkle emojis to the page! This represents one of the true super‐
powers of React. We’re able to re-render individual components, or elements of com‐
ponents, in isolation from the rest of our application (Figure 11-2).
Figure 11-2. Clicking the button updates the component state and adds content to our
page
We have now created a new application using create-react-app, updated our Appli
cation component’s JSX, created a new component, declared a component state, and
dynamically updated a component. With a basic understanding of these fundamen‐
tals, we are now prepared to develop declarative UIs in JavaScript using React.
Conclusion
We are surrounded by user interfaces across a wide variety of devices. JavaScript and
web technologies present an unparalleled opportunity to develop these interfaces
across the multitude of platforms, using a single set of technologies. Meanwhile, React
and other declarative view libraries allow us to build powerful, dynamic applications.
The combination of these technologies enables developers to build amazing things
without requiring specialized knowledge for each platform. In the coming chapters
we’ll put this into practice by utilizing a GraphQL API to build interfaces for web,
desktop, and native mobile applications.
108 | Chapter 11: User Interfaces and React
CHAPTER 12
Building a Web Client with React
The original idea behind hypertext was to take related documents and link them
together: if academic paper A references academic paper B let’s make it easy to click
something and navigate between them. In 1989, a software engineer at CERN named
Tim Berners-Lee had the idea to combine hypertext with networked computers, mak‐
ing it easy for someone to make these connections regardless of the location of the
documents. Every cat photo, news article, tweet, streaming video, job search site, and
restaurant review is indebted to the simple idea of globally linking documents.
At its heart, the web remains a medium for linking documents together. Each page is
HTML, rendered in a web browser, with CSS for styling and JavaScript for enhance‐
ments. Today, we use these technologies to build everything from personal blogs and
small brochure sites to complex interactive applications. The underlying advantage is
that the web provides universal access. All anyone needs is a web browser on a webconnected device, creating an inclusive-by-default environment.
What We’re Building
In the upcoming chapters we’ll build the web client for our social note application,
Notedly. Users will be able to create and sign in to an account, write notes in Mark‐
down, edit their notes, view a feed of other users’ notes, and “favorite” other users’
notes. To accomplish all of this, we’ll be interacting with our GraphQL server API.
In our web application:
• Users will be able to create notes, as well as read, update, and delete the notes
they’ve created.
• Users will be able to view a feed of notes created by other users, and read individ‐
ual notes created by others, though they will not be able to update or delete them.
109
• Users will be able to create an account, log in, and log out.
• Users will be able to retrieve their profile information as well as the public profile
information of other users.
• Users will be able to favorite the notes of other users as well as retrieve a list of
their favorites.
These features will cover a lot of ground, but we’ll be breaking them into small
chunks throughout this portion of the book. Once you’ve learned to build a React
application with all of these features, you’ll be able to apply the tools and techniques
toward building all sorts of rich web applications.
How We’re Going to Build This
As you’ve probably guessed, to build this application we’ll be using React as a clientside JavaScript library. Additionally, we’ll be querying data from our GraphQL API.
To aid in the querying, mutating, and caching of data, we’ll make use of Apollo Client.
Apollo Client comprises a collection of open source tools for working with GraphQL.
We’ll be using the React version of the library, but the team at Apollo has also devel‐
oped Angular, Vue, Scala.js, Native iOS, and Native Android integrations.
Other GraphQL Client Libraries
While we’ll be using Apollo in this book, it is far from the only
GraphQL client option available. Facebook’s Relay and Formidda‐
ble’s urql are two popular alternatives.
Additionally, we’ll be using Parcel as our code bundler. A code bundler allows us to
write JavaScript using features that may not be available in a web browser (e.g., newer
language features, code modules, minificiation) and packages them for use in the
browser environment. Parcel is a configuration-free alternative to application build
tools like Webpack. It offers a lot of nice features such as code splitting and automati‐
cally updating the browser during development (aka hot module replacement), but
without the need to set up a build chain. As you saw in the previous chapter, createreact-app also offers a zero-configuration initial setup, using Webpack behind the
scenes, but Parcel allows us to build our application from the ground up, in a way that
I find ideal for learning.
Getting Started
Before we can start development, we need to make a copy of the project starter files to
our machine. The project’s source code contains all of the scripts and references to
third-party libraries that we will need to develop our application. To clone the code to
110 | Chapter 12: Building a Web Client with React
your local machine, open the terminal, navigate to the directory where you keep your
projects, and git clone the project repository. If you’ve worked through the API
chapters, you may also have already create a notedly directory to keep the project
code organized:
# change into the Projects directory
$ cd
$ cd Projects
$ # type the `mkdir notedly` command if you don't yet have a notedly directory
$ cd notedly
$ git clone git@github.com:javascripteverywhere/web.git
$ cd web
$ npm install
Installing Third-Party Dependencies
By making a copy of the book’s starter code and running npm
install in the directory, you avoid having to again run npm
install for any of the individual third-party dependencies.
The code is structured as follows:
/src
This is the directory where you should perform your development as you follow
along with the book.
/solutions
This directory contains the solutions for each chapter. If you get stuck, these are
available for you to consult.
/final
This directory contains the final working project.
Now that you have the code on your local machine, you’ll need to make a copy of the
project’s .env file. This file is a place to keep the variables unique to the environment
we are working in. For example, when working locally we’ll be pointing to a local
instance of our API, but when we deploy our app we’ll point to our remotely
deployed API. To make a copy of the sample .env file, type the following into your
terminal, from the web directory:
$ cp .env.example .env
You should now see an .env file in the directory. You don’t yet need to do anything
with this file, but we’ll be adding information to it as we progress through the devel‐
opment of our API backend. The .gitignore file included with the project will ensure
that you do not inadvertently commit your .env file.
Getting Started | 111
Help, I Don’t See the .env File!
By default, operating systems hide files that start with a period, as
these are typically used by the system, not end users. If you don’t
see the .env file, try opening the directory in your text editor. The
file should be visible in the file explorer of your editor. Alternately,
typing ls -a into your terminal window will list the files in the
current working directory.
Building Out the Web Application
With our starter code cloned locally, we’re ready to build out our React web applica‐
tion. Let’s first take a look at our src/index.html file. This looks like a standard, yet
completely empty, HTML file, but note the following two lines:
<div id="root"></div>
<script src="./App.js"></script>
These two lines are incredibly important to our React application. The root <div>
will provide the container for our entire application. Meanwhile, the App.js file will be
the entry point to our JavaScript application.
Now we can begin to develop our React application in our src/App.js file. If you fol‐
lowed along with the React introduction in the previous chapter, this may all feel
familiar. In src/App.js we begin by importing the react and react-dom libraries:
import React from 'react';
import ReactDOM from 'react-dom';
Now we will create a function, named App, that will return the contents of our appli‐
cation. For now, this will simply be two lines of HTML contained within a <div>
element:
const App = () => {
 return (
 <div>
 <h1>Hello Notedly!</h1>
 <p>Welcome to the Notedly application</p>
 </div>
 );
};
112 | Chapter 12: Building a Web Client with React
What’s With All of the divs?
If you’re just starting out with React, you may wonder about the
tendency to surround components with <div> tags. React compo‐
nents must be contained with a parent element, which often is a
<div> tag, but could also be any other appropriate HTML tag such
as <section>, <header>, or <nav>. If a containing HTML tag feels
extraneous, we can instead use <React.Fragment> or empty <> tags
to contain the components in our JavaScript code.
Finally, we will instruct React to render our application within the element with an ID
of root by adding the following:
ReactDOM.render(<App />, document.getElementById('root'));
The full content of our src/App.js file should now be:
import React from 'react';
import ReactDOM from 'react-dom';
const App = () => {
 return (
 <div>
 <h1>Hello Notedly!</h1>
 <p>Welcome to the Notedly application</p>
 </div>
 );
};
ReactDOM.render(<App />, document.getElementById('root'));
With this complete, let’s take a look in our web browser. Start your local development
server by typing npm run dev in your terminal application. Once the code is bundled,
visit http://localhost:1234 to view the page (Figure 12-1).
Building Out the Web Application | 113
Figure 12-1. Our initial React application running in the browser
Routing
One of the defining features of the web is being able to link documents together. Sim‐
ilarly, for our application we’ll want users to be able to navigate between screens or
pages. In an HTML rendered application, this would involve creating multiple HTML
documents. Whenever a user navigates to a new document, the entire document will
reload, even if there are shared aspects, such as a header or footer, on the two pages.
In JavaScript applications we can make use of client-side routing. In many ways, this
will be similar to HTML linking. A user will click a link, the URL will update, and
they will navigate to a new screen. The difference is that our application will only
update the page with the content that has changed. The experience will be smooth
and “app-like,” meaning that there will not be a visible refresh of the page.
In React, the most commonly used routing library is React Router. This library ena‐
bles us to add routing capabilities to React web applications. To introduce routing to
our application, let’s first create a src/pages directory and add the following files:
• /src/pages/index.js
• /src/pages/home.js
• /src/pages/mynotes.js
114 | Chapter 12: Building a Web Client with React
• /src/pages/favorites.js
Our home.js, mynotes.js, and favorites.js files will be our individual page components.
We can create each of them with some initial content and an effect hook, which will
update the document title when a user navigates to the page.
In src/pages/home.js:
import React from 'react';
const Home = () => {
 return (
 <div>
 <h1>Notedly</h1>
 <p>This is the home page</p>
 </div>
 );
};
export default Home;
In src/pages/mynotes.js:
import React, { useEffect } from 'react';
const MyNotes = () => {
 useEffect(() => {
 // update the document title
 document.title = 'My Notes — Notedly';
 });
 return (
 <div>
 <h1>Notedly</h1>
 <p>These are my notes</p>
 </div>
 );
};
export default MyNotes;
In src/pages/favorites.js:
import React, { useEffect } from 'react';
const Favorites = () => {
 useEffect(() => {
 // update the document title
 document.title = 'Favorites — Notedly';
 });
 return (
 <div>
Routing | 115
 <h1>Notedly</h1>
 <p>These are my favorites</p>
 </div>
 );
};
export default Favorites;
useEffect
In the preceding examples we’re using React’s useEffect hook to
set the title of the page. Effect hooks allow us to include side effects
in our components, updating something that is not related to the
component itself. If you are interested, React’s documentation pro‐
vides a deep dive into effect hooks.
Now, in src/pages/index.js we’ll import React Router and the methods necessary for
web browser routing with the react-router-dom package:
import React from 'react';
import { BrowserRouter as Router, Route } from 'react-router-dom';
Next, we’ll import the page components that we just created:
import Home from './home';
import MyNotes from './mynotes';
import Favorites from './favorites';
Finally, we’ll designate each of the page components that we created as routes with a
specific URL. Note the use of exact for our “Home” route, which will ensure the
home component is rendered only for the root URL:
const Pages = () => {
 return (
 <Router>
 <Route exact path="/" component={Home} />
 <Route path="/mynotes" component={MyNotes} />
 <Route path="/favorites" component={Favorites} />
 </Router>
 );
};
export default Pages;
Our complete src/pages/index.js file should now look as follows:
// import React and routing dependencies
import React from 'react';
import { BrowserRouter as Router, Route } from 'react-router-dom';
// import routes
import Home from './home';
116 | Chapter 12: Building a Web Client with React
import MyNotes from './mynotes';
import Favorites from './favorites';
// define routes
const Pages = () => {
 return (
 <Router>
 <Route exact path="/" component={Home} />
 <Route path="/mynotes" component={MyNotes} />
 <Route path="/favorites" component={Favorites} />
 </Router>
 );
};
export default Pages;
Finally, we can update the src/App.js file to use our routes by importing the routes and
rendering the components:
import React from 'react';
import ReactDOM from 'react-dom';
// import routes
import Pages from '/pages';
const App = () => {
 return (
 <div>
 <Pages />
 </div>
 );
};
ReactDOM.render(<App />, document.getElementById('root'));
Now if you manually update the URL in your web browser, you should be able to
view each component. For example, type http://localhost:1234/favorites to ren‐
der the “favorites” page.
Linking
We’ve created our pages, but we’re missing the key component of linking them
together. So let’s add some links to the other pages from our home page. To do so,
we’ll use React Router’s Link component.
In src/pages/home.js:
import React from 'react';
// import the Link component from react-router
import { Link } from 'react-router-dom';
const Home = () => {
Routing | 117
 return (
 <div>
 <h1>Notedly</h1>
 <p>This is the home page</p>
 { /* add a list of links */ }
 <ul>
 <li>
 <Link to="/mynotes">My Notes</Link>
 </li>
 <li>
 <Link to="/favorites">Favorites</Link>
 </li>
 </ul>
 </div>
 );
};
export default Home;
With this we’re able to navigate our application. Clicking one of the links on the home
page will navigate to the corresponding page component. Core browser navigation
functions, such as the back and forward buttons, will continue to work as well.
UI Components
We’ve successfully created individual page components and can navigate between
them. As we build out our pages, they will have several shared user interface ele‐
ments, such as a header and sitewide navigation. Rewriting these each time they are
used wouldn’t be very efficient (and would get quite annoying). Instead, we can write
reusable interface components and import them into our interface wherever we need
them. In fact, thinking of our UI as composed of tiny components is one of the core
tenants of React, and was my breakthrough in grasping the framework.
We’ll start by creating header and navigation components for our application. First,
let’s create a new directory within our src directory called components. Within the src/
components directory, we’ll create two new files called Header.js and Navigation.js.
React components must be capitalized, so we’ll follow the common convention of
capitalizing the filename as well.
Let’s begin by writing the header component in src/components/Header.js. To do so,
we’ll import our logo.svg file and add the corresponding markup for our component:
import React from 'react';
import logo from '../img/logo.svg';
const Header = () => {
 return (
 <header>
 <img src={logo} alt="Notedly Logo" height="40" />
118 | Chapter 12: Building a Web Client with React
 <h1>Notedly</h1>
 </header>
 );
};
export default Header;
For our navigation component we’ll import React Router’s Link functionality and
mark up an unordered list of links. In src/components/Navigation.js:
import React from 'react';
import { Link } from 'react-router-dom';
const Navigation = () => {
 return (
 <nav>
 <ul>
 <li>
 <Link to="/">Home</Link>
 </li>
 <li>
 <Link to="/mynotes">My Notes</Link>
 </li>
 <li>
 <Link to="/favorites">Favorites</Link>
 </li>
 </ul>
 </nav>
 );
};
export default Navigation;
In screenshots you’ll see that I’ve also included emoji characters as navigation icons.
If you’d like to do the same, the accessible markup for including emoji characters is as
follows:
<span aria-hidden="true" role="img">
 <!-- emoji character -->
</span>
With our header and navigation components complete, we can now use them within
our application. Let’s update our src/pages/home.js file to include the components. We
will first import them and then include the component within our JSX markup.
Our src/pages/home.js will now look as follows (Figure 12-2):
import React from 'react';
import Header from '../components/Header';
import Navigation from '../components/Navigation';
const Home = () => {
UI Components | 119
 return (
 <div>
 <Header />
 <Navigation />
 <p>This is the home page</p>
 </div>
 );
};
export default Home;
Figure 12-2. With React components we’re able to easily compose shareable UI features
This is everything we need in order to be able to create shareable components across
our application. For more on using components within a UI, I highly recommend
reading the React documentation page “Thinking in React”.
Conclusion
The web remains an unparalleled medium for distributing applications. It couples
universal access with a developer’s ability to deploy real-time updates. In this chapter
we built out the foundation of our JavaScript web application in React. In the next
chapter we will add layout and style to the app, using React components and
CSS-in-JS.
120 | Chapter 12: Building a Web Client with React
CHAPTER 13
Styling an Application
In his 1978 track “Lip Service,” Elvis Costello sneers the line “don’t act like you’re
above me, just look at your shoes.” This kiss-off implies that the narrator can detect
an attempt at elevated social status simply by seeing someone’s shoes, no matter how
finely pressed their suit or how elegant their dress. For better or worse, style is a
major part of human culture, and we’re all accustomed to picking up on these types of
social cues. Archaeologists have even found that humans in the Upper Paleolithic era
created necklaces and bracelets from bones, teeth, berries, and stone. Our clothes not
only serve the functional purpose of protecting our bodies from the elements, but
may also communicate to others information about our culture, social status, inter‐
ests, and so much more.
A web application is functional without anything beyond the default styles of the web,
but by applying CSS we are able to more clearly communicate with our users. In this
chapter, we’ll explore how we can use the CSS-in-JS Styled Components library to
introduce layout and style to our application. This will allow us to make a more usa‐
ble and aesthetically pleasing application within a maintainable, component-based,
code structure.
Creating a Layout Component
Many, or in our case all, pages of an application will share a common layout. For
example, all the pages of our application will have a header, a sidebar, and a content
area (Figure 13-1). Rather than import the shared layout elements within each page
component, we can instead create a component specifically for our layout and wrap
each of our page components within it.
121
Figure 13-1. A wireframe of our page layout
To create our component, we’ll begin by creating a new file at src/components/
Layout.js. Within this file we’ll import our shared components and lay out our con‐
tent. Our React component function will receive a property of children, which will
allow us to specify where child content will appear in the layout. We’ll also make use
of the empty <React.Fragment> JSX element to help avoid extraneous markup.
Let’s create our component in src/components/Layout.js:
import React from 'react';
import Header from './Header';
import Navigation from './Navigation';
const Layout = ({ children }) => {
 return (
 <React.Fragment>
 <Header />
 <div className="wrapper">
 <Navigation />
 <main>{children}</main>
 </div>
 </React.Fragment>
 );
};
export default Layout;
122 | Chapter 13: Styling an Application
Now within our src/pages/index.js file, we can wrap our page components within the
newly created Layout component to apply the shared layout to each page:
// import React and routing dependencies
import React from 'react';
import { BrowserRouter as Router, Route } from 'react-router-dom';
// import shared layout component
import Layout from '../components/Layout';
// import routes
import Home from './home';
import MyNotes from './mynotes';
import Favorites from './favorites';
// define routes
const Pages = () => {
 return (
 <Router>
 {/* Wrap our routes within the Layout component */}
 <Layout>
 <Route exact path="/" component={Home} />
 <Route path="/mynotes" component={MyNotes} />
 <Route path="/favorites" component={Favorites} />
 </Layout>
 </Router>
 );
};
export default Pages;
The final step is to remove any instances of <Header> or <Navigation> within our
page components. For example, our src/pages/Home.js file will now have the following
reduced code:
import React from 'react';
const Home = () => {
 return (
 <div>
 <p>This is the home page</p>
 </div>
 );
};
export default Home;
With this complete, you can view your application in your browser. As you navigate
between the routes you’ll see our header and navigation links appear on each page.
For now, they are not styled and our page does not have a visual layout. Let’s explore
adding styles in the next section.
Creating a Layout Component | 123
CSS
Cascading Style Sheets are precisely named: they are a set of rules that allow us to
write styles for the web. The styles “cascade,” meaning that the last or most specifically
defined style will be rendered. For example:
p {
 color: green
}
p {
 color: red
}
This CSS will render all paragraphs red, making the color: green rule obsolete. This
is such a simple idea, but it has resulted in dozens of patterns and techniques to aid in
avoiding its pitfalls. CSS structural techniques such as BEM (block element modifier),
OOCSS (object-oriented CSS), and Atomic CSS use prescriptive class naming to help
scope styles. Preprocessors such as SASS (syntatically awesome stylesheets) and Less
(leaner stylesheets) provide tooling that simplifies the CSS syntax and enables modu‐
lar files. Though these each have their merits, CSS-in-JavaScript provides a compel‐
ling use case for developing React or other JavaScript-driven applications.
What About CSS Frameworks?
CSS and UI frameworks are a popular option for developing an
application, with good reason. They present a solid style baseline
and reduce the amount of code that a developer needs to write by
providing styles and functionality for common application pat‐
terns. The tradeoffs are that applications using these frameworks
may become visually similar and can increase the file bundle size.
That tradeoff may be worthwhile to you, however. Some of my per‐
sonal favorite UI frameworks for working with React are Ant
Design, Bootstrap, Grommet, and Rebass.
CSS-in-JS
When I first encountered CSS-in-JS, my initial reaction was one of horror. I spent the
formative years of my web development career in the web standards era. I continue to
advocate for accessibility and sensible progressive enhancement for web develop‐
ment. “Separation of concerns” has been a core tenant of my web practices for over a
decade. So, if you’re like me and simply reading “CSS-in-JS” makes you feel dirty,
you’re not alone. However, I was quickly won over once I gave it a proper (and
judgment-free) try. CSS-in-JS makes it easy to think of our user interfaces as a series
of components, something that I had been trying to do with a combination of struc‐
ture techniques and CSS preprocessors for years.
124 | Chapter 13: Styling an Application
In this book we’ll be using Styled Components as our CSS-in-JS library. It is fast, flex‐
ible, under active development, and the most popular CSS-in-JS library. It’s also used
by companies such as Airbnb, Reddit, Patreon, Lego, BBC News, Atlassian, and many
more.
The Styled Components library works by allowing us to define the styles of an ele‐
ment using JavaScript’s template literal syntax. We create a JavaScript variable that
will refer to an HTML element and its associated styles. Since that sounds fairly
abstract, let’s take a look at a simple example:
import React from 'react';
import styled from 'styled-components'
const AlertParagraph = styled.p`
 color: green;
`;
const ErrorParagraph = styled.p`
 color: red;
`;
const Example = () => {
 return (
 <div>
 <AlertParagraph>This is green.</AlertParagraph>
 <ErrorParagraph>This is red.</ErrorParagraph>
 </div>
 );
};
export default Example;
As you can see, we can easily scope styles. Additionally, we are scoping our style to
that specific component. This helps us to avoid class name collisions across different
parts of our application.
Creating a Button Component
Now that we have a basic understanding of styled components, let’s integrate them
into our application. To begin with, we’ll write some styles for a <button> element,
which will allow us to reuse the component throughout our application. In the previ‐
ous example, we integrated our styles alongside our React/JSX code, but we can also
write standalone styled components. To begin, create a new file at src/components/
Button.js, import the styled library from styled-components, and set up the export‐
able component as a template literal like so:
import styled from 'styled-components';
const Button = styled.button`
CSS | 125
 /* our styles will go here */
`;
export default Button;
With the component in place, we can fill it in with some styles. Add some baseline
button styles as well as hover and active state styles as follows:
import styled from 'styled-components';
const Button = styled.button`
 display: block;
 padding: 10px;
 border: none;
 border-radius: 5px;
 font-size: 18px;
 color: #fff;
 background-color: #0077cc;
 cursor: pointer;
 :hover {
 opacity: 0.8;
 }
 :active {
 background-color: #005fa3;
 }
`;
export default Button;
Now we can use our button throughout our application. For example, to use it on the
application’s home page, we could import the component and use the <Button> ele‐
ment anywhere we would typically use <button>.
In src/pages/home.js:
import React from 'react';
import Button from '../components/Button';
const Home = () => {
 return (
 <div>
 <p>This is the home page</p>
 <Button>Click me!</Button>
 </div>
 );
};
export default Home;
126 | Chapter 13: Styling an Application
With this, we’ve written a styled component that we can use anywhere in our applica‐
tion. This is great for maintainability, as we can easily find our styles and change
them across our codebase. Additionally, we can couple styled components with
markup, allowing us to create small, reusable, and maintainable components.
Adding Global Styles
Though many of our styles will be contained within individual components, every
site or application also has a set of global styles (things like CSS resets, fonts, and
baseline colors). We can create a GlobalStyle.js component to house these styles.
This will look a bit different from our previous example, as we’ll be creating a style‐
sheet rather than styles attached to a specific HTML element. To accomplish this,
we’ll import the createGlobalStyle module from styled-components. We’ll also
import the normalize.css library to ensure consistent rendering of HTML elements
across browsers. Finally, we’ll add some global rules for the HTML body of our appli‐
cation and default link styles.
In src/components/GlobalStyle.js:
// import createGlobalStyle and normalize
import { createGlobalStyle } from 'styled-components';
import normalize from 'normalize.css';
// we can write our CSS as a JS template literal
export default createGlobalStyle`
 ${normalize}
 *, *:before, *:after {
 box-sizing: border-box;
 }
 body,
 html {
 height: 100%;
 margin: 0;
 }
 body {
 font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,
 Oxygen-Sans, Ubuntu, Cantarell, 'Helvetica Neue', sans-serif;
 background-color: #fff;
 line-height: 1.4;
 }
 a:link,
 a:visited {
 color: #0077cc;
 }
CSS | 127
 a:hover,
 a:focus {
 color: #004499;
 }
 code,
 pre {
 max-width: 100%;
 }
`;
To apply these styles, we’ll import them into our App.js file and add a <Global
Style /> element to our application:
import React from 'react';
import ReactDOM from 'react-dom';
// import global styles
import GlobalStyle from '/components/GlobalStyle';
// import routes
import Pages from '/pages';
const App = () => {
 return (
 <div>
 <GlobalStyle />
 <Pages />
 </div>
 );
};
ReactDOM.render(<App />, document.getElementById('root'));
With this, our global styles will be applied to the application. When you preview the
app in the browser, you’ll see that the typeface has changed, the links have a new style,
and the margins have been removed (Figure 13-2).
Figure 13-2. Our application now has global styles applied
128 | Chapter 13: Styling an Application
Component Styles
Now that we’ve applied some global styles to our application, we can begin styling the
individual components. In doing this we’ll also introduce the overall layout of our
application. For each component we style, we’ll first import the styled library from
styled-components. We’ll then define some element styles as variables. Lastly, we’ll
use those elements within the JSX of our React component.
Styled Component Naming
To avoid collisions with HTML elements, it’s mandatory to capital‐
ize the names of our styled components.
We can begin in src/components/Layout.js, where we’ll add style to the structural
<div> and <main> tags for the application’s layout.
import React from 'react';
import styled from 'styled-components';
import Header from './Header';
import Navigation from './Navigation';
// component styles
const Wrapper = styled.div`
 /* We can apply media query styles within the styled component */
 /* This will only apply the layout for screens above 700px wide */
 @media (min-width: 700px) {
 display: flex;
 top: 64px;
 position: relative;
 height: calc(100% - 64px);
 width: 100%;
 flex: auto;
 flex-direction: column;
 }
`;
const Main = styled.main`
 position: fixed;
 height: calc(100% - 185px);
 width: 100%;
 padding: 1em;
 overflow-y: scroll;
 /* Again apply media query styles to screens above 700px */
 @media (min-width: 700px) {
 flex: 1;
 margin-left: 220px;
 height: calc(100% - 64px);
 width: calc(100% - 220px);
CSS | 129
 }
`;
const Layout = ({ children }) => {
 return (
 <React.Fragment>
 <Header />
 <Wrapper>
 <Navigation />
 <Main>{children}</Main>
 </Wrapper>
 </React.Fragment>
 );
};
export default Layout;
With our Layout.js component complete, we can add some styles to our Header.js and
Navigation.js files:
In src/components/Header.js:
import React from 'react';
import styled from 'styled-components';
import logo from '../img/logo.svg';
const HeaderBar = styled.header`
 width: 100%;
 padding: 0.5em 1em;
 display: flex;
 height: 64px;
 position: fixed;
 align-items: center;
 background-color: #fff;
 box-shadow: 0 0 5px 0 rgba(0, 0, 0, 0.25);
 z-index: 1;
`;
const LogoText = styled.h1`
 margin: 0;
 padding: 0;
 display: inline;
`;
const Header = () => {
 return (
 <HeaderBar>
 <img src={logo} alt="Notedly Logo" height="40" />
 <LogoText>Notedly</LogoText>
 </HeaderBar>
 );
};
130 | Chapter 13: Styling an Application
export default Header;
Finally, in src/components/Navigation.js:
import React from 'react';
import { Link } from 'react-router-dom';
import styled from 'styled-components';
const Nav = styled.nav`
 padding: 1em;
 background: #f5f4f0;
 @media (max-width: 700px) {
 padding-top: 64px;
 }
 @media (min-width: 700px) {
 position: fixed;
 width: 220px;
 height: calc(100% - 64px);
 overflow-y: scroll;
 }
`;
const NavList = styled.ul`
 margin: 0;
 padding: 0;
 list-style: none;
 line-height: 2;
 /* We can nest styles in styled-components */
 /* The following styles will apply to links within the NavList component */
 a {
 text-decoration: none;
 font-weight: bold;
 font-size: 1.1em;
 color: #333;
 }
 a:visited {
 color: #333;
 }
 a:hover,
 a:focus {
 color: #0077cc;
 }
`;
const Navigation = () => {
 return (
 <Nav>
CSS | 131
 <NavList>
 <li>
 <Link to="/">Home</Link>
 </li>
 <li>
 <Link to="/mynotes">My Notes</Link>
 </li>
 <li>
 <Link to="/favorites">Favorites</Link>
 </li>
 </NavList>
 </Nav>
 );
};
export default Navigation;
With these styles applied, we now have a fully styled application (Figure 13-3). Going
forward, we can apply styles as we create individual components.
Figure 13-3. Our application with styles applied
Conclusion
In this chapter we introduced layout and style to our application. Using the CSS-in-JS
library Styled Components allows us to write concise and properly scoped CSS styles.
132 | Chapter 13: Styling an Application
These styles can then be applied to individual components or globally across our
application. In the next chapter, we’ll work toward a fully featured application by
implementing our GraphQL client and making calls to our API.
Conclusion | 133

CHAPTER 14
Working with Apollo Client
I remember my first internet connection vividly. My computer’s modem would dial in
to a local number connected to my internet service provider (ISP), setting me free on
the web. As magical as this felt at the time, it is a far cry from the instant, always-on
connections that we use today. Here’s what the process looked like:
1. Sit down at my computer and open the ISP software.
2. Click Connect, and wait for the modem to dial the number.
3. If the connection is successful, hear the glorious “modem sounds.” If not, such as
during peak hours when the lines may be overloaded and busy, try again.
4. Once connected, receive a success notification and browse the web in all of its
GIF-filled 90s glory.
This cycle may seem arduous, but it still represents the way in which services speak to
each other: they request a connection, make that connection, send a request, and get
something back in return. Our client applications will work in the same manner. We
will first make a connection to our server API application and, if successful, make
requests to that server.
In this chapter, we’ll use Apollo Client to connect to our API. Once we’ve connected,
we’ll write a GraphQL query, which will be used to display data on a page. We’ll also
introduce pagination, both within an API query and in our interface components.
135
Running the API Locally
The development of our web client application will require access
to a local instance of our API. If you’ve been following along with
the book, you may already have the Notedly API and its database
up and running on your machine. If not, I’ve added instructions to
Appendix A on how to get a copy of the API up and running along
with some sample data. If you already have the API running, but
would like some additional data to work with, run npm run seed
from the root of the API project directory.
Setting Up Apollo Client
Much like Apollo Server, Apollo Client offers a number of helpful features to simplify
working with GraphQL within JavaScript UI applications. Apollo Client provides
libraries for connecting a web client to an API, local caching, GraphQL syntax, local
state management, and more. We’ll also be using Apollo Client with a React applica‐
tion, but Apollo also offers libraries for Vue, Angular, Meteor, Ember, and Web
Components.
First, we’ll want to ensure that our .env file contains a reference to our local API URI.
This will allow us to use our local API instance in development, while pointing to our
product API when we release our application to a public web server. In our .env file,
we should have a API_URI variable with our local API server’s address:
API_URI=http://localhost:4000/api
Our code bundler, Parcel, is configured to automatically work with .env files. Any
time we want to reference an .env variable in our code, we can use
process.env.VARIABLE_NAME. This will allow us to use unique values in local devel‐
opment, production, and any other environment that we may need (such as staging
or continuous integration).
With the address stored in an environment variable, we are ready to connect our web
client to our API server. Working in our src/App.js file, first we need to import the
Apollo packages that we’ll be using:
// import Apollo Client libraries
import { ApolloClient, ApolloProvider, InMemoryCache } from '@apollo/client';
With these imported, we can configure a new Apollo Client instance, passing it the
API URI, initiating the cache, and enabling the use of the local Apollo developer
tools:
// configure our API URI & cache
const uri = process.env.API_URI;
const cache = new InMemoryCache();
136 | Chapter 14: Working with Apollo Client
// configure Apollo Client
const client = new ApolloClient({
 uri,
 cache,
 connectToDevTools: true
});
Finally, we can connect our React application to our Apollo Client by wrapping it in
an ApolloProvider. We’ll replace our empty <div> tags with <ApolloProvider> and
include our client as a connection:
const App = () => {
 return (
 <ApolloProvider client={client}>
 <GlobalStyle />
 <Pages />
 </ApolloProvider>
 );
};
Overall, our src/App.js file will now look as follows:
import React from 'react';
import ReactDOM from 'react-dom';
// import Apollo Client libraries
import { ApolloClient, ApolloProvider, InMemoryCache } from '@apollo/client';
// global styles
import GlobalStyle from '/components/GlobalStyle';
// import our routes
import Pages from '/pages';
// configure our API URI & cache
const uri = process.env.API_URI;
const cache = new InMemoryCache();
// configure Apollo Client
const client = new ApolloClient({
 uri,
 cache,
 connectToDevTools: true
});
const App = () => (
 <ApolloProvider client={client}>
 <GlobalStyle />
 <Pages />
 </ApolloProvider>
);
ReactDOM.render(<App />, document.getElementById('root'));
Setting Up Apollo Client | 137
With our client connected to our API server, we can now integrate GraphQL queries
and mutations into our application.
Querying an API
When we query an API, we are requesting data. In a UI client, we want to be able to
query that data and display it to the user. Apollo enables us to compose queries to
fetch data. We can then update React components to display the data to the end user.
We can explore the use of queries by writing a noteFeed query, which will return a
feed of the latest notes to the user and display it on the application’s home page.
When I am first writing a query, I find the following process useful:
1. Consider what data the query needs to return.
2. Write the query in the GraphQL Playground.
3. Integrate the query into the client application.
Let’s follow this process in drafting our query. If you followed along in the API por‐
tion of the book, you may recall that the noteFeed query returns a list of 10 notes
along with a cursor, which indicates the position of the last note returned, and a has
NextPage boolean, which allows us to determine if there are additional notes to load.
We can view our schema within the GraphQL Playground, allowing us to see all of
the data options available. For our query, we’ll most likely require the following
information:
{
 cursor
 hasNextPage
 notes {
 id
 createdAt
 content
 favoriteCount
 author {
 id
 username
 avatar
 }
 }
 }
Now, in our GraphQL Playground we can flesh this out into a GraphQL query. We’ll
be writing this a bit more verbosely than the queries from a server chapter, by naming
the query and providing an optional variable named cursor. To use the GraphQL
Playground, first ensure that the API server is running, and then visit http://localhost:
4000/api. In the GraphQL Playground, add the following query:
138 | Chapter 14: Working with Apollo Client
query noteFeed($cursor: String) {
 noteFeed(cursor: $cursor) {
 cursor
 hasNextPage
 notes {
 id
 createdAt
 content
 favoriteCount
 author {
 username
 id
 avatar
 }
 }
 }
 }
In the GraphQL Playground, also add a “query variable” to test out the use of the
variable:
{
 "cursor": ""
}
To test out this variable, replace the empty string with the ID value of any of the notes
in our database (Figure 14-1).
Figure 14-1. Our noteFeed query in the GraphQL Playground
Querying an API | 139
Now that we know that our query is properly written, we can confidently integrate it
into our web application. In the src/pages/home.js file, import the useQuery library as
well as the GraphQL syntax via the gql library from @apollo/client:
// import the required libraries
import { useQuery, gql } from '@apollo/client';
// our GraphQL query, stored as a variable
const GET_NOTES = gql`
 query NoteFeed($cursor: String) {
 noteFeed(cursor: $cursor) {
 cursor
 hasNextPage
 notes {
 id
 createdAt
 content
 favoriteCount
 author {
 username
 id
 avatar
 }
 }
 }
 }
`;
Now we can integrate the query into our React application. To do this, we’ll pass our
GraphQL query string to Apollo’s useQuery React hook. Our hook will return an
object containing one of the following values:
data
The data returned by the query, if successful.
loading
The loading state, which is set to true when the data is being fetched. This allows
us to display a loading indicator to our users.
error
If our data fails to fetch, an error is returned to our application.
We can update our Home component to include our query:
const Home = () => {
 // query hook
 const { data, loading, error, fetchMore } = useQuery(GET_NOTES);
 // if the data is loading, display a loading message
 if (loading) return <p>Loading...</p>;
 // if there is an error fetching the data, display an error message
140 | Chapter 14: Working with Apollo Client
 if (error) return <p>Error!</p>;
 // if the data is successful, display the data in our UI
 return (
 <div>
 {console.log(data)}
 The data loaded!
 </div>
 );
};
export default Home;
If you’ve done everything successfully, you should see a “The data loaded!” message
on the home page of our application (Figure 14-2). We’ve also included a
console.log statement, which will print our data to the browser console. Taking a
look at the structure of data results can be a helpful guidepost when integrating the
data into the application.
Figure 14-2. If our data has been successfully fetched, our component will display a “e
data loaded!” message and the data will print to the console
Querying an API | 141
Now, let’s integrate the data we receive into the application. To do this, we will map
over the array of notes returned within our data. React requires that each result be
assigned a unique key, for which we’ll use the individual note’s ID. To begin, we’ll dis‐
play the username of the author for each note:
const Home = () => {
 // query hook
 const { data, loading, error, fetchMore } = useQuery(GET_NOTES);
 // if the data is loading, display a loading message
 if (loading) return <p>Loading...</p>;
 // if there is an error fetching the data, display an error message
 if (error) return <p>Error!</p>;
 // if the data is successful, display the data in our UI
 return (
 <div>
 {data.noteFeed.notes.map(note => (
 <div key={note.id}>{note.author.username}</div>
 ))}
 </div>
 );
};
Using JavaScript’s map() Method
If you haven’t worked with JavaScript’s map() method before, the
syntax can seem a bit intimidating at first. The map() method
allows you to perform an action for items within an array. This can
be incredibly useful when you’re working with data returned from
an API, allowing you to perform actions such as displaying each
item in a certain way within the template. To learn more about
map(), I recommend reading the MDN Web Docs guide.
If there is data in our database, you should now see a list of usernames on the page
(Figure 14-3).
142 | Chapter 14: Working with Apollo Client
Figure 14-3. Usernames from our data, printed to the screen
Now that we have successfully mapped over our data, we can write the rest of our
component. Since our notes are written in Markdown, let’s import a library that will
allow us to render Markdown to the page.
In src/pages/home.js:
import ReactMarkdown from 'react-markdown';
Now we can update our UI to include the author’s avatar, the author’s username, the
date the note was created, the number of favorites that a note has, and finally the con‐
tent of the note itself. In src/pages/home.js:
// if the data is successful, display the data in our UI
return (
 <div>
 {data.noteFeed.notes.map(note => (
 <article key={note.id}>
 <img
 src={note.author.avatar}
 alt={`${note.author.username} avatar`}
 height="50px"
 />{' '}
 {note.author.username} {note.createdAt} {note.favoriteCount}{' '}
 <ReactMarkdown source={note.content} />
 </article>
 ))}
 </div>
);
Querying an API | 143
Whitespace in React
React strips the whitespace between elements on new lines. Using
{' '} in our markup is a way of manually adding whitespace.
You should now see a complete list of notes in your browser. Before we move on to
styling them, however, there is an opportunity for a small refactor. This is our first
page displaying notes, but we know that we will be making several more. On other
pages we will need to display individual notes, as well as feeds of other note types
(such as “my notes” and “favorites”). Let’s go ahead and create two new components:
src/components/Note.js and src/components/NoteFeed.js.
In src/components/Note.js, we’ll include the markup for an individual note. To accom‐
plish this, we’ll pass each of our component functions a property containing the
appropriate content.
import React from 'react';
import ReactMarkdown from 'react-markdown';
const Note = ({ note }) => {
 return (
 <article>
 <img
 src={note.author.avatar}
 alt="{note.author.username} avatar"
 height="50px"
 />{' '}
 {note.author.username} {note.createdAt} {note.favoriteCount}{' '}
 <ReactMarkdown source={note.content} />
 </article>
 );
};
export default Note;
Now for the src/components/NoteFeed.js component:
import React from 'react';
import Note from './Note';
const NoteFeed = ({ notes }) => {
 return (
 <div>
 {notes.map(note => (
 <div key={note.id}>
 <Note note={note} />
 </div>
 ))}
 </div>
 );
144 | Chapter 14: Working with Apollo Client
};
export default NoteFeed;
Finally, we can update the src/pages/home.js component to reference our NoteFeed:
import React from 'react';
import { useQuery, gql } from '@apollo/client';
import Button from '../components/Button';
import NoteFeed from '../components/NoteFeed';
const GET_NOTES = gql`
 query NoteFeed($cursor: String) {
 noteFeed(cursor: $cursor) {
 cursor
 hasNextPage
 notes {
 id
 createdAt
 content
 favoriteCount
 author {
 username
 id
 avatar
 }
 }
 }
 }
`;
const Home = () => {
 // query hook
const { data, loading, error, fetchMore } = useQuery(GET_NOTES);
// if the data is loading, display a loading message
if (loading) return <p>Loading...</p>;
// if there is an error fetching the data, display an error message
if (error) return <p>Error!</p>;
// if the data is successful, display the data in our UI
 return <NoteFeed notes={data.noteFeed.notes} />;
};
export default Home;
With this refactor, we’ll now be able to easily re-create note and note feed instances
across our application.
Querying an API | 145
Some Style
Now that we have written our components and can view our data, we can add some
style. One of the most obvious opportunities for improvement is in the way that our
“created at” date displays. To address this, we’ll use the date-fns library, which pro‐
vides small components for working with dates in JavaScript. In src/components/
Note.js, import the library and update the date markups to apply the conversion as
follows:
// import the format utility from `date-fns`
import { format } from 'date-fns';
// update the date markup to format it as Month, Day, and Year
{format(note.createdAt, 'MMM Do YYYY')} Favorites:{' '}
With our date formatted, we can use the Styled Components library to update the
note layout:
import React from 'react';
import ReactMarkdown from 'react-markdown';
import { format } from 'date-fns';
import styled from 'styled-components';
// Keep notes from extending wider than 800px
const StyledNote = styled.article`
 max-width: 800px;
 margin: 0 auto;
`;
// Style the note metadata
const MetaData = styled.div`
 @media (min-width: 500px) {
 display: flex;
 align-items: top;
 }
`;
// add some space between the avatar and meta info
const MetaInfo = styled.div`
 padding-right: 1em;
`;
// align 'UserActions' to the right on large screens
const UserActions = styled.div`
 margin-left: auto;
`;
const Note = ({ note }) => {
 return (
 <StyledNote>
 <MetaData>
 <MetaInfo>
146 | Chapter 14: Working with Apollo Client
 <img
 src={note.author.avatar}
 alt="{note.author.username} avatar"
 height="50px"
 />
 </MetaInfo>
 <MetaInfo>
 <em>by</em> {note.author.username} <br />
 {format(note.createdAt, 'MMM Do YYYY')}
 </MetaInfo>
 <UserActions>
 <em>Favorites:</em> {note.favoriteCount}
 </UserActions>
 </MetaData>
 <ReactMarkdown source={note.content} />
 </StyledNote>
 );
};
export default Note;
We would also be well served to add some space and a light border between the notes
in our NoteFeed.js component:
import React from 'react';
import styled from 'styled-components';
const NoteWrapper = styled.div`
 max-width: 800px;
 margin: 0 auto;
 margin-bottom: 2em;
 padding-bottom: 2em;
 border-bottom: 1px solid #f5f4f0;
`;
import Note from './Note';
const NoteFeed = ({ notes }) => {
 return (
 <div>
 {notes.map(note => (
 <NoteWrapper key={note.id}>
 <Note note={note} />
 </NoteWrapper>
 ))}
 </div>
 );
};
export default NoteFeed;
With these updates, we’ve introduced layout styles to our application.
Querying an API | 147
Dynamic Queries
Currently our application consists of three routes, each of which is static. These
routes are located at a static URL and will always make the same data request. How‐
ever, applications commonly need dynamic routes and queries based upon those
routes. As an example, every tweet on Twitter.com is assigned a unique URL at twit‐
ter.com/<username>/status/<tweet_id>. This allows users to link and share individual
tweets both within the Twitter ecosystem as well as anywhere on the web.
Currently, in our application notes can only be accessed within a feed, but we want to
allow users to view and link to individual notes. To accomplish this we’ll set up
dynamic routing in our React application as well as an individual note GraphQL
query. Our goal is for users to be able to access routes at /note/<note_id>.
To begin, we’ll create a new page component at src/pages/note.js. We will pass our
props (property) object to the component, which includes the match property via
React Router. This property contains information about how the route path matches
the URL. This will give us access to the URL parameters through match.params.
import React from 'react';
const NotePage = props => {
 return (
 <div>
 <p>ID: {props.match.params.id}</p>
 </div>
 );
};
export default NotePage;
Now we can add a corresponding route to our src/pages/index.js file. This route will
include an ID parameter indicated with :id:
// import React and routing dependencies
import React from 'react';
import { BrowserRouter as Router, Route } from 'react-router-dom';
// import shared layout component
import Layout from '../components/Layout';
// import routes
import Home from './home';
import MyNotes from './mynotes';
import Favorites from './favorites';
import NotePage from './note';
// define routes
const Pages = () => {
 return (
148 | Chapter 14: Working with Apollo Client
 <Router>
 <Layout>
 <Route exact path="/" component={Home} />
 <Route path="/mynotes" component={MyNotes} />
 <Route path="/favorites" component={Favorites} />
 <Route path="/note/:id" component={NotePage} />
 </Layout>
 </Router>
 );
};
export default Pages;
Now, visiting http://localhost:1234/note/123 will print ID: 123 to our page. To test it
out, replace the ID parameter with anything of your choosing, such as /note/pizza
or /note/GONNAPARTYLIKE1999. This is pretty cool, but not very useful. Let’s
update our src/pages/note.js component to make a GraphQL query for the note with
the ID found in the URL. To do this, we’ll use the note query from our API as well as
our Note React component:
import React from 'react';
// import GraphQL dependencies
import { useQuery, gql } from '@apollo/client';
// import the Note component
import Note from '../components/Note';
// the note query, which accepts an ID variable
const GET_NOTE = gql`
 query note($id: ID!) {
 note(id: $id) {
 id
 createdAt
 content
 favoriteCount
 author {
 username
 id
 avatar
 }
 }
 }
`;
const NotePage = props => {
 // store the id found in the url as a variable
 const id = props.match.params.id;
 // query hook, passing the id value as a variable
 const { loading, error, data } = useQuery(GET_NOTE, { variables: { id } });
 // if the data is loading, display a loading message
Dynamic Queries | 149
 if (loading) return <p>Loading...</p>;
 // if there is an error fetching the data, display an error message
 if (error) return <p>Error! Note not found</p>;
 // if the data is successful, display the data in our UI
 return <Note note={data.note} />;
};
export default NotePage;
Now, navigating to a URL with an ID parameter will render either the corresponding
note or an error message. Finally, let’s update our src/components/NoteFeed.js compo‐
nent to display a link to the individual note in the UI.
First, at the top of the file, import {Link} from React Router:
import { Link } from 'react-router-dom';
Then, update the JSX to include a link to the note page as follows:
<NoteWrapper key={note.id}>
 <Note note={note} />
 <Link to={`note/${note.id}`}>Permalink</Link>
</NoteWrapper>
With this, we are using dynamic routes in our application and enabling users to view
individual notes.
Pagination
Currently we are only retrieving the 10 most recent notes within our application’s
home page. If we want to display additional notes, we need to enable pagination. You
may recall from the beginning of this chapter and the development of our API server
that our API returns a cursor, which is the ID of the last note returned in a page of
results. Additionally, the API returns the hasNextPage boolean, which is true if there
are additional notes found in our database. When making a request to our API, we
can pass it a cursor argument, which will return the next 10 items.
In other words, if we have a list of 25 objects (with corresponding IDs of 1–25), when
we make an initial request it will return items 1–10 as well as a cursor value of 10 and
a hasNextPage value of true. If we make a request, passing a cursor value of 10, we
will receive items 11–20, with a cursor value of 20 and a hasNextPage value of true.
Finally, if we make a third request, passing it a cursor of 20, we will receive items
21–25, with a cursor value of 25 and a hasNextPage value of false. This is exactly
the logic we’ll be implementing within our noteFeed query.
To do this, let’s update our src/pages/home.js file to make paginated queries. In our UI,
when a user clicks a See More button, the next 10 notes should load on the page. We’ll
want this to happen without any page refreshes. To do this we need to include the
150 | Chapter 14: Working with Apollo Client
fetchMore argument within our query component and display the Button compo‐
nent only when hasNextPage is true. For now we’ll write this directly into our home
page component, but it could easily be isolated into its own component or become
part of the NoteFeed component.
// if the data is successful, display the data in our UI
return (
 // add a <React.Fragment> element to provide a parent element
 <React.Fragment>
 <NoteFeed notes={data.noteFeed.notes} />
 {/* Only display the Load More button if hasNextPage is true */}
 {data.noteFeed.hasNextPage && (
 <Button>Load more</Button>
 )}
 </React.Fragment>
);
Conditionals in React
In the previous example we are conditionally displaying the “Load
more” button using an inline if statement with the && operator. If
hasNextPage is true, the button is displayed. You can read more
about conditional rendering in the official React documentation.
Now we can update the <Button> component to use an onClick handler. When a
user clicks the button, we’ll want to use the fetchMore method to make an additional
query and append the returned data to our page.
{data.noteFeed.hasNextPage && (
 // onClick peform a query, passing the current cursor as a variable
 <Button
 onClick={() =>
 fetchMore({
 variables: {
 cursor: data.noteFeed.cursor
 },
 updateQuery: (previousResult, { fetchMoreResult }) => {
 return {
 noteFeed: {
 cursor: fetchMoreResult.noteFeed.cursor,
 hasNextPage: fetchMoreResult.noteFeed.hasNextPage,
 // combine the new results and the old
 notes: [
 ...previousResult.noteFeed.notes,
 ...fetchMoreResult.noteFeed.notes
 ],
 __typename: 'noteFeed'
 }
 };
 }
Pagination | 151
 })
 }
 >
 Load more
 </Button>
)}
The previous code might look a little gnarly, so let’s break it down. Our <Button>
component includes an onClick handler. When the button is clicked, a new query is
executed using the fetchMore method, passing the cursor value returned in the pre‐
vious query. Once returned, updateQuery is executed, which updates our cursor and
hasNextPage values and combines the results into a single array. The __typename is
the name of the query, which is included in Apollo’s results.
With this change, we are able to view all of the notes from our note feed. Try it out
yourself by scrolling to the bottom of your note feed. If your database contains more
than 10 notes, the button will be visible. Clicking “Load more” will add the next note
Feed result to the page.
Conclusion
We’ve covered a lot of ground in this chapter. We’ve set up Apollo Client to work with
our React application and integrated multiple GraphQL queries into our UI. The
power of GraphQL is demonstrated in the ability to write single queries that return
precisely the data that a UI requires. In the next chapter we’ll integrate user authenti‐
cation into our application, allowing users to log in and view their notes and
favorites.
152 | Chapter 14: Working with Apollo Client
CHAPTER 15
Web Authentication and State
My family and I recently moved. After filling out and signing several forms (my hand
is still tired), we were handed the keys to the front door. Each time we come back
home, we are able to use those keys to unlock the door and enter. I’m grateful that I
don’t need to complete the form each time that I come home, but also appreciate hav‐
ing a lock so that we don’t have any unexpected guests.
Client-side web authentication works in much the same way. Our users will fill out a
form and will be handed a key to the website, in the form of a password alongside a
token stored in their browser. When they return to the site they will either be auto‐
matically authenticated with the token, or be able to sign back in using their
password.
In this chapter, we’ll build out a web authentication system with our GraphQL API.
To do this, we’ll be building forms, storing JWTs in the browser, sending tokens with
each request, and keeping track of our application’s state.
Creating a Sign-up Form
To get started with our application’s client authentication, we can create a user signup React component. Before doing so, let’s map out how the component will work.
First, a user will navigate to the /signup route within our application. On this page
they will be presented with a form where they can enter their email address, desired
username, and password. Submitting the form will perform our API’s signUp muta‐
tion. If the mutation is successful, a new user account will be created and the API will
return a JWT. If there is an error, we can inform the user. We’ll be displaying a generic
error message, but we could update our API to return specific error messages, such as
a pre-existing username or a duplicate email address.
153
Let’s get started by creating our new route. First, we’ll create a new React component
at src/pages/signup.js:
import React, { useEffect } from 'react';
// include the props passed to the component for later use
const SignUp = props => {
 useEffect(() => {
 // update the document title
 document.title = 'Sign Up — Notedly';
 });
 return (
 <div>
 <p>Sign Up</p>
 </div>
 );
};
export default SignUp;
Now we’ll update our route list in src/pages/index.js to include the signup route:
// import the signup route
import SignUp from './signup';
// within the Pages component add the route
<Route path="/signup" component={SignUp} />
By adding the route, we will be able to navigate to http://localhost:1234/signup to see
the (mostly empty) sign-up page. Now, let’s add the markup for our form:
import React, { useEffect } from 'react';
const SignUp = props => {
 useEffect(() => {
 // update the document title
 document.title = 'Sign Up — Notedly';
 });
 return (
 <div>
 <form>
 <label htmlFor="username">Username:</label>
 <input
 required
 type="text"
 id="username"
 name="username"
 placeholder="username"
 />
 <label htmlFor="email">Email:</label>
 <input
154 | Chapter 15: Web Authentication and State
 required
 type="email"
 id="email"
 name="email"
 placeholder="Email"
 />
 <label htmlFor="password">Password:</label>
 <input
 required
 type="password"
 id="password"
 name="password"
 placeholder="Password"
 />
 <button type="submit">Submit</button>
 </form>
 </div>
 );
};
export default SignUp;
htmlFor
If you’re just learning React, one of the common gotchas are JSX
attributes that differ from their HTML counterparts. In this case we
are using the JSX htmlFor in place of HTML’s for attribute to avoid
any JavaScript collisions. You can see a full, though short, list of
these attributes in the React DOM Elements documentation.
Now we can add some style by importing our Button component and styling the
form as a styled component:
import React, { useEffect } from 'react';
import styled from 'styled-components';
import Button from '../components/Button';
const Wrapper = styled.div`
 border: 1px solid #f5f4f0;
 max-width: 500px;
 padding: 1em;
 margin: 0 auto;
`;
const Form = styled.form`
 label,
 input {
 display: block;
 line-height: 2em;
 }
Creating a Sign-up Form | 155
 input {
 width: 100%;
 margin-bottom: 1em;
 }
`;
const SignUp = props => {
 useEffect(() => {
 // update the document title
 document.title = 'Sign Up — Notedly';
 });
 return (
 <Wrapper>
 <h2>Sign Up</h2>
 <Form>
 <label htmlFor="username">Username:</label>
 <input
 required
 type="text"
 id="username"
 name="username"
 placeholder="username"
 />
 <label htmlFor="email">Email:</label>
 <input
 required
 type="email"
 id="email"
 name="email"
 placeholder="Email"
 />
 <label htmlFor="password">Password:</label>
 <input
 required
 type="password"
 id="password"
 name="password"
 placeholder="Password"
 />
 <Button type="submit">Submit</Button>
 </Form>
 </Wrapper>
 );
};
export default SignUp;
156 | Chapter 15: Web Authentication and State
React Forms and State
In an application, things change. Data is entered into a form, a user toggles a slider
open, a message is sent. In React, we can track these changes at the component level
by assigning state. In our form, we’ll need to track the state of each form element, so
that it can be submitted.
React Hooks
In this book we’re using functional components and React’s newer
Hooks API. If you’ve used other learning resources that make use
of React’s class components, this may look a little different. You
can read more about Hooks in the React documentation.
To get started with state, we’ll first update the React import at the top of our src/pages/
signup.js file to include useState:
import React, { useEffect, useState } from 'react';
Next, within our SignUp component we’ll set the default form value state:
const SignUp = props => {
 // set the default state of the form
 const [values, setValues] = useState();
// rest of component goes here
};
Now we’ll update our component to change the state when a form field is entered and
perform an operation when a user submits the form. First, we’ll create an onChange
function, which will update our component’s state whenever the form is updated.
We’ll also update the markup of each form element to call this function when a user
makes a change, using the onChange property. Then we’ll update our form element to
include an onSubmit handler. For now, we’ll simply log our form data to the console.
In /src/pages/sigunp.js:
const SignUp = () => {
 // set the default state of the form
 const [values, setValues] = useState();
 // update the state when a user types in the form
 const onChange = event => {
 setValues({
 ...values,
 [event.target.name]: event.target.value
 });
 };
 useEffect(() => {
Creating a Sign-up Form | 157
 // update the document title
 document.title = 'Sign Up — Notedly';
 });
 return (
 <Wrapper>
 <h2>Sign Up</h2>
 <Form
 onSubmit={event => {
 event.preventDefault();
 console.log(values);
 }}
 >
 <label htmlFor="username">Username:</label>
 <input
 required
 type="text"
 name="username"
 placeholder="username"
 onChange={onChange}
 />
 <label htmlFor="email">Email:</label>
 <input
 required
 type="email"
 name="email"
 placeholder="Email"
 onChange={onChange}
 />
 <label htmlFor="password">Password:</label>
 <input
 required
 type="password"
 name="password"
 placeholder="Password"
 onChange={onChange}
 />
 <Button type="submit">Submit</Button>
 </Form>
 </Wrapper>
 );
};
With this form markup in place, we’re ready to request data with a GraphQL
mutation.
signUp Mutation
To sign up a user, we’ll be using our API’s signUp mutation. This mutation will accept
an email, username, and password as variables and return a JWT if the signup is suc‐
cessful. Let’s write our mutation and integrate it into our sign-up form.
158 | Chapter 15: Web Authentication and State
First, we’ll need to import our Apollo libraries. We’ll be making using of the useMuta
tion and useApolloClient hooks, as well as the gql syntax, from Apollo Client. In
src/pages/signUp, add the following alongside the other library import statements:
import { useMutation, useApolloClient, gql } from '@apollo/client';
Now write the GraphQL mutation as follows:
const SIGNUP_USER = gql`
 mutation signUp($email: String!, $username: String!, $password: String!) {
 signUp(email: $email, username: $username, password: $password)
 }
`;
With the mutation written, we can update our React component markup to perform
the mutation when a user submits the form, passing the form elements as variables.
For now, we’ll log our response (which, if successful, should be a JWT) to the console:
const SignUp = props => {
 // useState, onChange, and useEffect all remain the same here
 //add the mutation hook
 const [signUp, { loading, error }] = useMutation(SIGNUP_USER, {
 onCompleted: data => {
 // console.log the JSON Web Token when the mutation is complete
 console.log(data.signUp);
 }
});
 // render our form
 return (
 <Wrapper>
 <h2>Sign Up</h2>
 {/* pass the form data to the mutation when a user submits the form */}
 <Form
 onSubmit={event => {
 event.preventDefault();
 signUp({
 variables: {
 ...values
 }
 });
 }}
 >
 {/* ... the rest of the form remains unchanged ... */}
 </Form>
 </Wrapper>
 );
};
Creating a Sign-up Form | 159
Now if you complete and submit the form, you should see a JWT logged to your con‐
sole (Figure 15-1). Additionally, if you perform a users query in the GraphQL Play‐
ground (http://localhost:4000/api), you’ll see the new account (Figure 15-2).
Figure 15-1. If successful, a JSON Web Token will print to our console when we submit
the form
Figure 15-2. We can also see a list of users by performing a users query in the GraphQL
Playground
With our mutation in place and returning the expected data, next we want to store
the response that we receive.
160 | Chapter 15: Web Authentication and State
JSON Web Tokens and Local Storage
When our signUp mutation is successful, it returns a JSON Web Token (JWT). You
may recall from the API portion of the book that a JWT allows us to securely store a
user’s ID on the user’s device. To achieve this in our user’s web browser, we’ll store the
token in the browser’s localStorage. localStorage is a simple key-value store that
persists across browser sessions until the storage is updated or cleared. Let’s update
our mutation to store the token in localStorage.
In src/pages/signup.js, update the useMutation hook to store the token in
localStorage (see Figure 15-3):
const [signUp, { loading, error }] = useMutation(SIGNUP_USER, {
 onCompleted: data => {
 // store the JWT in localStorage
 localStorage.setItem('token', data.signUp);
 }
});
Figure 15-3. Our web token is now stored in the browser’s localStorage
JWTs and Security
When a token is stored in localStorage, any JavaScript that can be
run on the page has access to the token, making it susceptible to
cross-site scripting (XSS) attacks. For this reason, when using
localStorage to store token credentials, you need to take extra
care to limit (or avoid) CDN hosted scripts. If a third-party script is
compromised, it would have access to the JWT.
With our JWT stored locally, we’re prepared to use it in our GraphQL mutations and
queries.
Creating a Sign-up Form | 161
Redirects
Currently when a user completes the sign-up form, the form re-renders as an empty
form. This doesn’t leave the user with much of a visual cue that their account registra‐
tion was successful. Instead, let’s redirect the user to the home page of our applica‐
tion. Another option would be to create a “Success” page that thanks the user for
registering and onboards them to the application.
As you may recall from earlier in the chapter, we’re passing the properties into the
component. We can redirect a route using React Router’s history, which will be
available to us through props.history.push. To implement this, we’ll update our
mutation’s onCompleted event to include a redirect like so:
const [signUp, { loading, error }] = useMutation(SIGNUP_USER, {
 onCompleted: data => {
 // store the token
 localStorage.setItem('token', data.signUp);
 // redirect the user to the homepage
 props.history.push('/');
 }
 });
With this change, users will now be redirected to our application’s home page after
registering for an account.
Attaching Headers to Requests
Though we are storing our token in localStorage, our API does not yet have access
to it. This means that even if a user has created an account, the API has no way of
identifying the user. If you recall from our API development, each API call receives a
token in the header of the request. We’ll modify our client to send the JWT as a
header with each request.
In src/App.js we’ll update our dependencies to include createHttpLink from Apollo
Client as well as setContext from Apollo’s Link Context package. We’ll then update
Apollo’s configuration to send the token in the header of each request:
// import the Apollo dependencies
import {
 ApolloClient,
 ApolloProvider,
 createHttpLink,
 InMemoryCache
} from '@apollo/client';
import { setContext } from 'apollo-link-context';
// configure our API URI & cache
const uri = process.env.API_URI;
162 | Chapter 15: Web Authentication and State
const httpLink = createHttpLink({ uri });
const cache = new InMemoryCache();
// check for a token and return the headers to the context
const authLink = setContext((_, { headers }) => {
 return {
 headers: {
 ...headers,
 authorization: localStorage.getItem('token') || ''
 }
 };
});
// create the Apollo client
const client = new ApolloClient({
 link: authLink.concat(httpLink),
 cache,
 resolvers: {},
 connectToDevTools: true
});
With this change, we’ll now be able to pass the information of the logged-in user to
our API.
Local State Management
We’ve looked at managing state within a component, but what about across our appli‐
cation? There are times where it’s useful to have some information shared among
many components. We could pass props from a base component across our applica‐
tion, but as soon as we get past a couple of levels of subcomponents, this can get
messy. Libraries such as Redux and MobX have sought to solve the challenges of state
management and have proven useful for many developers and teams. In our case,
we’re already making use of the Apollo Client library, which includes the ability to use
GraphQL queries for local state management. Rather than introducing another
dependency, let’s implement a local state property that will store whether the user is
logged in.
The Apollo React library puts the ApolloClient instance within React’s context, but
at times we may need to access it directly. We can do so with the useApolloClient
hook, which will allow us to perform actions such as directly updating or resetting
the cache store or writing local data.
Currently, we have two ways to determine if a user is logged in to our application.
First, we know they are a current user if they’ve successfully submitted the sign-up
form. Second, we know that if a visitor accesses the site with a token stored in local
Storage, then they are already logged in. Let’s begin by adding to our state when a
Local State Management | 163
user completes the sign-up form. To achieve this, we’ll write directly to our Apollo
Client’s local store, using client.writeData and the useApolloClient hook.
In src/pages/signup.js we first need to update the @apollo/client library import to
include useApolloClient:
import { useMutation, useApolloClient } from '@apollo/client';
In src/pages/signup.js we’ll call the useApolloClient function and update the muta‐
tion to add to the local store, using writeData, when it is complete:
// Apollo Client
const client = useApolloClient();
// Mutation Hook
const [signUp, { loading, error }] = useMutation(SIGNUP_USER, {
 onCompleted: data => {
 // store the token
 localStorage.setItem('token', data.signUp);
 // update the local cache
 client.writeData({ data: { isLoggedIn: true } });
 // redirect the user to the homepage
 props.history.push('/');
 }
});
Now, let’s update our application to check for a pre-existing token when the page
loads and update the state when a token is found. In src/App.js, first update the
ApolloClient configuration to an empty resolvers object. This will allow us to per‐
form GraphQL queries on our local cache.
// create the Apollo client
const client = new ApolloClient({
 link: authLink.concat(httpLink),
 cache,
 resolvers: {},
 connectToDevTools: true
});
Next, we can perform the check on the initial page load of our application:
// check for a local token
const data = {
 isLoggedIn: !!localStorage.getItem('token')
};
// write the cache data on initial load
cache.writeData({ data });
Here comes the cool part: we can now access isLoggedIn as a GraphQL query any‐
where within our application by using the @client directive. To demonstrate this,
let’s update the header of our application to display a “Sign Up” and “Sign In” link if
isLoggedIn is false and a “Log Out” link if isLoggedIn is true.
164 | Chapter 15: Web Authentication and State
In src/components/Header.js, import the necessary dependencies and write the query
like so:
// new dependencies
import { useQuery, gql } from '@apollo/client';
import { Link } from 'react-router-dom';
// local query
const IS_LOGGED_IN = gql`
 {
 isLoggedIn @client
 }
`;
Now, within our React component we can include a simple query to retrieve the state
along with a tertiary operator that displays options either to log out or sign in:
const UserState = styled.div`
 margin-left: auto;
`;
const Header = props => {
 // query hook for user logged in state
 const { data } = useQuery(IS_LOGGED_IN);
 return (
 <HeaderBar>
 <img src={logo} alt="Notedly Logo" height="40" />
 <LogoText>Notedly</LogoText>
 {/* If logged in display a logout link, else display sign-in options */}
 <UserState>
 {data.isLoggedIn ? (
 <p>Log Out</p>
 ) : (
 <p>
 <Link to={'/signin'}>Sign In</Link> or{' '}
 <Link to={'/signup'}>Sign Up</Link>
 </p>
 )}
 </UserState>
 </HeaderBar>
 );
};
With this, when a user is logged in they’ll see a “Log Out” option: otherwise, they’ll be
presented with options to sign up or in, all thanks to local state. We’re not limited to
simple boolean logic, either. Apollo enables us to write local resolvers and type defini‐
tions, allowing us to take advantage of everything GraphQL has to offer within our
local state.
Local State Management | 165
Logging Out
Currently once a user is signed in, they have no way to log out of our application.
Let’s turn the “Log Out” language in our header into a button that, when clicked, will
log out the user. To do this, when the button is clicked we will remove the token that
has been stored in localStorage. We’ll use a <button> element for its built-in acces‐
sibility, as it both serves as a semantic representation of a user action and receives
focus, like a link, when a user is navigating the application with their keyboard.
Before writing our code, let’s write a styled component that will render a button like a
link. Create a new file at src/Components/ButtonAsLink.js and add the following:
import styled from 'styled-components';
const ButtonAsLink = styled.button`
 background: none;
 color: #0077cc;
 border: none;
 padding: 0;
 font: inherit;
 text-decoration: underline;
 cursor: pointer;
 :hover,
 :active {
 color: #004499;
 }
`;
export default ButtonAsLink;
Now in src/components/Header.js we can implement our logout functionality. We
need to use React Router’s withRouter higher-order component to handle the redi‐
rect since our Header.js file is a UI component and not a defined route. Let’s begin by
importing the ButtonAsLink component as well as withRouter:
// import both Link and withRouter from React Router
import { Link, withRouter } from 'react-router-dom';
// import the ButtonAsLink component
import ButtonAsLink from './ButtonAsLink';
Now, within our JSX we’ll update our component to include the props parameter and
update the logout markup to be a button:
const Header = props => {
 // query hook for user logged-in state,
 // including the client for referencing the Apollo store
 const { data, client } = useQuery(IS_LOGGED_IN);
 return (
 <HeaderBar>
166 | Chapter 15: Web Authentication and State
 <img src={logo} alt="Notedly Logo" height="40" />
 <LogoText>Notedly</LogoText>
 {/* If logged in display a logout link, else display sign-in options */}
 <UserState>
 {data.isLoggedIn ? (
 <ButtonAsLink>
 Logout
 </ButtonAsLink>
 ) : (
 <p>
 <Link to={'/signin'}>Sign In</Link> or{' '}
 <Link to={'/signup'}>Sign Up</Link>
 </p>
 )}
 </UserState>
 </HeaderBar>
 );
};
// we wrap our component in the withRouter higher-order component
export default withRouter(Header);
withRouter
When we want to include routing in a component that is not itself
directly routable, we need to use React Router’s withRouter higherorder component.
When a user logs out of our application, we want to reset the cache store to prevent
any unwanted data from appearing outside of the session. Apollo offers the ability to
call the resetStore function, which will fully clear the cache. Let’s add an onClick
handler to our component’s button to remove the user’s token, reset the Apollo Store,
update the local state, and redirect the user to the home page. To accomplish this,
we’ll update our useQuery hook to include a reference to the client and wrap our
component in the withRouter higher-order component in our export statement.
const Header = props => {
 // query hook for user logged in state
 const { data, client } = useQuery(IS_LOGGED_IN);
 return (
 <HeaderBar>
 <img src={logo} alt="Notedly Logo" height="40" />
 <LogoText>Notedly</LogoText>
 {/* If logged in display a logout link, else display sign-in options */}
 <UserState>
 {data.isLoggedIn ? (
 <ButtonAsLink
 onClick={() => {
 // remove the token
Logging Out | 167
 localStorage.removeItem('token');
 // clear the application's cache
 client.resetStore();
 // update local state
 client.writeData({ data: { isLoggedIn: false } });
 // redirect the user to the home page
 props.history.push('/');
 }}
 >
 Logout
 </ButtonAsLink>
 ) : (
 <p>
 <Link to={'/signin'}>Sign In</Link> or{' '}
 <Link to={'/signup'}>Sign Up</Link>
 </p>
 )}
 </UserState>
 </HeaderBar>
 );
};
export default withRouter(Header);
Finally, we will need Apollo to add the user state back to our cached state when the
store is reset. In src/App.js update the cache settings to include onResetStore:
// check for a local token
const data = {
 isLoggedIn: !!localStorage.getItem('token')
};
// write the cache data on initial load
cache.writeData({ data });
// write the cache data after cache is reset
client.onResetStore(() => cache.writeData({ data }));
With this, logged-in users are able to easily log out of our application. We’ve integra‐
ted this functionality directly into our Header component, but in the future we could
refactor it into a standalone component.
Creating a Sign-In Form
Currently our users are able to sign up and log out of our application, but they have
no way to sign back in. Let’s create a sign-in form and do a bit of refactoring along the
way so that we can reuse much of the code found in our signup component.
Our first step will be to create a new page component that will live at /signin. In a new
file at src/pages/signin.js, add the following:
168 | Chapter 15: Web Authentication and State
import React, { useEffect } from 'react';
const SignIn = props => {
 useEffect(() => {
 // update the document title
 document.title = 'Sign In — Notedly';
 });
 return (
 <div>
 <p>Sign up page</p>
 </div>
 );
};
export default SignIn;
Now we can make our page routable, so that users can navigate to it. In src/pages/
index.js import the route page and add a new route path:
// import the sign-in page component
import SignIn from './signin';
const Pages = () => {
 return (
 <Router>
 <Layout>
 // ... our other routes
 // add a signin route to our routes list
 <Route path="/signin" component={SignIn} />
 </Layout>
 </Router>
 );
};
Let’s pause here, before we implement our sign-in form, to consider our options. We
could reimplement a form, much like we wrote for our Sign Up page, but that feels
tedious and would require us to maintain two similar forms. When one changes, we
would need to be sure to update the other. Another option is to isolate the form into
its own component, which would allow us to reuse common code and make updates
in a single location. Let’s go forward with the shared form component approach.
We’ll first create a new component at src/components/UserForm.js, bringing over our
<form> markup and styles. We will be making a few minor, but notable, changes to
this form to use the properties that it receives from the parent component. First, we’ll
rename our onSubmit mutation to props.action, which will allow us to pass the
mutation to our form through the component’s properties. Second, we’ll add some
conditional statements where we know that our two forms will differ. We’ll make use
of a second property named formType, which we’ll pass a string. We can change our
template’s rendering based on the value of the string.
Creating a Sign-In Form | 169
We’ll write these either as an inline if statement with a logical && operator or as a
conditional ternary operator:
import React, { useState } from 'react';
import styled from 'styled-components';
import Button from './Button';
const Wrapper = styled.div`
 border: 1px solid #f5f4f0;
 max-width: 500px;
 padding: 1em;
 margin: 0 auto;
`;
const Form = styled.form`
 label,
 input {
 display: block;
 line-height: 2em;
 }
 input {
 width: 100%;
 margin-bottom: 1em;
 }
`;
const UserForm = props => {
 // set the default state of the form
 const [values, setValues] = useState();
 // update the state when a user types in the form
 const onChange = event => {
 setValues({
 ...values,
 [event.target.name]: event.target.value
 });
 };
 return (
 <Wrapper>
 {/* Display the appropriate form header */}
 {props.formType === 'signup' ? <h2>Sign Up</h2> : <h2>Sign In</h2>}
 {/* perform the mutation when a user submits the form */}
 <Form
 onSubmit={e => {
 e.preventDefault();
 props.action({
 variables: {
 ...values
 }
170 | Chapter 15: Web Authentication and State
 });
 }}
 >
 {props.formType === 'signup' && (
 <React.Fragment>
 <label htmlFor="username">Username:</label>
 <input
 required
 type="text"
 id="username"
 name="username"
 placeholder="username"
 onChange={onChange}
 />
 </React.Fragment>
 )}
 <label htmlFor="email">Email:</label>
 <input
 required
 type="email"
 id="email"
 name="email"
 placeholder="Email"
 onChange={onChange}
 />
 <label htmlFor="password">Password:</label>
 <input
 required
 type="password"
 id="password"
 name="password"
 placeholder="Password"
 onChange={onChange}
 />
 <Button type="submit">Submit</Button>
 </Form>
 </Wrapper>
 );
};
export default UserForm;
Now we can simplify our src/pages/signup.js component to make use of the shared
form component:
import React, { useEffect } from 'react';
import { useMutation, useApolloClient, gql } from '@apollo/client';
import UserForm from '../components/UserForm';
const SIGNUP_USER = gql`
 mutation signUp($email: String!, $username: String!, $password: String!) {
 signUp(email: $email, username: $username, password: $password)
Creating a Sign-In Form | 171
 }
`;
const SignUp = props => {
 useEffect(() => {
 // update the document title
 document.title = 'Sign Up — Notedly';
 });
 const client = useApolloClient();
 const [signUp, { loading, error }] = useMutation(SIGNUP_USER, {
 onCompleted: data => {
 // store the token
 localStorage.setItem('token', data.signUp);
 // update the local cache
 client.writeData({ data: { isLoggedIn: true } });
 // redirect the user to the homepage
 props.history.push('/');
 }
 });
 return (
 <React.Fragment>
 <UserForm action={signUp} formType="signup" />
 {/* if the data is loading, display a loading message*/}
 {loading && <p>Loading...</p>}
 {/* if there is an error, display a error message*/}
 {error && <p>Error creating an account!</p>}
 </React.Fragment>
 );
};
export default SignUp;
Finally, we can write our SignIn component, making use of our signIn mutation and
UserForm component. In src/pages/signin.js:
import React, { useEffect } from 'react';
import { useMutation, useApolloClient, gql } from '@apollo/client';
import UserForm from '../components/UserForm';
const SIGNIN_USER = gql`
 mutation signIn($email: String, $password: String!) {
 signIn(email: $email, password: $password)
 }
`;
const SignIn = props => {
 useEffect(() => {
 // update the document title
 document.title = 'Sign In — Notedly';
 });
172 | Chapter 15: Web Authentication and State
 const client = useApolloClient();
 const [signIn, { loading, error }] = useMutation(SIGNIN_USER, {
 onCompleted: data => {
 // store the token
 localStorage.setItem('token', data.signIn);
 // update the local cache
 client.writeData({ data: { isLoggedIn: true } });
 // redirect the user to the homepage
 props.history.push('/');
 }
 });
 return (
 <React.Fragment>
 <UserForm action={signIn} formType="signIn" />
 {/* if the data is loading, display a loading message*/}
 {loading && <p>Loading...</p>}
 {/* if there is an error, display a error message*/}
 {error && <p>Error signing in!</p>}
 </React.Fragment>
 );
};
export default SignIn;
With this, we now have a manageable form component and have enabled users to
both sign up and sign in to our application.
Protected Routes
A common application pattern is to limit access to specific pages or portions of the
site to authenticated users. In our case, nonauthenticated users would have no use for
the My Notes or Favorites pages. We can implement this pattern in our router, auto‐
matically routing unauthenticated users to the application’s Sign In page when they
attempt to visit those routes.
In src/pages/index.js we’ll start by importing the necessary dependencies and adding
our isLoggedIn query:
import { useQuery, gql } from '@apollo/client';
const IS_LOGGED_IN = gql`
 {
 isLoggedIn @client
 }
`;
Now we’ll import React Router’s Redirect library and write a PrivateRoute compo‐
nent, which will redirect the user if they are not logged in:
Protected Routes | 173
// update our react-router import to include Redirect
import { BrowserRouter as Router, Route, Redirect } from 'react-router-dom';
// add the PrivateRoute component below our `Pages` component
const PrivateRoute = ({ component: Component, ...rest }) => {
 const { loading, error, data } = useQuery(IS_LOGGED_IN);
 // if the data is loading, display a loading message
 if (loading) return <p>Loading...</p>;
 // if there is an error fetching the data, display an error message
 if (error) return <p>Error!</p>;
 // if the user is logged in, route them to the requested component
 // else redirect them to the sign-in page
 return (
 <Route
 {...rest}
 render={props =>
 data.isLoggedIn === true ? (
 <Component {...props} />
 ) : (
 <Redirect
 to={{
 pathname: '/signin',
 state: { from: props.location }
 }}
 />
 )
 }
 />
 );
};
export default Pages;
Finally, we can update any of our routes intended for logged-in users to use the
PrivateRoute component:
const Pages = () => {
 return (
 <Router>
 <Layout>
 <Route exact path="/" component={Home} />
 <PrivateRoute path="/mynotes" component={MyNotes} />
 <PrivateRoute path="/favorites" component={Favorites} />
 <Route path="/note/:id" component={Note} />
 <Route path="/signup" component={SignUp} />
 <Route path="/signin" component={SignIn} />
 </Layout>
 </Router>
 );
};
174 | Chapter 15: Web Authentication and State
Redirect State
When we redirect a private route, we are also storing the referring
URL as state. This allows us to redirect users back to the page they
were originally attempting to navigate to. We could update our
redirect on the Sign In page to optionally use props.state.
location.from to enable this feature.
Now when a user attempts to navigate to a page intended for logged-in users, they
will be redirected to our Sign In page.
Conclusion
In this chapter we’ve covered two critical concepts for building client-side JavaScript
applications: authentication and state. By building a full authentication flow, you’ve
gained insight into how user accounts work with a client application. From here, I
would encourage you to explore alternate options such as OAuth and authentication
services such as Auth0, Okta, and Firebase. Additionally, you’ve learned to manage
state in an application, both at the component level, using the React Hooks API, as
well as across the application, using Apollo’s local state. With these key concepts
behind you, you can now build robust user interface applications.
Conclusion | 175

CHAPTER 16
Create, Read, Update,
and Delete Operations
I love paper notebooks and keep one with me at nearly all times. Usually they are rel‐
atively inexpensive and I quickly fill them with half-formed thoughts. Not long ago I
purchased a pricier hardback notebook, with a lovely cover and fancy paper stock. At
the time of purchase, I had grand ambitions of the types of sketches and planning
that would happen within that notebook, but it sat completely empty on my desk for
months. Eventually, I put it on a shelf and went back to my standard notebook brand.
Much like my fancy notebook, our app is useful only if our users are able to interact
with it. You may recall from our API development that the Notedly application is a
“CRUD” (create, read, update, and delete) application. An authenticated user can cre‐
ate new notes, read notes, update the content of a note or a note’s status as a favorite,
and delete a note. In this chapter, we’ll implement all of this functionality within our
web user interface. To accomplish these tasks, we’ll be writing GraphQL mutations
and queries.
Creating New Notes
Currently we have the means to view notes, but not a way to create them. This is akin
to having a notebook without a pen. Let’s add the ability for users to create new notes.
We’ll do this by creating a textarea form in which users can write the note. When
the user submits the form, we’ll perform a GraphQL mutation to create the note in
our database.
To begin, let’s create the NewNote component at src/pages/new.js:
import React, { useEffect } from 'react';
import { useMutation, gql } from '@apollo/client';
177
const NewNote = props => {
 useEffect(() => {
 // update the document title
 document.title = 'New Note — Notedly';
 });
 return <div>New note</div>;
};
export default NewNote;
Next, let’s set up the new route in our src/pages/index.js file:
// import the NewNote route component
import NewNote from './new';
// add a private route to our list of routes, within the
<PrivateRoute path="/new" component={NewNote} />
We know that we’ll be both creating new notes as well as updating existing notes. To
accommodate this behavior, let’s create a new component called NoteForm, which will
serve as the markup and React state for note form editing.
We’ll create a new file at src/components/NoteForm.js. The component will consist of a
form element containing a text area along with some minimal styles. The functional‐
ity will be much like our UserForm component:
import React, { useState } from 'react';
import styled from 'styled-components';
import Button from './Button';
const Wrapper = styled.div`
 height: 100%;
`;
const Form = styled.form`
 height: 100%;
`;
const TextArea = styled.textarea`
 width: 100%;
 height: 90%;
`;
const NoteForm = props => {
 // set the default state of the form
 const [value, setValue] = useState({ content: props.content || '' });
 // update the state when a user types in the form
 const onChange = event => {
 setValue({
178 | Chapter 16: Create, Read, Update, and Delete Operations
 ...value,
 [event.target.name]: event.target.value
 });
 };
 return (
 <Wrapper>
 <Form
 onSubmit={e => {
 e.preventDefault();
 props.action({
 variables: {
 ...values
 }
 });
 }}
 >
 <TextArea
 required
 type="text"
 name="content"
 placeholder="Note content"
 value={value.content}
 onChange={onChange}
 />
 <Button type="submit">Save</Button>
 </Form>
 </Wrapper>
 );
};
export default NoteForm;
Next, we will need to reference our NoteForm component in our NewNote page com‐
ponent. In src/pages/new.js:
import React, { useEffect } from 'react';
import { useMutation, gql } from '@apollo/client';
// import the NoteForm component
import NoteForm from '../components/NoteForm';
const NewNote = props => {
 useEffect(() => {
 // update the document title
 document.title = 'New Note — Notedly';
 });
 return <NoteForm />;
};
export default NewNote;
Creating New Notes | 179
With these updates, navigating to http://localhost:1234/new will display our form
(Figure 16-1).
Figure 16-1. Our NewNote component presents the user with a large text area and Save
button
With the form complete, we can go about writing our mutation to create the new
note. In src/pages/new.js:
import React, { useEffect } from 'react';
import { useMutation, gql } from '@apollo/client';
import NoteForm from '../components/NoteForm';
// our new note query
const NEW_NOTE = gql`
 mutation newNote($content: String!) {
 newNote(content: $content) {
 id
 content
 createdAt
 favoriteCount
 favoritedBy {
 id
 username
 }
 author {
180 | Chapter 16: Create, Read, Update, and Delete Operations
 username
 id
 }
 }
 }
`;
const NewNote = props => {
 useEffect(() => {
 // update the document title
 document.title = 'New Note — Notedly';
 });
 const [data, { loading, error }] = useMutation(NEW_NOTE, {
 onCompleted: data => {
 // when complete, redirect the user to the note page
 props.history.push(`note/${data.newNote.id}`);
 }
 });
 return (
 <React.Fragment>
 {/* as the mutation is loading, display a loading message*/}
 {loading && <p>Loading...</p>}
 {/* if there is an error, display a error message*/}
 {error && <p>Error saving the note</p>}
 {/* the form component, passing the mutation data as a prop */}
 <NoteForm action={data} />
 </React.Fragment>
 );
};
export default NewNote;
In the previous code we are performing a newNote mutation when the form is sub‐
mitted. If the mutation is successful, the user is redirected to the individual note page.
You may notice that the newNote mutation requests quite a bit of data. This matches
the data requested by the note mutation, ideally updating Apollo’s cache for quick
navigation to the individual note component.
As mentioned earlier, Apollo aggressively caches our queries, which is helpful for
speeding up our application’s navigation. Unfortunately, this also means a user could
visit a page and not see an update they’ve just made. We can manually update Apollo’s
cache, but an easier way to accomplish this is to use Apollo’s refetchQueries feature
to intentionally update the cache when performing a mutation. To do this, we’ll need
access to our prewritten queries. Up until now, we’ve been including them at the top
of a component file, but let’s move them to their own query.js file. Create a new file
at /src/gql/query.js and add each of our note queries as well as our IS_LOGGED_IN
query:
Creating New Notes | 181
import { gql } from '@apollo/client';
const GET_NOTES = gql`
 query noteFeed($cursor: String) {
 noteFeed(cursor: $cursor) {
 cursor
 hasNextPage
 notes {
 id
 createdAt
 content
 favoriteCount
 author {
 username
 id
 avatar
 }
 }
 }
 }
`;
const GET_NOTE = gql`
 query note($id: ID!) {
 note(id: $id) {
 id
 createdAt
 content
 favoriteCount
 author {
 username
 id
 avatar
 }
 }
 }
`;
const IS_LOGGED_IN = gql`
 {
 isLoggedIn @client
 }
`;
export { GET_NOTES, GET_NOTE, IS_LOGGED_IN };
Reusable Queries and Mutations
Moving forward, we will keep all of our queries and mutations sep‐
arate from our components This will allow us to easily reuse them
in our application and is also useful for mocking during testing.
182 | Chapter 16: Create, Read, Update, and Delete Operations
Now in src/pages/new.js we can request that our mutation refetch the GET_NOTES
query by importing the query and adding the refetchQueries option:
// import the query
import { GET_NOTES } from '../gql/query';
// within the NewNote component update the mutation
//everything else stays the same
const NewNote = props => {
 useEffect(() => {
 // update the document title
 document.title = 'New Note — Notedly';
 });
 const [data, { loading, error }] = useMutation(NEW_NOTE, {
 // refetch the GET_NOTES query to update the cache
 refetchQueries: [{ query: GET_NOTES }],
 onCompleted: data => {
 // when complete, redirect the user to the note page
 props.history.push(`note/${data.newNote.id}`);
 }
 });
 return (
 <React.Fragment>
 {/* as the mutation is loading, display a loading message*/}
 {loading && <p>Loading...</p>}
 {/* if there is an error, display a error message*/}
 {error && <p>Error saving the note</p>}
 {/* the form component, passing the mutation data as a prop */}
 <NoteForm action={data} />
 </React.Fragment>
 );
};
Our final step will be to add a link to our /new page, so that users can easily navigate
to it. In the src/components/Navigation.js file, add a new link item as follows:
<li>
 <Link to="/new">New</Link>
</li>
With this, our users are able to navigate to the new note page, type a note, and save
the note to the database.
Reading User Notes
Our application is currently capable of reading our note feed as well as individual
notes, but we are not yet querying the notes of authenticated users. Let’s write two
GraphQL queries to create a feed of notes by the user as well as their favorites.
Reading User Notes | 183
In src/gql/query.js, add a GET_MY_NOTES query and update the exports like so:
// add the GET_MY_NOTES query
const GET_MY_NOTES = gql`
 query me {
 me {
 id
 username
 notes {
 id
 createdAt
 content
 favoriteCount
 author {
 username
 id
 avatar
 }
 }
 }
 }
`;
// update to include GET_MY_NOTES
export { GET_NOTES, GET_NOTE, IS_LOGGED_IN, GET_MY_NOTES };
Now in src/pages/mynotes.js, import the query and display the notes using the Note
Feed component:
import React, { useEffect } from 'react';
import { useQuery, gql } from '@apollo/client';
import NoteFeed from '../components/NoteFeed';
import { GET_MY_NOTES } from '../gql/query';
const MyNotes = () => {
 useEffect(() => {
 // update the document title
 document.title = 'My Notes — Notedly';
 });
 const { loading, error, data } = useQuery(GET_MY_NOTES);
 // if the data is loading, our app will display a loading message
 if (loading) return 'Loading...';
 // if there is an error fetching the data, display an error message
 if (error) return `Error! ${error.message}`;
 // if the query is successful and there are notes, return the feed of notes
 // else if the query is successful and there aren't notes, display a message
 if (data.me.notes.length !== 0) {
 return <NoteFeed notes={data.me.notes} />;
 } else {
 return <p>No notes yet</p>;
184 | Chapter 16: Create, Read, Update, and Delete Operations
 }
};
export default MyNotes;
We can repeat this process to make the “favorites” page. First, in src/gql/query.js:
// add the GET_MY_FAVORITES query
const GET_MY_FAVORITES = gql`
 query me {
 me {
 id
 username
 favorites {
 id
 createdAt
 content
 favoriteCount
 author {
 username
 id
 avatar
 }
 }
 }
 }
`;
// update to include GET_MY_FAVORITES
export { GET_NOTES, GET_NOTE, IS_LOGGED_IN, GET_MY_NOTES, GET_MY_FAVORITES };
Now, in src/pages/favorites.js:
import React, { useEffect } from 'react';
import { useQuery, gql } from '@apollo/client';
import NoteFeed from '../components/NoteFeed';
// import the query
import { GET_MY_FAVORITES } from '../gql/query';
const Favorites = () => {
 useEffect(() => {
 // update the document title
 document.title = 'Favorites — Notedly';
 });
 const { loading, error, data } = useQuery(GET_MY_FAVORITES);
 // if the data is loading, our app will display a loading message
 if (loading) return 'Loading...';
 // if there is an error fetching the data, display an error message
 if (error) return `Error! ${error.message}`;
 // if the query is successful and there are notes, return the feed of notes
 // else if the query is successful and there aren't notes, display a message
Reading User Notes | 185
 if (data.me.favorites.length !== 0) {
 return <NoteFeed notes={data.me.favorites} />;
 } else {
 return <p>No favorites yet</p>;
 }
};
export default Favorites;
Finally, let’s update our src/pages/new.js file to refetch the GET_MY_NOTES query, to
ensure that a cached list of user notes is updated when the note is created. In src/
pages/new.js, first update the GraphQL query import statement:
import { GET_MY_NOTES, GET_NOTES } from '../gql/query';
And then update the mutation:
const [data, { loading, error }] = useMutation(NEW_NOTE, {
 // refetch the GET_NOTES and GET_MY_NOTES queries to update the cache
 refetchQueries: [{ query: GET_MY_NOTES }, { query: GET_NOTES }],
 onCompleted: data => {
 // when complete, redirect the user to the note page
 props.history.push(`note/${data.newNote.id}`);
 }
});
With these changes, we now can perform all of the read operations within our
application.
Updating Notes
Currently once a user writes a note, they have no way to make an update to it. To
address this, we want to enable note editing in our application. Our GraphQL API
has an updateNote mutation, which accepts a note ID and content as parameters. If
the note exists in the database, the mutation will update the stored content with the
content sent in the mutation.
In our application, we can create a route at /edit/NOTE_ID that will place the existing
note content in a form textarea. When a user clicks Save, we’ll submit the form and
perform the updateNote mutation.
Let’s create a new route where our notes will be edited. To begin, we can make a
duplicate of our src/pages/note.js page and name it edit.js. For now, this page will sim‐
ply display the note.
At src/pages/edit.js:
import React from 'react';
import { useQuery, useMutation, gql } from '@apollo/client';
// import the Note component
186 | Chapter 16: Create, Read, Update, and Delete Operations
import Note from '../components/Note';
// import the GET_NOTE query
import { GET_NOTE } from '../gql/query';
const EditNote = props => {
 // store the id found in the url as a variable
 const id = props.match.params.id;
 // define our note query
 const { loading, error, data } = useQuery(GET_NOTE, { variables: { id } });
 // if the data is loading, display a loading message
 if (loading) return 'Loading...';
 // if there is an error fetching the data, display an error message
 if (error) return <p>Error! Note not found</p>;
 // if successful, pass the data to the note component
 return <Note note={data.note} />;
};
export default EditNote;
Now, we can make the page navigable by adding it to our routes in src/pages/index.js:
// import the edit page component
import EditNote from './edit';
// add a new private route that accepts an :id parameter
<PrivateRoute path="/edit/:id" component={EditNote} />
With this, if you navigate to a note page at /note/ID and swap it for /edit/ID you’ll see
a render of the note itself. Let’s change this so that it instead displays the note content
presented in a form’s textarea.
In src/pages/edit.js, remove the import statement of the Note component and replace
it with the NoteForm component:
// import the NoteForm component
import NoteForm from '../components/NoteForm';
Now we can update our EditNote component to use our editing form. We can pass
the content of the note to our form component by using the content property.
Though our GraphQL mutation will accept updates only from the original author, we
can also limit displaying the form to the note’s author, to avoid confusing other users.
First, add a new query to the src/gql/query.js file to get the current user, their user ID,
and a list of favorited note IDs:
// add GET_ME to our queries
const GET_ME = gql`
 query me {
 me {
 id
 favorites {
 id
Updating Notes | 187
 }
 }
 }
`;
// update to include GET_ME
export {
 GET_NOTES,
 GET_NOTE,
 GET_MY_NOTES,
 GET_MY_FAVORITES,
 GET_ME,
 IS_LOGGED_IN
};
In src/pages/edit.js, import the GET_ME query and include a user check:
import React from 'react';
import { useMutation, useQuery } from '@apollo/client';
// import the NoteForm component
import NoteForm from '../components/NoteForm';
import { GET_NOTE, GET_ME } from '../gql/query';
import { EDIT_NOTE } from '../gql/mutation';
const EditNote = props => {
 // store the id found in the url as a variable
 const id = props.match.params.id;
 // define our note query
 const { loading, error, data } = useQuery(GET_NOTE, { variables: { id } });
 // fetch the current user's data
 const { data: userdata } = useQuery(GET_ME);
 // if the data is loading, display a loading message
 if (loading) return 'Loading...';
 // if there is an error fetching the data, display an error message
 if (error) return <p>Error! Note not found</p>;
 // if the current user and the author of the note do not match
 if (userdata.me.id !== data.note.author.id) {
 return <p>You do not have access to edit this note</p>;
 }
 // pass the data to the form component
 return <NoteForm content={data.note.content} />;
};
We are now able to edit a note in the form, but clicking the button does not yet save
our changes. Let’s write our GraphQL updateNote mutation. Similar to our file of
queries, let’s create a file to hold our mutations. In src/gql/mutation, add the following:
import { gql } from '@apollo/client';
const EDIT_NOTE = gql`
 mutation updateNote($id: ID!, $content: String!) {
 updateNote(id: $id, content: $content) {
188 | Chapter 16: Create, Read, Update, and Delete Operations
 id
 content
 createdAt
 favoriteCount
 favoritedBy {
 id
 username
 }
 author {
 username
 id
 }
 }
 }
`;
export { EDIT_NOTE };
With our mutation written, we can import it and update our component code to call
the mutation when the button is clicked. To do this, we will add a useMutation hook.
When the mutation is complete, we’ll redirect the user to the note page.
// import the mutation
import { EDIT_NOTE } from '../gql/mutation';
const EditNote = props => {
 // store the id found in the url as a variable
 const id = props.match.params.id;
 // define our note query
 const { loading, error, data } = useQuery(GET_NOTE, { variables: { id } });
 // fetch the current user's data
 const { data: userdata } = useQuery(GET_ME);
 // define our mutation
 const [editNote] = useMutation(EDIT_NOTE, {
 variables: {
 id
 },
 onCompleted: () => {
 props.history.push(`/note/${id}`);
 }
 });
 // if the data is loading, display a loading message
 if (loading) return 'Loading...';
 // if there is an error fetching the data, display an error message
 if (error) return <p>Error!</p>;
 // if the current user and the author of the note do not match
 if (userdata.me.id !== data.note.author.id) {
 return <p>You do not have access to edit this note</p>;
 }
 // pass the data and mutation to the form component
Updating Notes | 189
 return <NoteForm content={data.note.content} action={editNote} />;
};
export default EditNote;
Finally, we’ll want to display an “Edit” link to users, but only if they are the author of
the note. In our application, we will need to check to ensure that the ID of the current
user matches the ID of the note author. To implement this behavior, we’ll be touching
several components.
Now we could implement our functionality directly within the Note component, but
let’s instead create a component specifically for logged-in user interactions at src/
components/NoteUser.js. In this React component we will perform a GraphQL query
for the current user ID and provide a routable link to the edit page. With this infor‐
mation, we can begin by including our required libraries and setting up a new React
component. Within the React component, we will include an edit link, which will
route the user to the edit page for the note. For now, the user will see this link regard‐
less of who owns the note.
Update src/components/NoteUser.js as follows:
import React from 'react';
import { useQuery, gql } from '@apollo/client';
import { Link } from 'react-router-dom';
const NoteUser = props => {
 return <Link to={`/edit/${props.note.id}`}>Edit</Link>;
};
export default NoteUser;
Next, we will update our Note component to perform a local isLoggedIn state query.
We can then conditionally render our NoteUser component based on the logged-in
state of the user.
Let’s first import the GraphQL libraries to perform the query along with our Note
User component. In src/components/Note.js, add the following at the top of the file:
import { useQuery } from '@apollo/client';
// import logged in user UI components
import NoteUser from './NoteUser';
// import the IS_LOGGED_IN local query
import { IS_LOGGED_IN } from '../gql/query';
Now, we can update our JSX component to check the logged-in state. If the user is
logged in, we’ll display the NoteUser component; otherwise, we’ll display the favorite
count.
const Note = ({ note }) => {
 const { loading, error, data } = useQuery(IS_LOGGED_IN);
190 | Chapter 16: Create, Read, Update, and Delete Operations
 // if the data is loading, display a loading message
 if (loading) return <p>Loading...</p>;
 // if there is an error fetching the data, display an error message
 if (error) return <p>Error!</p>;
 return (
 <StyledNote>
 <MetaData>
 <MetaInfo>
 <img
 src={note.author.avatar}
 alt={`${note.author.username} avatar`}
 height="50px"
 />
 </MetaInfo>
 <MetaInfo>
 <em>by</em> {note.author.username} <br />
 {format(note.createdAt, 'MMM Do YYYY')}
 </MetaInfo>
 {data.isLoggedIn ? (
 <UserActions>
 <NoteUser note={note} />
 </UserActions>
 ) : (
 <UserActions>
 <em>Favorites:</em> {note.favoriteCount}
 </UserActions>
 )}
 </MetaData>
 <ReactMarkdown source={note.content} />
 </StyledNote>
 );
};
Unauthenticated Edits
Though we will be hiding the edit link in the UI, users could still
navigate to a note’s edit screen without being the note owner.
Thankfully, our GraphQL API is designed to prevent anyone but
the note owner from editing the note’s content. Though we won’t
be doing it in this book, a good additional step would be to update
the src/pages/edit.js component to redirect a user if they are not the
note owner.
With this change, logged-in users are able to see an edit link at the top of each note.
Clicking the link will navigate to an edit form, regardless of who is the owner of the
note. Let’s address this by updating our NoteUser component to query for the current
user’s ID and display the edit link only if it matches the ID of the note author.
First in src/components/NoteUser.js, add the following:
Updating Notes | 191
import React from 'react';
import { useQuery } from '@apollo/client';
import { Link } from 'react-router-dom';
// import our GET_ME query
import { GET_ME } from '../gql/query';
const NoteUser = props => {
 const { loading, error, data } = useQuery(GET_ME);
 // if the data is loading, display a loading message
 if (loading) return <p>Loading...</p>;
 // if there is an error fetching the data, display an error message
 if (error) return <p>Error!</p>;
 return (
 <React.Fragment>
 Favorites: {props.note.favoriteCount}
 <br />
 {data.me.id === props.note.author.id && (
 <React.Fragment>
 <Link to={`/edit/${props.note.id}`}>Edit</Link>
 </React.Fragment>
 )}
 </React.Fragment>
 );
};
export default NoteUser;
With this change, only the note’s original author will see the edit link in the UI
(Figure 16-2).
Figure 16-2. Only the note’s author will see the edit link
192 | Chapter 16: Create, Read, Update, and Delete Operations
Deleting Notes
Our CRUD application is still missing the ability to delete a note. We can write a but‐
ton UI component that, when clicked, will perform a GraphQL mutation, deleting the
note. Let’s start by creating a new component at src/components/DeleteNote.js. Since
we will be performing a redirect within a nonroutable component, we will use React
Router’s withRouter higher-order component:
import React from 'react';
import { useMutation } from '@apollo/client';
import { withRouter } from 'react-router-dom';
import ButtonAsLink from './ButtonAsLink';
const DeleteNote = props => {
 return <ButtonAsLink>Delete Note</ButtonAsLink>;
};
export default withRouter(DeleteNote);
Now, we can write our mutation. Our GraphQL API has a deleteNote mutation,
which returns a boolean of true if the note is deleted. When the mutation completes,
we’ll redirect the user to the /mynotes page of our application.
First, in src/gql/mutation.js, write the mutation as follows:
const DELETE_NOTE = gql`
 mutation deleteNote($id: ID!) {
 deleteNote(id: $id)
 }
`;
// update to include DELETE_NOTE
export { EDIT_NOTE, DELETE_NOTE };
Now in src/components/DeleteNote, add the following:
import React from 'react';
import { useMutation } from '@apollo/client';
import { withRouter } from 'react-router-dom';
import ButtonAsLink from './ButtonAsLink';
// import the DELETE_NOTE mutation
import { DELETE_NOTE } from '../gql/mutation';
// import queries to refetch after note deletion
import { GET_MY_NOTES, GET_NOTES } from '../gql/query';
const DeleteNote = props => {
 const [deleteNote] = useMutation(DELETE_NOTE, {
 variables: {
 id: props.noteId
 },
Deleting Notes | 193
 // refetch the note list queries to update the cache
 refetchQueries: [{ query: GET_MY_NOTES, GET_NOTES }],
 onCompleted: data => {
 // redirect the user to the "my notes" page
 props.history.push('/mynotes');
 }
 });
 return <ButtonAsLink onClick={deleteNote}>Delete Note</ButtonAsLink>;
};
export default withRouter(DeleteNote);
Now, we can import the new DeleteNote component within our src/components/
NoteUser.js file, displaying it only to a note’s author:
import React from 'react';
import { useQuery } from '@apollo/client';
import { Link } from 'react-router-dom';
import { GET_ME } from '../gql/query';
// import the DeleteNote component
import DeleteNote from './DeleteNote';
const NoteUser = props => {
 const { loading, error, data } = useQuery(GET_ME);
 // if the data is loading, display a loading message
 if (loading) return <p>Loading...</p>;
 // if there is an error fetching the data, display an error message
 if (error) return <p>Error!</p>;
 return (
 <React.Fragment>
 Favorites: {props.note.favoriteCount} <br />
 {data.me.id === props.note.author.id && (
 <React.Fragment>
 <Link to={`/edit/${props.note.id}`}>Edit</Link> <br />
 <DeleteNote noteId={props.note.id} />
 </React.Fragment>
 )}
 </React.Fragment>
 );
};
export default NoteUser;
With this mutation written, logged-in users are now able to delete a note with the
click of a button.
194 | Chapter 16: Create, Read, Update, and Delete Operations
Toggling Favorites
The last piece of user functionality missing from our application is the ability to add
and remove “favorite” notes. Let’s follow our pattern of creating a component for this
feature and integrating it into our application. First, create a new component at src/
components/FavoriteNote.js:
import React, { useState } from 'react';
import { useMutation } from '@apollo/client';
import ButtonAsLink from './ButtonAsLink';
const FavoriteNote = props => {
 return <ButtonAsLink>Add to favorites</ButtonAsLink>;
};
export default FavoriteNote;
Before we add any functionality, let’s go ahead and incorporate this component into
our src/components/NoteUser.js component. First, import the component:
import FavoriteNote from './FavoriteNote';
Now, within our JSX, include a reference to the component. You may recall that when
we wrote our GET_ME query, we included a list of favorited note IDs, which we’ll make
use of here:
return (
 <React.Fragment>
 <FavoriteNote
 me={data.me}
 noteId={props.note.id}
 favoriteCount={props.note.favoriteCount}
 />
 <br />
 {data.me.id === props.note.author.id && (
 <React.Fragment>
 <Link to={`/edit/${props.note.id}`}>Edit</Link> <br />
 <DeleteNote noteId={props.note.id} />
 </React.Fragment>
 )}
 </React.Fragment>
);
You’ll notice that we’re passing three properties to our FavoriteNote component.
First is our me data, which will include the current user’s ID as well as a list of notes
favorited by that user. Second, the noteID of the current note. And finally is the favor
iteCount, which is the current total number of user favorites.
Now we can return to our src/components/FavoriteNote.js file. In this file, we’ll store
the current number of favorites as state and check to see if the current note ID is in
Toggling Favorites | 195
the existing list of user favorites. We’ll change the text that the user sees based on the
state of the user’s favorite. When the user clicks the button, it will call our toggleFa
vorite mutation, which will either add or remove the favorite from the user’s list.
Let’s begin by updating the component to use state to control the click functionality.
const FavoriteNote = props => {
 // store the note's favorite count as state
 const [count, setCount] = useState(props.favoriteCount);
 // store if the user has favorited the note as state
 const [favorited, setFavorited] = useState(
 // check if the note exists in the user favorites list
 props.me.favorites.filter(note => note.id === props.noteId).length > 0
 );
 return (
 <React.Fragment>
 {favorited ? (
 <ButtonAsLink
 onClick={() => {
 setFavorited(false);
 setCount(count - 1);
 }}
 >
 Remove Favorite
 </ButtonAsLink>
 ) : (
 <ButtonAsLink
 onClick={() => {
 setFavorited(true);
 setCount(count + 1);
 }}
 >
 Add Favorite
 </ButtonAsLink>
 )}
 : {count}
 </React.Fragment>
 );
};
With the preceding changes we’re updating the state when a user clicks, but we’re not
yet calling our GraphQL mutation. Let’s complete this component by writing the
mutation and adding it to the component. The result is shown in Figure 16-3.
In src/gql/mutation.js:
// add the TOGGLE_FAVORITE mutation
const TOGGLE_FAVORITE = gql`
 mutation toggleFavorite($id: ID!) {
 toggleFavorite(id: $id) {
 id
196 | Chapter 16: Create, Read, Update, and Delete Operations
 favoriteCount
 }
 }
`;
// update to include TOGGLE_FAVORITE
export { EDIT_NOTE, DELETE_NOTE, TOGGLE_FAVORITE };
In src/components/FavoriteNote.js:
import React, { useState } from 'react';
import { useMutation } from '@apollo/client';
import ButtonAsLink from './ButtonAsLink';
// the TOGGLE_FAVORITE mutation
import { TOGGLE_FAVORITE } from '../gql/mutation';
// add the GET_MY_FAVORITES query to refetch
import { GET_MY_FAVORITES } from '../gql/query';
const FavoriteNote = props => {
 // store the note's favorite count as state
 const [count, setCount] = useState(props.favoriteCount);
 // store if the user has favorited the note as state
 const [favorited, setFavorited] = useState(
 // check if the note exists in the user favorites list
 props.me.favorites.filter(note => note.id === props.noteId).length > 0
 );
 // toggleFavorite mutation hook
 const [toggleFavorite] = useMutation(TOGGLE_FAVORITE, {
 variables: {
 id: props.noteId
 },
 // refetch the GET_MY_FAVORITES query to update the cache
 refetchQueries: [{ query: GET_MY_FAVORITES }]
 });
 // if the user has favorited the note, display the option to remove the favorite
 // else, display the option to add as a favorite
 return (
 <React.Fragment>
 {favorited ? (
 <ButtonAsLink
 onClick={() => {
 toggleFavorite();
 setFavorited(false);
 setCount(count - 1);
 }}
 >
 Remove Favorite
 </ButtonAsLink>
 ) : (
Toggling Favorites | 197
 <ButtonAsLink
 onClick={() => {
 toggleFavorite();
 setFavorited(true);
 setCount(count + 1);
 }}
 >
 Add Favorite
 </ButtonAsLink>
 )}
 : {count}
 </React.Fragment>
 );
};
export default FavoriteNote;
Figure 16-3. A logged-in user will be able to create, read, update, and delete notes
198 | Chapter 16: Create, Read, Update, and Delete Operations
Conclusion
In this chapter we’ve turned our site into a fully functioning CRUD (create, read,
update, delete) application. We are now able to implement GraphQL queries and
mutations based on the state of a signed-in user. The ability to build user interfaces
that integrate CRUD user interactions will provide a solid foundation for building all
sorts of web applications. With this functionality, we’ve completed the MVP (mini‐
mum viable product) of our app. In the next chapter, we’ll deploy the application to a
web server.
Conclusion | 199

CHAPTER 17
Deploying a Web Application
When I first began doing web development professionally, a “deployment” meant
uploading files from my local machine to a web server through an FTP client. There
weren’t any build steps or pipelines, meaning that the raw files on my machine were
the same as those on my web server. If something went wrong, I would either franti‐
cally try to fix the issue or roll back the change by replacing it with copies of the old
files. This wild west approach worked OK at the time, but also led to a lot of site
downtime and unexpected issues.
In today’s world of web development, the needs of our local development environ‐
ment and our web servers are quite different. On my local machine, I want to see
instant changes when I update a file and have uncompressed files for debugging. On
my web server, I only expect to see changes when I deploy them and value small file
sizes. In this chapter, we’ll look at one way that we can deploy a static application to
the web.
Static Websites
A web browser parses HTML, CSS, and JavaScript to generate the web pages that we
interact with. Unlike frameworks such as Express, Rails, and Django, which generate
the markup for a page server-side at the time of the request, static websites are simply
a collection of HTML, CSS, and JavaScript stored on a server. This can range in com‐
plexity from a single HTML file containing markup to complicated frontend build
processes that compile templating languages, multiple JavaScript files, and CSS preprocessors. In the end, however, static websites are a collection of those three file
types.
201
Our application, Notedly, is a static web app. It contains some markup, CSS, and Java‐
Script. Our build tool, Parcel, compiles the components that we write into files usable
by the browser. In local development, we run a web server and these files are updated
on the fly using Parcel’s hot module replacement feature. If we look at our pack‐
age.json file, you’ll see that I’ve included two deploy scripts:
"scripts": {
 "deploy:src": "parcel build src/index.html --public-url ./",
 "deploy:final": "parcel build final/index.html --public-url ./"
}
To build the application, open your terminal application, cd into the root of your web
directory, which contains the project, and then run the build command:
# if you're not already in the web directory, be sure to cd into it
$ cd Projects/notedly/web
# build the files from the src directory
$ npm run deploy:src
If you’ve been following along with the book and developing your web application in
the src directory, running npm run deploy:src in the terminal, as just described, will
generate the built application from your code. If you would prefer to use the final ver‐
sion of the application that is bundled with the sample code, using npm run
deploy:final will build the code from the final application directory.
In the rest of the chapter, I’ll demonstrate one way to deploy a statically built applica‐
tion, but these files could be hosted anywhere that can serve HTML—from a web
hosting provider to a Raspberry Pi left running on your desk. While there are many
tangible benefits to the type of process we’ll be working through, your deploy could
be as simple as updating the .env file to point to the remote API, running the build
script, and uploading the files.
Server-Side Rendered React
Though we’re building our React application as a static web appli‐
cation, it is also possible to render JSX on the server. This techni‐
que is often referred to as “universal JavaScript” and can have many
benefits, including performance gains, client-side JavaScript fall‐
backs, and SEO improvements. Frameworks such as Next.js have
sought to simplify this setup. Though we’re not covering serverside rendered JavaScript applications in this book, I highly recom‐
mend exploring this approach once you’re comfortable with clientside JavaScript application development.
202 | Chapter 17: Deploying a Web Application
Our Deployment Pipeline
For our application’s deployment, we’ll make use of a simple pipeline, which will
allow us to automatically deploy changes to our codebase. For our pipeline we’ll be
using two services. The first will be our source code repository, GitHub. The second
will be our web host, Netlify. I’ve chosen Netlify for its extensive, but easy-to-use, fea‐
ture set for deployments as well as its focus on static and serverless applications.
Our goal is for any commit to the master branch of our application to be automati‐
cally deployed to our web host. We could visualize that process as shown in
Figure 17-1.
Figure 17-1. Our deployment process
Hosting Source Code with Git
The first step in our deployment process is to set up our source code repository. You
may have already done this, in which case feel free to skip ahead. As noted before
we’ll be using GitHub, but this process could be configured with other public Git
hosts, such as GitLab or Bitbucket.
GitHub Repositories
We’ll be creating a new GitHub repository, but if you prefer, you
can use the official code sample at https://github.com/javascript
everywhere/web by creating a fork to your GitHub account.
First, navigate to GitHub and create an account or sign in to your existing account.
Then click the New Repository button. Provide a name and click the Create Reposi‐
tory button (Figure 17-2).
Our Deployment Pipeline | 203
Figure 17-2. GitHub’s new repository page
Now, in your terminal application, navigate to your web application’s directory, set
the Git origin to the new GitHub repository, and push the code. Because we are
updating an existing Git repo, our instructions will differ slightly from GitHub’s:
# first navigate to the directory if you're not already there
cd Projects/notedly/web
# update the GitHub remote origin to match your repository
git remote set-url origin git://YOUR.GIT.URL
# push the code to the new GitHub repository
git push -u origin master
Now, if you navigate to https://github.com/<your_username>/<your_repo_name>, you
will see the source code of the application.
204 | Chapter 17: Deploying a Web Application
Deploy with Netlify
With our source code in a remote Git repository, we can now configure our web host,
Netlify, to build and deploy our code. First, go to netlify.com and register for an
account. Once you’ve created an account, click the “New site from Git” button. This
will walk you through setting up your site deployment:
1. Choose your Git provider by selecting GitHub, which will connect and authorize
your GitHub account.
2. Next, select the repository that contains the source code.
3. Finally, set up your build settings.
For our build settings, add the following (Figure 17-3):
1. Build command: npm run deploy:src (or npm run deploy:final, if deploying
the final example code).
2. Publish directory: dist.
3. Under “Advanced settings,” click “New variable” and add a variable name of
API_URI with a variable value of https://<your_api_name>.herokuapp.com/api
(this will be the URL of the API application, which we deployed to Heroku).
Once you’ve configured the application, click the “Deploy site” button. After a few
minutes your application will be running at the Netlify-supplied URL. Now, anytime
we push a change to our GitHub repo, our site will be automatically deployed.
Slow Initial Load
Our deployed web application will be loading data from our
deployed Heroku API. With Heroku’s free plan, application con‐
tainers sleep after one hour of inactivity. If you haven’t used your
API in a while, the initial data load will be slow while the container
spins back up.
Our Deployment Pipeline | 205
Figure 17-3. With Netlify we can configure our build process and environment variables
Conclusion
In this chapter we’ve deployed a static web application. To do this, we’ve used Netlify’s
deployment pipeline features to watch for changes to our Git repository, run our
build processes, and store environment variables. With this foundation, we have
everything we need to publicly release web applications.
206 | Chapter 17: Deploying a Web Application
CHAPTER 18
Desktop Applications with Electron
My introduction to personal computers was in a school lab full of Apple II machines.
Once a week, my classmates and I were ushered into the room, handed some floppy
disks, and given a rough set of instructions on how to load an application (typically
Oregon Trail). I don’t remember much from these sessions other than feeling com‐
pletely locked in to the little world I was now able to control. Personal computers have
come a long way since the mid-1980s, but we still rely on desktop applications to per‐
form many tasks.
On a typical day, I may access an email client, a text editor, a chat client, spreadsheet
software, a music streaming service, and several more desktop applications. Often‐
times, these have a web application equivalent, but the convenience and integration of
a desktop application can provide several user experience benefits. However, for years
the ability to create these applications felt out of reach. Thankfully, today we are able
to use web technologies to build fully featured desktop applications with a small
learning curve.
What We’re Building
Over the next few chapters we’ll build a desktop client for our social note application,
Notedly. Our goal is to use JavaScript and web technologies to develop a desktop
application that a user can download and install on their computer. For now, this
application will be a simple implementation that wraps our web application within a
desktop application shell. Developing our app in this way will allow us to quickly ship
a desktop app to those users who are interested, while providing us the flexibility to
introduce a custom application for desktop users at a later date.
207
How We’re Going To Build This
To build our application, we’ll be using Electron, an open source framework for
building cross-platform desktop applications with web technologies. It works by uti‐
lizing Node.js and Chrome’s underlying browser engine, Chromium. This means that
as developers we have access to the world of the browser, Node.js, and operating sys‐
tem–specific abilities, which are typically unavailable in a web environment. Electron
was originally developed by GitHub for the Atom text editor, but has since been used
as a platform for applications both big and small, including Slack, VS Code, Discord,
and WordPress Desktop.
Getting Started
Before we can start development, we need to make a copy of the project starter files to
our machine. The project’s source code contains all of the scripts and references to
third-party libraries that we will need to develop your application. To clone the code
to our local machine, open the terminal, navigate to the directory where you keep
your projects, and git clone the project repository. If you’ve worked through the
API and web chapters, you may also have already created a notedly directory to keep
the project code organized:
$ cd Projects
$ # type the `mkdir notedly` command if you don't yet have a notedly directory
$ cd notedly
$ git clone git@github.com:javascripteverywhere/desktop.git
$ cd desktop
$ npm install
Installing Third-Party Dependencies
By making a copy of the book’s starter code and running npm
install in the directory, you avoid having to again run npm
install for any of the individual third-party dependencies.
The code is structured as follows:
/src
This is the directory where you should perform your development as you follow
along with the book.
/solutions
This directory contains the solutions for each chapter. If you get stuck, these are
available for you to consult.
/final
This directory contains the final working project.
208 | Chapter 18: Desktop Applications with Electron
With our project directory created and dependencies installed, we are ready to begin
our development.
Our First Electron App
With our repository cloned to our machine, let’s develop our first Electron app. If you
look within your src directory, you’ll see that there are a few files. The index.html file
contains bare-bones HTML markup. For now, this file will serve as Electron’s “ren‐
derer process,” meaning that it will be the web page displayed as a window by our
Electron application.
<!DOCTYPE html>
<html>
 <head>
 <meta charset="UTF-8">
 <title>Notedly Desktop</title>
 </head>
 <body>
 <h1>Hello World!</h1>
 </body>
</html>
The index.js file is where we will set up our Electron application. In our application,
this file will contain what Electron calls the “main process,” which defines the applica‐
tion shell. The main process works by creating a BrowserWindow instance in Electron,
which serves as the application shell.
index.js Versus main.js
Though I’ve named the file index.js to follow the pattern found in
the rest of our sample applications, it is common in Electron devel‐
opment to name the “main process” file main.js.
Let’s set up our main process to display a browser window containing our HTML
page. First, import Electron’s app and browserWindow functionality in src/index.js:
const { app, BrowserWindow } = require('electron');
Now we can define our application’s browserWindow and define the file that our appli‐
cation will load. In src/index.js, add the following:
const { app, BrowserWindow } = require('electron');
// to avoid garbage collection, declare the window as a variable
let window;
// specify the details of the browser window
function createWindow() {
 window = new BrowserWindow({
Our First Electron App | 209
 width: 800,
 height: 600,
 webPreferences: {
 nodeIntegration: true
 }
 });
 // load the HTML file
 window.loadFile('index.html');
 // when the window is closed, reset the window object
 window.on('closed', () => {
 window = null;
 });
}
// when electron is ready, create the application window
app.on('ready', createWindow);
With this in place, we are ready to run our desktop application locally. In your termi‐
nal application, from your project’s directory, run the following:
$ npm start
This command will run electron src/index.js, launching a development environ‐
ment version of our application (see Figure 18-1).
Figure 18-1. Running the start command will launch our “Hello World” Electron
application
210 | Chapter 18: Desktop Applications with Electron
macOS Application Window Details
macOS handles application windows differently from Windows. When a user clicks
the “close window” button, the application window closes, but the application itself
does not quit. Clicking the application’s icon in the macOS dock will reopen the
application window. Electron allows us to implement this functionality. Add the fol‐
lowing to the bottom of the src/index.js file:
// quit when all windows are closed.
app.on('window-all-closed', () => {
 // On macOS only quit when a user explicitly quits the application
 if (process.platform !== 'darwin') {
 app.quit();
 }
});
app.on('activate', () => {
 // on macOS, re-create the window when the icon is clicked in the dock
 if (window === null) {
 createWindow();
 }
});
With this added, you can see these changes by quitting the application and rerunning
it with the npm start command. Now, if a user is accessing our application with
macOS, they will see the expected behavior when closing a window.
Developer Tools
Since Electron is based on the Chromium browser engine (the engine behind
Chrome, Microsoft Edge, Opera, and many other browsers), it also gives us access to
Chromium’s Developer Tools. This allows us to perform all of the same JavaScript
debugging that we might do in a browser environment. Let’s check if our application
is in development mode and, if so, automatically open dev tools when our app
launches.
To perform this check, we’ll use the electron-util library. This is a small collection
of utilities that will allow us to easily check system conditions and simplifies boiler‐
plate code for common Electron patterns. For now, we’ll be making use of the is
module, which will allow us to check if our application is in development mode.
At the top of our src/index.js file, import the module:
const { is } = require('electron-util');
macOS Application Window Details | 211
Now, in our application code, we can add the following on the line below
window.loadFile(index.html) where we load our HTML file, which will open the
development tools when the application is in a development environment
(Figure 18-2):
// if in development mode, open the browser dev tools
if (is.development) {
 window.webContents.openDevTools();
}
Figure 18-2. Now when we open our application during development, the browser dev
tools will automatically open
Electron Security Warning
You may notice that our Electron app currently displays a security
warning related to an insecure Content Security Policy (CSP). We
will address this warning in the next chapter.
With easy access to the browser dev tools, we are well prepared to develop a client
application.
212 | Chapter 18: Desktop Applications with Electron
The Electron API
One of the advantages of desktop development is that, through the Electron API, we
gain access to operating system-level features that are rightfully unavailable in a web
browser environment, including:
• Notifications
• Native file drag and drop
• macOS Dark Mode
• Custom menus
• Robust keyboard shortcuts
• System dialogs
• The application tray
• System information
As you can imagine, these options allow us to add some unique features and
improved user experiences to our desktop clients. We won’t be using these in our sim‐
ple sample application, but it is worth familiarizing yourself with them. Electron’s
documentation provides detailed examples of each of Electron’s APIs. Additionally,
the Electron team has created electron-api-demos, a fully functioning Electron
application that demonstrates many of the unique features of the Electron API.
Conclusion
In this chapter we’ve explored the basics of using Electron to build desktop applica‐
tions with web technologies. The Electron environment offers us, as developers, an
opportunity to provide a cross-platform desktop experience to users without learning
the intricacies of multiple programming languages and operating systems. Armed
with the simple setup we’ve explored in this chapter and knowledge of web develop‐
ment, we are well prepared to build robust desktop applications. In the next chapter,
we’ll look at how we can incorporate an existing web app into an Electron shell.
The Electron API | 213

CHAPTER 19
Integrating an Existing
Web Application with Electron
I tend to accumulate web browser tabs like a child at the beach collects shells. I don’t
necessarily set out to collect them, but by the end of the day, I have dozens of tabs
open across a few browser windows. I’m not proud of this, but I suspect that I’m not
alone. As a result, I use desktop versions of some of my most commonly used web
applications. Often, these applications offer no advantage over the web, but the con‐
venience of an independent app makes them easy to access, find, and switch to
throughout the day.
In this chapter, we’ll look at how we can take an existing web application and wrap it
in an Electron shell. Before proceeding, you will need a local copy of our example
API and web applications. If you haven’t been following along through the whole
book, visit Appendixes A and B to run these.
Integrating Our Web Application
In the previous chapter, we set up our Electron application to load an index.html file.
Alternately, we can load a specific URL. In our case, we’ll begin by loading the URL of
our locally running web application. First, be sure that your web application and API
are running locally. Then we can update our src/index.js file, first by updating the
nodeIntegration setting in the BrowserWindow to false. This will avoid the security
risks of a locally running node application accessing an external site.
webPreferences: {
 nodeIntegration: false
},
215
Now, replace the window.loadFile('index.html'); line with the following:
window.loadURL('http://localhost:1234');
Running the Web Application
A local instance of your web application will need to be running on
the 1234 port. If you’ve been following along with the book, run
npm start from the root of your web application’s directory to start
the development server.
This will instruct Electron to load a URL, rather than a file. Now if you run the app
with npm start, you’ll see it loaded in an Electron window, with some caveats.
Warnings and Errors
The Electron browser developer tools and our terminal currently display a large num‐
ber of warnings and errors. Let’s look at each of these (see Figure 19-1).
Figure 19-1. Our application is running, but displays a large number of errors and
warnings
216 | Chapter 19: Integrating an Existing Web Application with Electron
First, our terminal displays a large number of SyntaxError: Unexpected Token
errors. Additionally, our developer tools show several corresponding warnings stating
DevTools failed to parse SourceMap. These two errors are related to the way in
which Parcel generates source maps and Electron reads them. Unfortunately, with the
combination of technologies that we are using, there does not seem to be a reasonable
fix for this issue. Our best option is to disable JavaScript source maps. In the applica‐
tion window’s developer tools, click “Settings” and then uncheck “Enable JavaScript
source maps” (see Figure 19-2).
Figure 19-2. Disabling source maps will reduce the number of errors and warnings
Now, if you quit and restart the application you’ll no longer see the source map–
related issues. This does come with the tradeoff that debugging our client-side Java‐
Script within Electron may be more difficult, but thankfully we can still access this
feature and our application in our web browser.
The final two warnings are related to Electron’s security. We will address these before
bundling our application for production, but it’s worth exploring now what these
warnings are.
Integrating Our Web Application | 217
Electron Security Warning (Insecure Resources)
This warning notifies us that we are loading web resources over an http connec‐
tion. In production, we should always load resources over https to ensure privacy
and security. In development, loading our localhost over http is not a problem, as
we will be referencing our hosted website, which uses https in the bundled
application.
Electron Security Warning (Insecure Content-Security-Policy)
This warning informs us that we have not yet set a Content Security Policy (CSP).
A CSP allows us to specify which domains our application is permitted to load
resources from, greatly reducing the risk of a cross-site scripting (XSS) attack.
Again, this is not a concern during local development, but it’s important in pro‐
duction. We’ll be implementing a CSP later in the chapter.
With our errors addressed, we’re ready to set up our application’s configuration file.
Configuration
When developing locally, we want to be able to run the local version of our web appli‐
cation, but when bundling the app to be used by others, we want it to reference the
publicly available URL. We can set up a simple configuration file to handle this.
In our ./src directory, we will add a config.js file where we can store applicationspecific properties. I’ve included a config.example.js file, which you can easily copy
from the terminal:
cp src/config.example.js src/config.js
Now we can fill in the properties of our application:
const config = {
 LOCAL_WEB_URL: 'http://localhost:1234/',
 PRODUCTION_WEB_URL: 'https://YOUR_DEPLOYED_WEB_APP_URL',
 PRODUCTION_API_URL: 'https://YOUR_DEPLOYED_API_URL'
};
module.exports = config;
Why Not .env?
In our previous environments, we’ve used .env files to manage
environment-specific settings. In this instance, we’re using a Java‐
Script configuration file because of the way that Electron apps bun‐
dle their dependencies.
218 | Chapter 19: Integrating an Existing Web Application with Electron
Now in our Electron application’s main process, we can use the configuration file to
specify which URL we would like to load in development and production. In src/
index.js, first import the config.js file:
const config = require('./config');
Now, we can update the loadURL functionality to load different URLs for each
environment:
// load the URL
if (is.development) {
 window.loadURL(config.LOCAL_WEB_URL);
} else {
 window.loadURL(config.PRODUCTION_WEB_URL);
}
By using a configuration file, we can easily provide Electron with environmentspecific settings.
Content Security Policy
As stated earlier in the chapter, a CSP allows us to limit the domains that our applica‐
tion has permission to load resources from. This helps to limit potential XSS and data
injection attacks. In Electron, we can specify our CSP settings to help improve the
security of the application. To learn more about CSP for both your Electron and web
applications, I recommend the MDN article on the subject.
Electron provides a built-in API for CSP, but the electron-util library offers a sim‐
pler and cleaner syntax. At the top of our src/index.js file, update the electron-util
import statement to include setContentSecurityPolicy:
const { is, setContentSecurityPolicy } = require('electron-util');
Now we can set our CSP for the production version of the application:
// set the CSP in production mode
if (!is.development) {
 setContentSecurityPolicy(`
 default-src 'none';
 script-src 'self';
 img-src 'self' https://www.gravatar.com;
 style-src 'self' 'unsafe-inline';
 font-src 'self';
 connect-src 'self' ${config.PRODUCTION_API_URL};
 base-uri 'none';
 form-action 'none';
 frame-ancestors 'none';
 `);
}
Content Security Policy | 219
With our CSP written, we can check for errors using the CSP Evaluator tool. If we are
intentionally accessing resources at additional URLs, we could add them to our CSP
rule set.
Our final src/index.js file will read as follows:
const { app, BrowserWindow } = require('electron');
const { is, setContentSecurityPolicy } = require('electron-util');
const config = require('./config');
// to avoid garbage collection, declare the window as a variable
let window;
// specify the details of the browser window
function createWindow() {
 window = new BrowserWindow({
 width: 800,
 height: 600,
 webPreferences: {
 nodeIntegration: false
 }
 });
 // load the URL
 if (is.development) {
 window.loadURL(config.LOCAL_WEB_URL);
 } else {
 window.loadURL(config.PRODUCTION_WEB_URL);
 }
 // if in development mode, open the browser dev tools
 if (is.development) {
 window.webContents.openDevTools();
 }
 // set the CSP in production mode
 if (!is.development) {
 setContentSecurityPolicy(`
 default-src 'none';
 script-src 'self';
 img-src 'self' https://www.gravatar.com;
 style-src 'self' 'unsafe-inline';
 font-src 'self';
 connect-src 'self' ${config.PRODUCTION_API_URL};
 base-uri 'none';
 form-action 'none';
 frame-ancestors 'none';
 `);
 }
 // when the window is closed, dereference the window object
 window.on('closed', () => {
220 | Chapter 19: Integrating an Existing Web Application with Electron
 window = null;
 });
}
// when electron is ready, create the application window
app.on('ready', createWindow);
// quit when all windows are closed.
app.on('window-all-closed', () => {
 // On macOS only quit when a user explicitly quits the application
 if (process.platform !== 'darwin') {
 app.quit();
 }
});
app.on('activate', () => {
 // on macOS, re-create the window when the icon is clicked in the dock
 if (window === null) {
 createWindow();
 }
});
With this, we have a working implementation of our web application running within
an Electron shell (shown in Figure 19-3).
Figure 19-3. Our web application running within an Electron application shell
Content Security Policy | 221
Conclusion
In this chapter we integrated an existing web app into an Electron desktop applica‐
tion, which enables us to get a desktop application to market quickly. It’s worth not‐
ing that there are tradeoffs to this approach, however, as it offers limited desktopspecific benefits and requires an internet connection to access the full features of the
application. For those of us looking to get a desktop application to market soon, these
downsides may be worthwhile. In the next chapter, we’ll look at how we can build and
distribute an Electron app.
222 | Chapter 19: Integrating an Existing Web Application with Electron
CHAPTER 20
Electron Deployment
The first time I taught a programming course, I came up with the clever idea of intro‐
ducing the course topics through a text adventure game. Students would come into
the lab, sit down at a desk, and walk through a series of hilarious (to me) prompts and
instructions. This was met with mixed reactions, not because of the jokes (well,
maybe because of the jokes), but because students had not interacted with a “pro‐
gram” in this way. The students were accustomed to a GUI (graphic user interface),
and interacting with a program through text prompts felt wrong to many of them.
Presently, to run our application we need to type a prompt in our terminal applica‐
tion to start the Electron process. In this chapter, we’ll look at how we can bundle our
application for distribution. To achieve this, we’ll be using the popular Electron
Builder library, which will help us package and distribute our application to our
users.
Electron Builder
Electron Builder is a library designed to simplify the packaging and distribution of
Electron and Proton Native applications. While there are other packaging solutions,
Electron Builder simplifies a number of pain points associated with application distri‐
bution, including:
• Code signing
• Multiplatform distribution targets
• Autoupdates
• Distribution
223
It offers a great balance between flexibility and features. Additionally, though we
won’t be making use of them, there are several Electron Builder boilerplates for Web‐
pack, React, Vue, and Vanilla JavaScript.
Electron Builder Versus Electron Forge
Electron Forge is another popular library that offers many similar
features to Electron Builder. A primary advantage of Electron
Forge is that it is based on official Electron libraries, while Electron
Builder is an independent build tool. This means that users benefit
from the growth of the Electron ecosystem. The downside is that
Electron Forge is based on a much more rigid application setup.
For the purposes of this book, Electron Builder provides the right
balance of features and learning opportunities, but I encourage you
to take a close look at Electron Forge as well.
Configuring Electron Builder
All of the configuration of Electron Builder will take place in our application’s
package.json file. In that file we can see that electron-builder is already listed as a
development dependency. Within the package.json file we can include a key, called
"build", which will contain all of the instructions to Electron Builder for packaging
our app. To begin, we will include two fields:
appId
This is a unique identifier for our application. macOS calls the concept CFBundle
Identifier and Windows terms it the AppUserModelID. The standard is to use
the reverse DNS format. For example, if we run a company with a domain of
jseverywhere.io and build an application named Notedly, the ID would be io.jse
verywhere.notedly.
productName
This is the human-readable version of our product’s name, as the package.json
name field requires hyphenated or single-word names.
All together, our beginning build configuration will appear as follows:
"build": {
 "appId": "io.jseverywhere.notedly",
 "productName": "Notedly"
},
Electron Builder provides us with many configuration options, several of which we’ll
be exploring throughout this chapter. For the complete list, visit the Electron Builder
docs.
224 | Chapter 20: Electron Deployment
Build for Our Current Platform
With our minimal configuration in place, we can create our first application build. By
default, Electron Builder will produce a build for the system we are developing on.
For example, since I am writing this on a MacBook, my build will default to macOS.
Let’s first add two scripts to our package.json file, which will be responsible for appli‐
cation builds. First, a pack script will generate a package directory, without fully pack‐
aging the app. This can be useful for testing purposes. Second, a dist script will
package the application in distributable format, such as a macOS DMG, Windows
installer, or DEB package.
"scripts": {
 // add the pack and dist scripts to the existing npm scripts list
 "pack": "electron-builder --dir",
 "dist": "electron-builder"
}
With this change, you can run npm run dist in your terminal application, which will
package the application in the project’s dist/ directory. Navigating to the dist/ direc‐
tory, you can see that Electron Builder has packaged the application for distribution
for your operating system.
App Icons
One thing that you have likely noticed is that our application is using the default Elec‐
tron app icon. This is fine for local development, but for a production application we
will want to use our own branding. In our project’s /resources folder, I have included
some application icons for both macOS and Windows. To generate these icons from a
PNG file, I used the iConvert Icons application, which is available for both macOS
and Windows.
In our /resources folder you will see the following files:
• icon.icns, the macOS application icon
• icon.ico, the Windows application icon
• An icons directory with a series of different-sized .png files, used by Linux
Optionally, we could also include background images for the macOS DMG by adding
icons with the names of background.png and background@2x.png, for retina screens.
Now within our package.json file, we update the build object to specify the name of
the build resource directory:
"build": {
 "appId": "io.jseverywhere.notedly",
 "productName": "Notedly",
Build for Our Current Platform | 225
 "directories": {
 "buildResources": "resources"
 }
},
Now, when we build the application, Electron Builder will package it with our custom
application icons (see Figure 20-1).
Figure 20-1. Our custom application icon in the macOS dock
Building for Multiple Platforms
Currently, we’re only building our application for the operating system that matches
our development platform. One of the great advantages of Electron as a platform is
that it allows us to use the same code to target multiple platforms, by updating our
dist script. To achieve this, Electron Builder makes use of the free and open source
electron-build-service. We’ll be using the public instance of this service, but it is
possible to self-host it for organizations seeking additional security and privacy.
In our package.json update the dist script to:
"dist": "electron-builder -mwl"
This will result in a build that targets macOS, Windows, and Linux. From here we can
distribute our application by uploading it as a release to GitHub or anywhere that we
can distribute files, such as Amazon S3 or our web server.
Code Signing
Both macOS and Windows include the concept of code signing. Code signing is a
boost for the security and trust of users, as it helps signify the trustworthiness of the
app. I won’t be walking through the code-signing process, as it is operating system
specific and comes at a cost to developers. The Electron Builder documentation offers
a comprehensive article on code signing for various platforms. Additionally, the Elec‐
tron documentation offers several resources and links. If you are building a produc‐
tion application, I encourage you to further research the code-signing options for
macOS and Windows.
226 | Chapter 20: Electron Deployment
Conclusion
We’ve covered the tip of the iceberg for deploying an Electron application. In this
chapter we used Electron Builder to build our applications. We can then easily upload
and distribute them through any web host. Once we have outgrown these needs, we
can use Electron Builder to integrate builds into a continuous delivery pipeline; auto‐
matically push releases to GitHub, S3, or other distribution platforms; and integrate
automatic updates into the application. If you are interested in further exploring the
topics of Electron development and app distribution, these are fantastic next steps to
take.
Conclusion | 227

CHAPTER 21
Mobile Applications with React Native
One day in the late 1980s I was shopping with my parents when I spotted a small
portable television. It was a battery-powered square box, with an antenna, small
speaker, and a tiny black-and-white screen. I was blown away by the possibility of
watching Saturday morning cartoons in my backyard. Though I’d never own one, just
knowing that such a device existed made me feel like I was living in a science-fiction
future world. Little did I know that as an adult, I’d carry a device in my pocket that
would allow me to not only watch Masters of the Universe, but also to access infinite
information, listen to music, play games, take notes, take photos, summon a car, buy
things, check the weather, and complete an infinite number of other tasks.
In 2007 Steve Jobs introduced the iPhone, saying “every once in a while a revolution‐
ary product comes along that changes everything.” Sure, smartphones existed before
2007, but it wasn’t until the rise of the iPhone (and subsequent rise of Android) that
they were truly smart. In the intervening years, smartphone applications have evolved
past the initial “anything goes” gold rush phase to be something that users demand
quality from and have high expectations for. Today’s applications have high standards
of functionality, interaction, and design. To add to the challenge, modern mobile
application development is splintered across the Apple iOS and Android platforms,
each using a different programming language and toolchain.
You’ve probably already guessed it (it is in the book title), but JavaScript enables us as
developers to write cross-platform mobile applications. In this chapter I’ll introduce
the library that enables this, React Native, as well as the Expo tool chain. We’ll also
clone the sample project code, which we’ll be building upon over the next few
chapters.
229
What We’re Building
Over the next few chapters we’ll build a mobile client for our social note application,
Notedly. The goal is to use JavaScript and web technologies to develop an application
a user can install on their mobile device. We’ll be implementing a subset of features so
as to avoid too much repetition from the web application chapters. Specifically, our
application will:
• Work on both iOS and Android operating systems
• Load a note feed and individual user notes from our GraphQL API
• Use CSS and styled components for styling
• Perform standard and dynamic routing
These features will provide a solid overview of the core concepts of developing a
mobile application with React Native. Before we get started, let’s take a closer look at
the technologies we will be using.
How We’re Going To Build This
React Native is the core technology that we will be using to develop our application.
React Native allows us to write applications in JavaScript, using React, and render
them for the native mobile platform. This means that to users, there is no discernible
difference between a React Native application and one written in the platform’s pro‐
gramming language. This is React Native’s key advantage over other popular web
technology–based mobile frameworks, which traditionally wrapped a web view
within an application shell. React Native has been used to develop apps by Facebook,
Instagram, Bloomberg, Tesla, Skype, Walmart, Pinterest, and many others.
The second key piece of our application development workflow is Expo, a set of tools
and services that simplify React Native development through really useful features
such as on-device previews, application builds, and extending the core React Native
library. Before getting started with our development, I recommend that you do the
following:
1. Visit expo.io and create an Expo account.
2. Install the Expo command-line tools by typing npm install expo-cli --global
into your terminal application.
3. Sign in to your Expo account locally by typing expo login in your terminal
application.
4. Install the Expo Client application for your mobile device. Links to the Expo Cli‐
ent iOS and Android app can be found at expo.io/tools.
230 | Chapter 21: Mobile Applications with React Native
5. Sign in to your account in the Expo Client application.
Finally, we’ll again use Apollo Client to interact with data from our GraphQL API.
Apollo Client comprises a collection of open source tools for working with GraphQL.
Getting Started
Before we can start development, you’ll need to make a copy of the project starter
files to your machine. The project’s source code contains all of the scripts and refer‐
ences to third-party libraries that we will need to develop our application. To clone
the code to your local machine, open the terminal, navigate to the directory where
you keep your projects, and git clone the project repository. If you’ve worked
through the API, web, and/or desktop chapters, you may also have already created a
notedly directory to keep the project code organized:
$ cd Projects
$ # type the `mkdir notedly` command if you don't yet have a notedly directory
$ cd notedly
$ git clone git@github.com:javascripteverywhere/mobile.git
$ cd mobile
$ npm install
Installing Third-Party Dependencies
By making a copy of the book’s starter code and running npm
install in the directory, you avoid having to again run npm
install for any of the individual third-party dependencies.
The code is structured as follows:
/src
This is the directory where you should perform your development as you follow
along with the book.
/solutions
This directory contains the solutions for each chapter. If you get stuck, these are
available for you to consult.
/final
This directory contains the final working project.
The remaining files and project setup match the standard output of the expo-cli
React Native generator, which you can run by typing expo init in your terminal.
Getting Started | 231
App.js?
Because of the way that Expo’s build chain works, the App.js file in
the root of the project directory is typically the application’s point
of entry. To standardize our mobile project with the code found in
the rest of the book, the App.js file is used only as a reference to
a /src/Main.js file.
Now that we have the code on our local machines and our dependencies installed,
let’s run the app. To start the application, in your terminal application, type the
following:
$ npm start
This will open Expo’s “Metro Bundler” web application on a local port in our browser.
From here, you can launch a local device simulator by clicking one of the “Run on…”
links. You can also launch the application on any physical device with the Expo Client
by scanning the QR code (Figure 21-1).
Figure 21-1. Expo’s Metro Bundler after launching our application
232 | Chapter 21: Mobile Applications with React Native
Installing Device Simulators
To run an iOS device simulator, you will need to download and
install Xcode (macOS only). For Android, download Android Stu‐
dio and follow Expo’s guide on setting up a device simulator. (See
Figure 21-2 for a comparison.) However, if you’re just getting
started with mobile application development, I recommend start‐
ing with your own physical device.
Figure 21-2. Our application running side by side on iOS and Android device simulators
If you’ve signed in to Expo from your computer’s terminal application as well as
within the Expo Client application on your mobile device, you can open the
application simply by opening the Expo Client application and clicking the Projects
tab (Figure 21-3).
Getting Started | 233
Figure 21-3. With Expo Client, we can preview our application on a physical device
With the code cloned to your local machine and the ability to preview the application
with Expo Client, you have everything in place to develop a mobile application.
Conclusion
This chapter introduced React Native and Expo. We cloned the sample project code,
ran it locally, and previewed it on a physical device or simulator. React Native
empowers web and JavaScript developers to build fully featured native mobile appli‐
cations, using the skills and tools they are familiar with. Expo simplifies the toolchain
and lowers the barrier to entry for native mobile development. With these two tools,
novices can easily get started with mobile development and web-savvy teams can
quickly introduce a mobile application development skillset. In the next chapter we’ll
take a closer look at React Native’s capabilities and introduce both routes and styles to
our app.
234 | Chapter 21: Mobile Applications with React Native
CHAPTER 22
Mobile Application Shell
My wife is a photographer, which means that much of her life is based around com‐
posing images within a rectangular frame. In photography there are many variables—
subject, light, angle—but the proportions of the image remain consistent. With that
limitation, incredible things happen, shaping the way that we see and remember the
world around us. Mobile application development presents a similar opportunity.
Within the constraints of a small rectangular screen, we can build incredibly powerful
applications with immersive user experiences.
In this chapter, we’ll begin to build out a shell for our application. To do this, we’ll
first take a closer look at some of the key building blocks of React Native components.
From there we’ll look at how to apply styles to our application, both with React Nati‐
ve’s built-in style support as well as with our CSS-in-JS library of choice, Styled Com‐
ponents. Once we’ve covered how to apply styles, we’ll take a look at how to integrate
routing into our application. Finally, we’ll explore how to easily enhance our app
interfaces with icons.
React Native Building Blocks
Let’s begin by taking a look at the basic building blocks of a React Native application.
You may have already guessed that a React Native application consists of React com‐
ponents written in JSX. But without an HTML page’s DOM (document object
model), what exactly goes within those components? We can start by looking at the
“Hello World” component at src/Main.js. For now, I’ve removed the styles:
import React from 'react';
import { Text, View } from 'react-native';
const Main = () => {
 return (
 <View>
235
 <Text>Hello world!</Text>
 </View>
 );
};
export default Main;
In this markup there are two notable JSX tags: <View> and <Text>. If you’re coming
from a web background, a <View> tag serves much of the same purpose as a <div>
tag. It is a container for the content of our applications. On their own they don’t do
much, but they contain all of our app’s content, can be nested within one another, and
are used to apply styles. Each of our components will be contained within a <View>.
In React Native, you can use a <View> anywhere that you might use a <div> or <span>
tag on the web. The <Text> tag, unsurprisingly, is used to contain any text in our app.
Unlike on the web, however, this single tag is used for all text.
As you can imagine, we can also add images to our applications, by using the <Image>
JSX element. Let’s update our src/Main.js file to include an image. To do so, we import
the Image component from React Native and use an <Image> tag with a src attribute
(see Figure 22-1):
import React from 'react';
import { Text, View, Image } from 'react-native';
const Main = () => {
 return (
 <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
 <Text>Hello world!</Text>
 <Image source={require('../assets/images/hello-world.jpg')} />
 </View>
 );
};
export default Main;
The preceding code renders some text and image within a view. You may notice that
our <View> and <Image> JSX tags are passed properties that allow us to control spe‐
cific behavior (in this case the style of the view and the source of the image). Passing
properties to an element allows us to extend the element with all sorts of additional
features. React Native’s API documentation catalogs the properties that are made
available to each element.
236 | Chapter 22: Mobile Application Shell
Figure 22-1. Using the <Image> tag we can add images to our application (photo by
Windell Oskay)
Our app doesn’t do much yet, but in the next section we’ll explore how we can
improve the look and feel using React Native’s built-in style support and Styled
Components.
Style and Styled Components
As app developers and designers, we want to be able to style our applications to have
a precise look, feel, and user experience. There are a number of UI component libra‐
ries, such as NativeBase or React Native Elements, which offer a wide range of prede‐
fined and often customizable components. These are well worth a look, but for our
purposes let’s explore how we might compose our own styles and application layouts.
Style and Styled Components | 237
As we’ve already seen, React Native provides a style property that allows us to apply
custom styles to any JSX element in our application. The style names and values
match those of CSS, except that the names are written in camelCase, such as line
Height and backgroundColor. Let’s update our /src/Main.js file to include some styles
for the <Text> element (see Figure 22-2):
const Main = () => {
 return (
 <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
 <Text style={{ color: '#0077cc', fontSize: 48, fontWeight: 'bold' }}>
 Hello world!
 </Text>
 <Image source={require('../assets/images/hello-world.jpg')} />
 </View>
 );
};
Figure 22-2. Using styles we can adjust the look of our <Text> element
238 | Chapter 22: Mobile Application Shell
You may be thinking, rightfully, that applying styles at the element level would
quickly become an unmaintainable mess. We can use React Native’s StyleSheet
library to help organize and reuse our styles.
First, we need to add StyleSheet to our list of imports (Figure 22-3):
import { Text, View, Image, StyleSheet } from 'react-native';
Now we can abstract our styles:
const Main = () => {
 return (
 <View style={styles.container}>
 <Text style={styles.h1}>Hello world!</Text>
 <Text style={styles.paragraph}>This is my app</Text>
 <Image source={require('../assets/images/hello-world.jpg')} />
 </View>
 );
};
const styles = StyleSheet.create({
 container: {
 flex: 1,
 justifyContent: 'center'
 },
 h1: {
 fontSize: 48,
 fontWeight: 'bold'
 },
 paragraph: {
 marginTop: 24,
 marginBottom: 24,
 fontSize: 18
 }
});
Flexbox
React Native uses the CSS flexbox algorithm to define layout styles.
We won’t be covering flexbox in depth, but React Native offers doc‐
umentation that clearly explains flexbox and its use cases for
arranging elements on the screen.
Style and Styled Components | 239
Figure 22-3. By using stylesheets we can scale the styles of our application
Styled Components
While React Native’s built-in style properties and StyleSheets may offer everything
that we need out of the box, they are far from our only options for styling our appli‐
cations. We can also make use of popular web CSS-in-JS solutions, such as Styled
Components and Emotion. These offer, in my opinion, a cleaner syntax, are more
closely aligned to CSS, and limit the amount of context switching needed between the
web and mobile application codebases. Using these web-enabled CSS-in-JS libraries
also creates the opportunity to share styles or components across platforms.
For our purposes, let’s look at how we can adapt the previous example to use the
Styled Components library. First, in src/Main.js we will import the native version of
the library:
import styled from 'styled-components/native'
240 | Chapter 22: Mobile Application Shell
From here we can migrate our styles to the Styled Components syntax. If you fol‐
lowed along in Chapter 13, this syntax should look very familiar. The final code of
our src/Main.js file becomes:
import React from 'react';
import { Text, View, Image } from 'react-native';
import styled from 'styled-components/native';
const StyledView = styled.View`
 flex: 1;
 justify-content: center;
`;
const H1 = styled.Text`
 font-size: 48px;
 font-weight: bold;
`;
const P = styled.Text`
 margin: 24px 0;
 font-size: 18px;
`;
const Main = () => {
 return (
 <StyledView>
 <H1>Hello world!</H1>
 <P>This is my app.</P>
 <Image source={require('../assets/images/hello-world.jpg')} />
 </StyledView>
 );
};
export default Main;
Styled Components Capitalization
In the Styled Components library, the element names must always
be capitalized.
With this we’re now able to apply custom styling to our applications, with the option
of using React Native’s built-in style system or Styled Components library.
Style and Styled Components | 241
Routing
On the web we can use HTML anchor links to link from one HTML document to any
other, including those on our own site. For JavaScript-driven applications we use
routing to link together JavaScript-rendered templates. What about native mobile
applications? For these, we will route our users between screens. In this section we’ll
explore two common routing types: tab-based navigation and stack navigation.
Tabbed Routing with React Navigation
To perform our routing we’ll make use of the React Navigation library, which is the
routing solution recommended by both the React Native and Expo teams. Most
importantly, it makes it very straightforward to implement common routing patterns
with a platform-specific look and feel.
To get started, let’s first create a new directory within our src directory named screens.
Within the screens directory, let’s create three new files, each containing a very basic
React component.
Add the following in src/screens/favorites.js:
import React from 'react';
import { Text, View } from 'react-native';
const Favorites = () => {
 return (
 <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
 <Text>Favorites</Text>
 </View>
 );
};
export default Favorites;
Add this in src/screens/feed.js:
import React from 'react';
import { Text, View } from 'react-native';
const Feed = () => {
 return (
 <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
 <Text>Feed</Text>
 </View>
 );
};
export default Feed;
Finally, add this in src/screens/mynotes.js:
242 | Chapter 22: Mobile Application Shell
import React from 'react';
import { Text, View } from 'react-native';
const MyNotes = () => {
 return (
 <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
 <Text>My Notes</Text>
 </View>
 );
};
export default MyNotes;
We can then create a new file at src/screens/index.js to be used as the root of our appli‐
cation’s routing. We’ll begin by importing our initial react and react-navigation
dependencies:
import React from 'react';
import { createAppContainer } from 'react-navigation';
import { createBottomTabNavigator } from 'react-navigation-tabs';
// import screen components
import Feed from './feed';
import Favorites from './favorites';
import MyNotes from './mynotes';
With these dependencies imported, we can create a tab navigator between these three
screens using React Navigation’s createBottomTabNavigator to define which React
component screens should appear in our navigation:
const TabNavigator = createBottomTabNavigator({
 FeedScreen: {
 screen: Feed,
 navigationOptions: {
 tabBarLabel: 'Feed',
 }
 },
 MyNoteScreen: {
 screen: MyNotes,
 navigationOptions: {
 tabBarLabel: 'My Notes',
 }
 },
 FavoriteScreen: {
 screen: Favorites,
 navigationOptions: {
 tabBarLabel: 'Favorites',
 }
 }
});
Routing | 243
// create the app container
export default createAppContainer(TabNavigator);
Finally, let’s update our src/Main.js file to do nothing but import our router. It should
now be simplified to read as follows:
import React from 'react';
import Screens from './screens';
const Main = () => {
 return <Screens />;
};
export default Main;
Be sure that your application is running by entering the npm start command in your
terminal. You should now see tab navigation at the bottom of the screen, where tap‐
ping a tab will route you to the appropriate screen (Figure 22-4).
Figure 22-4. We can now navigate between screens with tabbed navigation
244 | Chapter 22: Mobile Application Shell
Stack Navigation
A second kind of routing type is stack navigation, in which screens are conceptually
“stacked” on top of one another, allowing users to navigate deeper into and backward
through the stack. Consider a news application where a user views a feed of articles.
The user can tap a news article title and navigate deeper in the stack to the article
contents. They can then click a back button, navigating back to the article feed, or
perhaps a different article title, navigating deeper into the stack.
In our application we want users to be able to navigate from a feed of notes to the
notes themselves and back. Let’s look at how we might implement a stack navigation
for each of our screens.
First, let’s create a new NoteScreen component, which will contain the second screen
in our stack. Create a new file at src/screens/note.js with a minimal React Native
component:
import React from 'react';
import { Text, View } from 'react-native';
const NoteScreen = () => {
 return (
 <View style={{ padding: 10 }}>
 <Text>This is a note!</Text>
 </View>
 );
};
export default NoteScreen;
Next, we will make the changes to our router to enable stacked navigation for the
NoteScreen component. To do so, we’ll import createStackNavigator from reactnavigation-stack as well as our new note.js component. In src/screens/index.js
update the imports to look as follows:
import React from 'react';
import { Text, View, ScrollView, Button } from 'react-native';
import { createAppContainer } from 'react-navigation';
import { createBottomTabNavigator } from 'react-navigation-tabs';
// add import for createStackNavigator
import { createStackNavigator } from 'react-navigation-stack';
// import screen components, including note.js
import Feed from './feed';
import Favorites from './favorites';
import MyNotes from './mynotes';
import NoteScreen from './note';
With our libraries and files imported, we can implement the stack navigation capabil‐
ity. In our router file we must tell React Navigation which screens are “stackable.” For
Routing | 245
each of our tabbed routes, we’ll want a user to be able to navigate to a Note screen. Go
ahead and define those stacks as follows:
const FeedStack = createStackNavigator({
 Feed: Feed,
 Note: NoteScreen
});
const MyStack = createStackNavigator({
 MyNotes: MyNotes,
 Note: NoteScreen
});
const FavStack = createStackNavigator({
 Favorites: Favorites,
 Note: NoteScreen
});
Now we can update our TabNavigator to reference the stack, rather than an individ‐
ual screen. To do this, update the screen property in each TabNavigator object:
const TabNavigator = createBottomTabNavigator({
 FeedScreen: {
 screen: FeedStack,
 navigationOptions: {
 tabBarLabel: 'Feed'
 }
 },
 MyNoteScreen: {
 screen: MyStack,
 navigationOptions: {
 tabBarLabel: 'My Notes'
 }
 },
 FavoriteScreen: {
 screen: FavStack,
 navigationOptions: {
 tabBarLabel: 'Favorites'
 }
 }
});
All together, our src/screens/index.js file should appear as follows:
import React from 'react';
import { Text, View, ScrollView, Button } from 'react-native';
import { createAppContainer } from 'react-navigation';
import { createBottomTabNavigator } from 'react-navigation-tabs';
import { createStackNavigator } from 'react-navigation-stack';
// import screen components
import Feed from './feed';
import Favorites from './favorites';
246 | Chapter 22: Mobile Application Shell
import MyNotes from './mynotes';
import NoteScreen from './note';
// navigation stack
const FeedStack = createStackNavigator({
 Feed: Feed,
 Note: NoteScreen
});
const MyStack = createStackNavigator({
 MyNotes: MyNotes,
 Note: NoteScreen
});
const FavStack = createStackNavigator({
 Favorites: Favorites,
 Note: NoteScreen
});
// navigation tabs
const TabNavigator = createBottomTabNavigator({
 FeedScreen: {
 screen: FeedStack,
 navigationOptions: {
 tabBarLabel: 'Feed'
 }
 },
 MyNoteScreen: {
 screen: MyStack,
 navigationOptions: {
 tabBarLabel: 'My Notes'
 }
 },
 FavoriteScreen: {
 screen: FavStack,
 navigationOptions: {
 tabBarLabel: 'Favorites'
 }
 }
});
// create the app container
export default createAppContainer(TabNavigator);
If we open our application in a simulator or the Expo app on our device, we should
see no discernible difference. This is because we have yet to add a link to our stacked
navigation. Let’s update our src/screens/feed.js component to include a stacked naviga‐
tion link.
Routing | 247
To do so, first include the Button dependency from React Native:
import { Text, View, Button } from 'react-native';
Now we can include a button that, on press, will navigate to the content of our note.js
component. We will pass the component props, which will contain the navigation
information, and add a <Button> that will include the title and onPress props:
const Feed = props => {
 return (
 <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
 <Text>Note Feed</Text>
 <Button
 title="Keep reading"
 onPress={() => props.navigation.navigate('Note')}
 />
 </View>
 );
};
With this, we should be able to navigate between our screens. Click the button from
the Feed screen to navigate to the Note screen, and click the arrow to return
(Figure 22-5).
248 | Chapter 22: Mobile Application Shell
Figure 22-5. Clicking the button link will navigate to the new screen, while clicking the
arrow will return the user to the previous screen
Adding Screen Titles
Adding the stack navigator automatically adds a title bar to the top of our app. We
can style or even remove that top bar. For now let’s add a title to each screen at the top
of our stack. To do this, we will set the component navigationOptions outside of the
component itself. In src/screens/feed.js:
import React from 'react';
import { Text, View, Button } from 'react-native';
const Feed = props => {
// component code
};
Feed.navigationOptions = {
Routing | 249
 title: 'Feed'
};
export default Feed;
We can repeat this process for our other screen components.
In src/screens/favorites.js:
Favorites.navigationOptions = {
 title: 'Favorites'
};
In src/screens/mynotes.js:
MyNotes.navigationOptions = {
 title: 'My Notes'
};
Now each of our screens will include a title in the top navigation bar (Figure 22-6).
250 | Chapter 22: Mobile Application Shell
Figure 22-6. Setting the title in navigationOptions will add it to the top nav bar
Icons
Right now our navigation is functionally complete, but lacks a visual component to
make it easier for users. Thankfully, Expo makes it incredibly easy to include icons in
our application. We can search all of the icons that Expo makes available by visiting
expo.github.io/vector-icons. A number of icon sets are included, such as Ant Design,
Ionicons, Font Awesome, Entypo, Foundation, Material Icons, and Material Commu‐
nity Icons. This provides us with a tremendous amount of variety out of the box.
Let’s add some icons to our tabbed navigation. First, we must import the icon sets that
we’d like to use. In our case, we’ll make use of the Material Community Icons by
adding the following in src/screens/index.js:
import { MaterialCommunityIcons } from '@expo/vector-icons';
Icons | 251
Now anywhere we want to use an icon in a component, we can include it as JSX,
including setting properties such as size and color:
<MaterialCommunityIcons name="star" size={24} color={'blue'} />
We’ll be adding our icons to our tab navigation. React Navigation includes a property
called the tabBarIcon property, which allows us to set the icon. We can pass this as a
function, which enables us to set the tintColor, so that active tab icons have a differ‐
ent color than those that are inactive:
const TabNavigator = createBottomTabNavigator({
 FeedScreen: {
 screen: FeedStack,
 navigationOptions: {
 tabBarLabel: 'Feed',
 tabBarIcon: ({ tintColor }) => (
 <MaterialCommunityIcons name="home" size={24} color={tintColor} />
 )
 }
 },
 MyNoteScreen: {
 screen: MyStack,
 navigationOptions: {
 tabBarLabel: 'My Notes',
 tabBarIcon: ({ tintColor }) => (
 <MaterialCommunityIcons name="notebook" size={24} color={tintColor} />
 )
 }
 },
 FavoriteScreen: {
 screen: FavStack,
 navigationOptions: {
 tabBarLabel: 'Favorites',
 tabBarIcon: ({ tintColor }) => (
 <MaterialCommunityIcons name="star" size={24} color={tintColor} />
 )
 }
 }
});
With this, our tabbed navigation will display icons (Figure 22-7).
252 | Chapter 22: Mobile Application Shell
Figure 22-7. Our application’s navigation now includes icons
Conclusion
In this chapter we covered how to build the basic components of a React Native appli‐
cation. You’re now able to create components, add styles to them, and navigate
between them. Hopefully with this basic setup, you can see the incredible potential of
React Native. With minimal new technologies, you are already able to build the
beginnings of an impressive and professional mobile application. In the next chapter,
we’ll use GraphQL to include data from our API within the application.
Conclusion | 253

CHAPTER 23
GraphQL and React Native
At the Andy Warhol Museum in Pittsburgh, Pennsylvania, there is a permanent
installation called “Silver Clouds.” The installation is a sparse room with a dozen or so
rectangular foil balloons, each filled with a mix of helium and regular air. The result is
that the balloons will stay suspended longer than balloons filled with atmospheric air,
but don’t float to the ceiling like helium balloons. Patrons of the museum walk
through the museum, playfully batting the balloons to keep them afloat.
Currently, our application is much like the room of “clouds.” It’s enjoyable to playfully
click the icons and navigate around the app shell, but in the end it is a mostly empty
room (no offense to Mr. Warhol). In this chapter, we’ll begin to fill our application by
first exploring how we can display content with React Native’s list views. We’ll then
make use of Apollo Client to connect to our data API. Once we’ve connected, we’ll
write GraphQL queries, which will display data on an app screen.
Running Our API Locally
The development of our mobile application will require access to a
local instance of our API. If you’ve been following along with the
book, you may already have the Notedly API and its database up
and running on your machine. If not, I’ve added instructions in the
book’s Appendix A on how to get a copy of the API up and running
along with some sample data. If you already have the API running,
but would like some additional data to work with, run npm run
seed from the root of the API project directory.
255
Creating List and Scrollable Content Views
Lists are everywhere. In life we keep to-do lists, grocery lists, and guest lists. In appli‐
cations, lists are one of the most common UI patterns: lists of social media posts, lists
of articles, lists of songs, lists of movies, and so on. The list (see what I did there?)
goes on and on. It may come as no surprise, then, that React Native makes creating
scrollable lists of content a straightforward process.
The two types of lists on React Native are FlatList and SectionList. A FlatList is
useful for a large number of items in a single scrollable list. React Native does some
helpful things behind the scenes, such as rendering only the items that are initially
viewable to improve performance. A SectionList is much like a FlatList, except
that it allows groups of list items to have a header. Think of contacts in a contact list,
often grouped alphabetically beneath an alphanumeric header.
For our purposes, we’ll be using a FlatList to display a list of notes, through which a
user can scroll and tap a preview to read the full note. To achieve this, let’s create a
new component named NoteFeed, which we can use to display the list of notes. For
now we’ll use some stand-in data, but we’ll connect it to our API soon.
To begin, let’s create a new component at src/components/NoteFeed.js. We’ll start by
importing our dependencies and adding an array of temporary data.
import React from 'react';
import { FlatList, View, Text } from 'react-native';
import styled from 'styled-components/native';
// our dummy data
const notes = [
 { id: 0, content: 'Giant Steps' },
 { id: 1, content: 'Tomorrow Is The Question' },
 { id: 2, content: 'Tonight At Noon' },
 { id: 3, content: 'Out To Lunch' },
 { id: 4, content: 'Green Street' },
 { id: 5, content: 'In A Silent Way' },
 { id: 6, content: 'Lanquidity' },
 { id: 7, content: 'Nuff Said' },
 { id: 8, content: 'Nova' },
 { id: 9, content: 'The Awakening' }
];
const NoteFeed = () => {
 // our component code will go here
};
export default NoteFeed;
256 | Chapter 23: GraphQL and React Native
Now we can write our component code, which will contain a FlatList:
const NoteFeed = props => {
 return (
 <View>
 <FlatList
 data={notes}
 keyExtractor={({ id }) => id.toString()}
 renderItem={({ item }) => <Text>{item.content}</Text>}
 />
 </View>
 );
};
In the preceding code you can see that FlatList receives three properties that sim‐
plify the process of iterating over the data:
data
This property points to the array of data that the list will contain.
keyExtractor
Each item in the list must have a unique key value. We are using keyExtractor to
use the unique id value as the key.
renderItem
This property defines what should be rendered within the list. For now we are
passing an individual item from our notes array and displaying it as Text.
We can view our list by updating our src/screens/feed.js component to display the feed:
import React from 'react';
// import NoteFeed
import NoteFeed from '../components/NoteFeed';
const Feed = props => {
 return <NoteFeed />;
};
Feed.navigationOptions = {
 title: 'Feed'
};
export default Feed;
Let’s move back to our src/components/NoteFeed.js file and update renderItem to add
some spacing between list items using a styled component:
// FeedView styled component definition
const FeedView = styled.View`
 height: 100;
 overflow: hidden;
Creating List and Scrollable Content Views | 257
 margin-bottom: 10px;
`;
const NoteFeed = props => {
 return (
 <View>
 <FlatList
 data={notes}
 keyExtractor={({ id }) => id.toString()}
 renderItem={({ item }) => (
 <FeedView>
 <Text>{item.content}</Text>
 </FeedView>
 )}
 />
 </View>
 );
};
If you preview our app, you’ll see a scrollable list of data. Finally, we can add a separa‐
tor between our list items. Rather than adding a bottom border via CSS, React Native
enables us to pass an ItemSeparatorComponent property to our FlatList. This gives
us fine-grained control to place any type of component as a separator between list ele‐
ments. It also avoids placing a separator in unwanted places, such as after the last item
in the list. For our purposes we’ll add a simple border, created as a styled component
View:
// FeedView styled component definition
const FeedView = styled.View`
 height: 100;
 overflow: hidden;
 margin-bottom: 10px;
`;
// add a Separator styled component
const Separator = styled.View`
 height: 1;
 width: 100%;
 background-color: #ced0ce;
`;
const NoteFeed = props => {
 return (
 <View>
 <FlatList
 data={notes}
 keyExtractor={({ id }) => id.toString()}
 ItemSeparatorComponent={() => <Separator />}
 renderItem={({ item }) => (
 <FeedView>
 <Text>{item.content}</Text>
258 | Chapter 23: GraphQL and React Native
 </FeedView>
 )}
 />
 </View>
 );
};
Rather than rendering and styling our note’s content directly in our FlatList, let’s
isolate it within its own component. To do so we’ll introduce a new type of view called
ScrollView. The functionality of a ScrollView is precisely what you’d expect: rather
than conforming to the size of the screen, a ScrollView will overflow the content,
allowing the user to scroll.
Let’s create a new component at src/components/Note.js:
import React from 'react';
import { Text, ScrollView } from 'react-native';
import styled from 'styled-components/native';
const NoteView = styled.ScrollView`
 padding: 10px;
`;
const Note = props => {
 return (
 <NoteView>
 <Text>{props.note.content}</Text>
 </NoteView>
 );
};
export default Note;
Finally, we’ll update our src/components/NoteFeed.js component to make use of our
new Note component by importing it and using it within our FeedView. The final
component code will be as follows (Figure 23-1):
import React from 'react';
import { FlatList, View, Text } from 'react-native';
import styled from 'styled-components/native';
import Note from './Note';
// our dummy data
const notes = [
 { id: 0, content: 'Giant Steps' },
 { id: 1, content: 'Tomorrow Is The Question' },
 { id: 2, content: 'Tonight At Noon' },
 { id: 3, content: 'Out To Lunch' },
 { id: 4, content: 'Green Street' },
 { id: 5, content: 'In A Silent Way' },
 { id: 6, content: 'Lanquidity' },
Creating List and Scrollable Content Views | 259
 { id: 7, content: 'Nuff Said' },
 { id: 8, content: 'Nova' },
 { id: 9, content: 'The Awakening' }
];
// FeedView styled-component definition
const FeedView = styled.View`
 height: 100;
 overflow: hidden;
 margin-bottom: 10px;
`;
const Separator = styled.View`
 height: 1;
 width: 100%;
 background-color: #ced0ce;
`;
const NoteFeed = props => {
 return (
 <View>
 <FlatList
 data={notes}
 keyExtractor={({ id }) => id.toString()}
 ItemSeparatorComponent={() => <Separator />}
 renderItem={({ item }) => (
 <FeedView>
 <Note note={item} />
 </FeedView>
 )}
 />
 </View>
 );
};
export default NoteFeed;
260 | Chapter 23: GraphQL and React Native
Figure 23-1. Using FlatList we can display a list of data
With this we’ve laid out a simple FlatList. Now let’s make it possible to route from a
list item to an individual route.
Making a List Routable
A very common pattern in mobile applications is to tap an item in a list to view more
information or expanded functionality. If you recall from the previous chapter, our
feed screen sits atop the note screen in our navigation stack. In React Native we can
use the TouchableOpacity as a wrapper for making any view respond to user touches.
This means that we can wrap the content of our FeedView in TouchableOpacity and
route the user on press, the same way that we previously did with a button. Let’s go
ahead and update our src/components/NoteFeed.js component to do just that.
Creating List and Scrollable Content Views | 261
First, we must update our react-native import to include TouchableOpacity in src/
components/NoteFeed.js:
import { FlatList, View, TouchableOpacity } from 'react-native';
Next, we update our component to use TouchableOpacity:
const NoteFeed = props => {
 return (
 <View>
 <FlatList
 data={notes}
 keyExtractor={({ id }) => id.toString()}
 ItemSeparatorComponent={() => <Separator />}
 renderItem={({ item }) => (
 <TouchableOpacity
 onPress={() =>
 props.navigation.navigate('Note', {
 id: item.id
 })
 }
 >
 <FeedView>
 <Note note={item} />
 </FeedView>
 </TouchableOpacity>
 )}
 />
 </View>
 );
};
We’ll also need to update our feed.js screen component to pass the navigation proper‐
ties to the feed. In src/screens/feed.js:
const Feed = props => {
 return <NoteFeed navigation={props.navigation} />;
};
With this, we can easily navigate to our generic note screen. Let’s customize that
screen so that it displays the ID of the note. You may have noticed that in our Note
Feed component navigation, we’re passing an id property. In screens/note.js we can
read the value of that property:
import React from 'react';
import { Text, View } from 'react-native';
const NoteScreen = props => {
 const id = props.navigation.getParam('id');
 return (
 <View style={{ padding: 10 }}>
 <Text>This is note {id}</Text>
 </View>
262 | Chapter 23: GraphQL and React Native
 );
};
export default NoteScreen;
Now, we’re able to navigate from our list view to a detail page. Next, let’s take a look at
how we can integrate data from our API into our application.
GraphQL with Apollo Client
At this point we are ready to read and display data within our application. We’ll be
accessing the GraphQL API that we created in the first portion of the book. Conven‐
iently, we’ll be making use of Apollo Client, the same GraphQL client library from the
web portion of the book. Apollo Client offers a number of helpful features to simplify
working with GraphQL within JavaScript UI applications. Apollo’s client features
include fetching data from a remote API, local caching, GraphQL syntax handling,
local state management, and more.
To get started we’ll first need to set up our configuration file. We’ll store our environ‐
ment variables in a file called config.js. There are several ways to manage environment
and configuration variables in React Native, but I’ve found this style of configuration
file to be the most straightforward and effective. To get started, I’ve included a configexample.js file, which you can copy and edit with our app values. In your terminal
application, from the root of the project directory:
$ cp config.example.js config.js
From here we can update any dev or prod environment variables. In our case that will
only be a production API_URI value:
// set environment variables
const ENV = {
 dev: {
 API_URI: `http://${localhost}:4000/api`
 },
 prod: {
 // update the API_URI value with your publicly deployed API address
 API_URI: 'https://your-api-uri/api'
 }
};
We will now be able to access these two values, based on Expo’s environment, using
the getEnvVars function. We won’t dive into the rest of the configuration file, but it is
well commented if you are interested in exploring this setup further.
From here we can connect our client to our API. In our src/Main.js file we will set up
Apollo by using the Apollo Client library. If you worked through the web portion of
the book, this will look very familiar:
GraphQL with Apollo Client | 263
import React from 'react';
import Screens from './screens';
// import the Apollo libraries
import { ApolloClient, ApolloProvider, InMemoryCache } from '@apollo/client';
// import environment configuration
import getEnvVars from '../config';
const { API_URI } = getEnvVars();
// configure our API URI & cache
const uri = API_URI;
const cache = new InMemoryCache();
// configure Apollo Client
const client = new ApolloClient({
 uri,
 cache
});
const Main = () => {
 // wrap our app in the ApolloProvider higher-order component
 return (
 <ApolloProvider client={client}>
 <Screens />
 </ApolloProvider>
 );
};
export default Main;
With this, there won’t be a visible change in our application, but we are now connec‐
ted to our API. Next, let’s look at how we can query data from that API.
Writing GraphQL Queries
Now that we’re connected to our API, let’s query some of the data. We’ll start by
querying for all of the notes in our database, to be displayed in our NoteFeed list.
We’ll then query for individual notes to be displayed in our Note detail view.
The note Query
We’ll be using the bulk note API query rather than the paginated
noteFeed query for simplicity and to reduce repetition.
Writing a Query component works exactly the same way as in a React web applica‐
tion. In src/screens/feed.js, we import the useQuery and GraphQL Language (gql)
libraries like so:
264 | Chapter 23: GraphQL and React Native
// import our React Native and Apollo dependencies
import { Text } from 'react-native';
import { useQuery, gql } from '@apollo/client';
Next, we compose our query:
const GET_NOTES = gql`
 query notes {
 notes {
 id
 createdAt
 content
 favoriteCount
 author {
 username
 id
 avatar
 }
 }
 }
`;
Finally, we update our component to call the query:
const Feed = props => {
 const { loading, error, data } = useQuery(GET_NOTES);
 // if the data is loading, our app will display a loading indicator
 if (loading) return <Text>Loading</Text>;
 // if there is an error fetching the data, display an error message
 if (error) return <Text>Error loading notes</Text>;
 // if the query is successful and there are notes, return the feed of notes
 return <NoteFeed notes={data.notes} navigation={props.navigation} />;
};
All together, our src/screens/feed.js file is written as follows:
import React from 'react';
import { Text } from 'react-native';
// import our Apollo libraries
import { useQuery, gql } from '@apollo/client';
import NoteFeed from '../components/NoteFeed';
import Loading from '../components/Loading';
// compose our query
const GET_NOTES = gql`
 query notes {
 notes {
 id
 createdAt
 content
 favoriteCount
 author {
GraphQL with Apollo Client | 265
 username
 id
 avatar
 }
 }
 }
`;
const Feed = props => {
 const { loading, error, data } = useQuery(GET_NOTES);
 // if the data is loading, our app will display a loading indicator
 if (loading) return <Text>Loading</Text>;
 // if there is an error fetching the data, display an error message
 if (error) return <Text>Error loading notes</Text>;
 // if the query is successful and there are notes, return the feed of notes
 return <NoteFeed notes={data.notes} navigation={props.navigation} />;
};
Feed.navigationOptions = {
 title: 'Feed'
};
export default Feed;
With our query written, we can update the src/components/NoteFeed.js component to
use the data passed to it via props:
const NoteFeed = props => {
 return (
 <View>
 <FlatList
 data={props.notes}
 keyExtractor={({ id }) => id.toString()}
 ItemSeparatorComponent={() => <Separator />}
 renderItem={({ item }) => (
 <TouchableOpacity
 onPress={() =>
 props.navigation.navigate('Note', {
 id: item.id
 })
 }
 >
 <FeedView>
 <Note note={item} />
 </FeedView>
 </TouchableOpacity>
 )}
 />
 </View>
 );
};
266 | Chapter 23: GraphQL and React Native
With this change, with Expo running, we will see the data from our local API dis‐
played in a list, as shown in Figure 23-2.
Figure 23-2. Our API data displaying in our feed view
Right now, tapping a note preview in the list will still display a generic note page. Let’s
resolve that by making a note query in the src/screens/note.js file:
import React from 'react';
import { Text } from 'react-native';
import { useQuery, gql } from '@apollo/client';
import Note from '../components/Note';
// our note query, which accepts an ID variable
const GET_NOTE = gql`
 query note($id: ID!) {
 note(id: $id) {
GraphQL with Apollo Client | 267
 id
 createdAt
 content
 favoriteCount
 author {
 username
 id
 avatar
 }
 }
 }
`;
const NoteScreen = props => {
 const id = props.navigation.getParam('id');
 const { loading, error, data } = useQuery(GET_NOTE, { variables: { id } });
 if (loading) return <Text>Loading</Text>;
 // if there's an error, display this message to the user
 if (error) return <Text>Error! Note not found</Text>;
 // if successful, pass the data to the note component
 return <Note note={data.note} />;
};
export default NoteScreen;
Finally, let’s update out src/components/Note component file to display the note con‐
tents. We’ll add two new dependencies, react-native-markdown-renderer and
date-fns, to parse the Markdown and dates from our API in a more user-friendly
way.
import React from 'react';
import { Text, ScrollView } from 'react-native';
import styled from 'styled-components/native';
import Markdown from 'react-native-markdown-renderer';
import { format } from 'date-fns';
const NoteView = styled.ScrollView`
 padding: 10px;
`;
const Note = ({ note }) => {
 return (
 <NoteView>
 <Text>
 Note by {note.author.username} / Published{' '}
 {format(new Date(note.createdAt), 'MMM do yyyy')}
 </Text>
 <Markdown>{note.content}</Markdown>
 </NoteView>
 );
};
268 | Chapter 23: GraphQL and React Native
export default Note;
With these changes, we’ll see a list of notes in the application’s feed view. Tapping a
note preview will take us to the full, scrollable content of the note (see Figure 23-3).
Figure 23-3. With our GraphQL queries written, we can navigate between screens to
view note previews and full notes
Adding a Loading Indicator
Currently when data is loading in our application, it flashes the word “Loading” on
the screen. This may be effective at conveying the message, but is also a pretty jarring
user experience. React Native supplies us with a built-in ActivityIndicator, which
displays an operating system–appropriate loading spinner. Let’s write a simple com‐
ponent that we can use as a loading indicator across our application.
Adding a Loading Indicator | 269
Create a file at src/components/Loading.js and compose a simple component that dis‐
plays the activity indicator in the center of the screen:
import React from 'react';
import { View, ActivityIndicator } from 'react-native';
import styled from 'styled-components/native';
const LoadingWrap = styled.View`
 flex: 1;
 justify-content: center;
 align-items: center;
`;
const Loading = () => {
 return (
 <LoadingWrap>
 <ActivityIndicator size="large" />
 </LoadingWrap>
 );
};
export default Loading;
Now we can replace the “Loading” text in our GraphQL query components. In both
src/screens/feed.js and src/screens/note.js, first import the Loading component:
import Loading from '../components/Loading';
Then, in both files, update the Apollo loading state as follows:
if (loading) return <Loading />;
With this, our application will now display a spinning activity indicator when our
API data is loading (see Figure 23-4).
270 | Chapter 23: GraphQL and React Native
Figure 23-4. Using ActivityIndicator, we can add an operating system–appropriate load‐
ing spinner
Conclusion
In this chapter we first looked at how we can integrate list views into a React Native
application, making use of common application UI patterns. From there we config‐
ured Apollo Client and integrated the data from our API into the application. With
this, we already have everything we need to build many common types of applica‐
tions, such as a news app or integrating a blog feed from a website. In the next chap‐
ter, we’ll add authentication to our app and display user-specific queries.
Conclusion | 271

CHAPTER 24
Mobile Application Authentication
If you’ve ever stayed with a relative, vacationed at a rental property, or rented a fur‐
nished apartment, you know what it’s like to be surrounded by things that aren’t
yours. It can be hard to feel settled in these types of environments, not wanting to
leave something out of place or make a mess. When I’m in these situations, no matter
how kind or accommodating the host is, this lack of ownership leaves me on edge.
What can I say? I’m just not comfortable unless I can put a glass down without a
coaster.
Without the ability to customize or read user-specific data, our app might fill users
with the same sense of discomfort. Their notes are simply mixed in with those of
everyone else, not making the application truly their own. In this chapter we’ll add
authentication to our application. To accomplish this, we’ll introduce an authentica‐
tion routing flow, store token data using Expo’s SecureStore, create text forms in
React Native, and perform authentication GraphQL mutations.
Authentication Routing Flow
Let’s begin by creating our authentication flow. When a user first accesses our applica‐
tion, we’ll present them with a sign-in screen. When the user signs in, we’ll store a
token on the device, allowing them to bypass the sign-in screen on future application
uses. We’ll also add a settings screen, where a user can click a button to log out of the
application and remove the token from their device.
To accomplish this, we’ll be adding several new screens:
authloading.js
This will be an interstitial screen, which users won’t interact with. When the app
is opened, we’ll use the screen to check if a token is present and navigate the user
to either the sign-in screen or the application content.
273
signin.js
This is the screen where a user can sign in to their account. After a successful
login attempt, we will store a token on the device.
settings.js
In the settings screen, a user will be able to click a button and log out of the appli‐
cation. Once they are logged out, they will be routed back to the sign-in screen.
Using an Existing Account
We’ll be adding the ability to create an account through the app
later in the chapter. If you haven’t already, it would be useful to cre‐
ate an account either directly through your API instance’s
GraphQL Playground or the web application interface.
For storing and working with tokens, we’ll be using Expo’s SecureStore library. I’ve
found SecureStore to be a straightforward way to encrypt and store data locally on a
device. For iOS devices, SecureStore makes use of the built-in keychain services,
while on Android it uses the OS’s Shared Preferences, encrypting the data with Key‐
store. All of this happens under the hood, allowing us to simply store and retrieve
data.
To begin with, we’ll create our sign-in screen. For now, our sign-in screen will consist
of a Button component that, when pressed, will store a token. Let’s create a new
screen component at src/screens/signin.js, importing our dependencies:
import React from 'react';
import { View, Button, Text } from 'react-native';
import * as SecureStore from 'expo-secure-store';
const SignIn = props => {
 return (
 <View>
 <Button title="Sign in!" />
 </View>
 );
}
SignIn.navigationOptions = {
 title: 'Sign In'
};
export default SignIn;
274 | Chapter 24: Mobile Application Authentication
Next, let’s create our authentication loading component at src/screens/authloading.js,
which for now will simply display a loading indicator:
import React, { useEffect } from 'react';
import * as SecureStore from 'expo-secure-store';
import Loading from '../components/Loading';
const AuthLoading = props => {
 return <Loading />;
};
export default AuthLoading;
Finally, we can create our settings screen at src/screens/settings.js:
import React from 'react';
import { View, Button } from 'react-native';
import * as SecureStore from 'expo-secure-store';
const Settings = props => {
 return (
 <View>
 <Button title="Sign Out" />
 </View>
 );
};
Settings.navigationOptions = {
 title: 'Settings'
};
export default Settings;
With these components written, we will update our routing to handle the authentica‐
ted and unauthenticated states. In src/screens/index.js, add the new screens to our list
of import statements as follows:
import AuthLoading from './authloading';
import SignIn from './signin';
import Settings from './settings';
We’ll also need to update our react-navigation dependency to include
createSwitchNavigator, which allows us to display a single screen at a time and
switch between them. The SwitchNavigator resets routes to the default state when a
user navigates and does not offer back-navigation options.
import { createAppContainer, createSwitchNavigator } from 'react-navigation';
Authentication Routing Flow | 275
We can create a new StackNavigator for our authentication and settings screens.
This will allow us to add subnavigation screens when or if needed in the future:
const AuthStack = createStackNavigator({
 SignIn: SignIn
});
const SettingsStack = createStackNavigator({
 Settings: Settings
});
We will then add our settings screen to the bottom TabNavigator. The rest of the tab
navigation settings will stay the same:
const TabNavigator = createBottomTabNavigator({
FeedScreen: {
 // ...
},
MyNoteScreen: {
 // ...
},
FavoriteScreen: {
 // ...
},
Settings: {
 screen: Settings,
 navigationOptions: {
 tabBarLabel: 'Settings',
 tabBarIcon: ({ tintColor }) => (
 <MaterialCommunityIcons name="settings" size={24} color={tintColor} />
 )
 }
}
});
We can now create our SwitchNavigator by defining the screens to switch between
and setting a default screen, the AuthLoading. We’ll then replace our existing export
statement with one that exports the SwitchNavigator:
const SwitchNavigator = createSwitchNavigator(
 {
 AuthLoading: AuthLoading,
 Auth: AuthStack,
 App: TabNavigator
 },
 {
 initialRouteName: 'AuthLoading'
 }
);
export default createAppContainer(SwitchNavigator);
276 | Chapter 24: Mobile Application Authentication
All together, our src/screens/index.js file will appear as follows:
import React from 'react';
import { Text, View, ScrollView, Button } from 'react-native';
import { createAppContainer, createSwitchNavigator } from 'react-navigation';
import { createBottomTabNavigator } from 'react-navigation-tabs';
import { createStackNavigator } from 'react-navigation-stack';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import Feed from './feed';
import Favorites from './favorites';
import MyNotes from './mynotes';
import Note from './note';
import SignIn from './signin';
import AuthLoading from './authloading';
import Settings from './settings';
const AuthStack = createStackNavigator({
 SignIn: SignIn,
});
const FeedStack = createStackNavigator({
 Feed: Feed,
 Note: Note
});
const MyStack = createStackNavigator({
 MyNotes: MyNotes,
 Note: Note
});
const FavStack = createStackNavigator({
 Favorites: Favorites,
 Note: Note
});
const SettingsStack = createStackNavigator({
 Settings: Settings
});
const TabNavigator = createBottomTabNavigator({
 FeedScreen: {
 screen: FeedStack,
 navigationOptions: {
 tabBarLabel: 'Feed',
 tabBarIcon: ({ tintColor }) => (
 <MaterialCommunityIcons name="home" size={24} color={tintColor} />
 )
 }
 },
 MyNoteScreen: {
 screen: MyStack,
 navigationOptions: {
Authentication Routing Flow | 277
 tabBarLabel: 'My Notes',
 tabBarIcon: ({ tintColor }) => (
 <MaterialCommunityIcons name="notebook" size={24} color={tintColor} />
 )
 }
 },
 FavoriteScreen: {
 screen: FavStack,
 navigationOptions: {
 tabBarLabel: 'Favorites',
 tabBarIcon: ({ tintColor }) => (
 <MaterialCommunityIcons name="star" size={24} color={tintColor} />
 )
 }
 },
 Settings: {
 screen: SettingsStack,
 navigationOptions: {
 tabBarLabel: 'Settings',
 tabBarIcon: ({ tintColor }) => (
 <MaterialCommunityIcons name="settings" size={24} color={tintColor} />
 )
 }
 }
});
const SwitchNavigator = createSwitchNavigator(
 {
 AuthLoading: AuthLoading,
 Auth: AuthStack,
 App: TabNavigator
 },
 {
 initialRouteName: 'AuthLoading'
 }
);
export default createAppContainer(SwitchNavigator);
Right now, when we preview our app we’ll only see loading spinner, since our Auth
Loading route is the initial screen. Let’s update this so that the loading screen checks
for the existence of a token value in the application’s SecureStore. If the token is
present, we’ll navigate the user to the main application screen. However, if no token is
present, the user should be routed to the sign-in screen. Let’s update src/screens/
authloading.js to perform this check:
import React, { useEffect } from 'react';
import * as SecureStore from 'expo-secure-store';
import Loading from '../components/Loading';
const AuthLoadingScreen = props => {
278 | Chapter 24: Mobile Application Authentication
 const checkLoginState = async () => {
 // retrieve the value of the token
 const userToken = await SecureStore.getItemAsync('token');
 // navigate to the app screen if a token is present
 // else navigate to the auth screen
 props.navigation.navigate(userToken ? 'App' : 'Auth');
 };
 // call checkLoginState as soon as the component mounts
 useEffect(() => {
 checkLoginState();
 });
 return <Loading />;
};
export default AuthLoadingScreen;
With this change, when we load the app we should now be routed to the sign-in
screen, since no token is present. For now, let’s update our sign-in screen to store a
generic token and navigate to the application when the user presses the button
(Figure 24-1):
import React from 'react';
import { View, Button, Text } from 'react-native';
import * as SecureStore from 'expo-secure-store';
const SignIn = props => {
 // store the token with a key value of `token`
 // after the token is stored navigate to the app's main screen
 const storeToken = () => {
 SecureStore.setItemAsync('token', 'abc').then(
 props.navigation.navigate('App')
 );
 };
 return (
 <View>
 <Button title="Sign in!" onPress={storeToken} />
 </View>
 );
};
SignIn.navigationOptions = {
 title: 'Sign In'
};
export default SignIn;
Authentication Routing Flow | 279
Figure 24-1. Clicking the button will store a token and route the user to the application
Now, when a user presses the button, a token is stored via SecureStore. With the
sign-in functionality in place, let’s add the ability for users to sign out of the applica‐
tion. To do so, we’ll add a button on our settings screen that, when pressed, will
remove the token from SecureStore (Figure 24-2). In src/screens/settings.js:
import React from 'react';
import { View, Button } from 'react-native';
import * as SecureStore from 'expo-secure-store';
const Settings = props => {
 // delete the token then navigate to the auth screen
 const signOut = () => {
 SecureStore.deleteItemAsync('token').then(
 props.navigation.navigate('Auth')
 );
 };
280 | Chapter 24: Mobile Application Authentication
 return (
 <View>
 <Button title="Sign Out" onPress={signOut} />
 </View>
 );
};
Settings.navigationOptions = {
 title: 'Settings'
};
export default Settings;
Figure 24-2. Clicking the button will remove the token from the device and return the
user to the sign-in screen
Authentication Routing Flow | 281
With these pieces in place, we have everything we need to create an application
authentication flow.
Be Sure to Sign Out
If you haven’t already, tap the Sign Out button in your local app
instance. We’ll be adding proper sign-in functionality in the
upcoming sections.
Creating a Sign-in Form
While we can now click a button and store a token on the user’s device, we’re not yet
allowing a user to sign in to an account by entering their own information. Let’s begin
to remedy this by creating a form where a user can enter their email address and
password. To do this, we’ll create a new component at src/components/UserForm.js
with a form using React Native’s TextInput component:
import React, { useState } from 'react';
import { View, Text, TextInput, Button, TouchableOpacity } from 'react-native';
import styled from 'styled-components/native';
const UserForm = props => {
 return (
 <View>
 <Text>Email</Text>
 <TextInput />
 <Text>Password</Text>
 <TextInput />
 <Button title="Log In" />
 </View>
 );
}
export default UserForm;
Now we can display this form on our authentication screen. To do so, update src/
screens/signin.js to import and use the component like so:
import React from 'react';
import { View, Button, Text } from 'react-native';
import * as SecureStore from 'expo-secure-store';
import UserForm from '../components/UserForm';
const SignIn = props => {
 const storeToken = () => {
 SecureStore.setItemAsync('token', 'abc').then(
 props.navigation.navigate('App')
 );
 };
282 | Chapter 24: Mobile Application Authentication
 return (
 <View>
 <UserForm />
 </View>
 );
}
export default SignIn;
With this, we’ll see a basic form display on the authentication screen, but it lacks any
style or functionality. We can continue implementing the form in our src/components/
UserForm.js file. We’ll be using React’s useState hook to read and set the values of
our form elements:
const UserForm = props => {
 // form element state
 const [email, setEmail] = useState();
 const [password, setPassword] = useState();
 return (
 <View>
 <Text>Email</Text>
 <TextInput onChangeText={text => setEmail(text)} value={email} />
 <Text>Password</Text>
 <TextInput onChangeText={text => setPassword(text)} value={password} />
 <Button title="Log In" />
 </View>
 );
}
Now we can add a few more additional properties to our form elements to provide
users with the expected functionality when working with email addresses or pass‐
words. Full documentation of the TextInput API can be found in the React Native
docs. We’ll also call a function when the button is pressed, though the functionality
will be limited.
const UserForm = props => {
 // form element state
 const [email, setEmail] = useState();
 const [password, setPassword] = useState();
 const handleSubmit = () => {
 // this function is called when the user presses the form button
 };
 return (
 <View>
 <Text>Email</Text>
 <TextInput
 onChangeText={text => setEmail(text)}
 value={email}
Creating a Sign-in Form | 283
 textContentType="emailAddress"
 autoCompleteType="email"
 autoFocus={true}
 autoCapitalize="none"
 />
 <Text>Password</Text>
 <TextInput
 onChangeText={text => setPassword(text)}
 value={password}
 textContentType="password"
 secureTextEntry={true}
 />
 <Button title="Log In" onPress={handleSubmit} />
 </View>
 );
}
Our form has all of the necessary components, but the styling leaves a lot to be
desired. Let’s use the Styled Components library to give the form a more appropriate
appearance:
import React, { useState } from 'react';
import { View, Text, TextInput, Button, TouchableOpacity } from 'react-native';
import styled from 'styled-components/native';
const FormView = styled.View`
 padding: 10px;
`;
const StyledInput = styled.TextInput`
 border: 1px solid gray;
 font-size: 18px;
 padding: 8px;
 margin-bottom: 24px;
`;
const FormLabel = styled.Text`
 font-size: 18px;
 font-weight: bold;
`;
const UserForm = props => {
 const [email, setEmail] = useState();
 const [password, setPassword] = useState();
 const handleSubmit = () => {
 // this function is called when the user presses the form button
 };
 return (
 <FormView>
 <FormLabel>Email</FormLabel>
284 | Chapter 24: Mobile Application Authentication
 <StyledInput
 onChangeText={text => setEmail(text)}
 value={email}
 textContentType="emailAddress"
 autoCompleteType="email"
 autoFocus={true}
 autoCapitalize="none"
 />
 <FormLabel>Password</FormLabel>
 <StyledInput
 onChangeText={text => setPassword(text)}
 value={password}
 textContentType="password"
 secureTextEntry={true}
 />
 <Button title="Log In" onPress={handleSubmit} />
 </FormView>
 );
};
export default UserForm;
Finally, our Button component is limited to the default style options, with the excep‐
tion of accepting a color property value. To create a custom-styled button compo‐
nent, we can use the React Native wrapper TouchableOpacity (see Figure 24-3):
const FormButton = styled.TouchableOpacity`
 background: #0077cc;
 width: 100%;
 padding: 8px;
`;
const ButtonText = styled.Text`
 text-align: center;
 color: #fff;
 font-weight: bold;
 font-size: 18px;
`;
const UserForm = props => {
 const [email, setEmail] = useState();
 const [password, setPassword] = useState();
 const handleSubmit = () => {
 // this function is called when the user presses the form button
 };
 return (
 <FormView>
 <FormLabel>Email</FormLabel>
 <StyledInput
 onChangeText={text => setEmail(text)}
Creating a Sign-in Form | 285
 value={email}
 textContentType="emailAddress"
 autoCompleteType="email"
 autoFocus={true}
 autoCapitalize="none"
 />
 <FormLabel>Password</FormLabel>
 <StyledInput
 onChangeText={text => setPassword(text)}
 value={password}
 textContentType="password"
 secureTextEntry={true}
 />
 <FormButton onPress={handleSubmit}>
 <ButtonText>Submit</ButtonText>
 </FormButton>
 </FormView>
 );
};
With this, we’ve implemented a sign-in form and applied custom styles. Let’s now
implement the form’s functionality.
286 | Chapter 24: Mobile Application Authentication
Figure 24-3. Our sign-in form with custom styles
Authentication with GraphQL Mutations
You may recall the authentication flow we’ve developed from the API and web appli‐
cation chapters, but before moving forward let’s do a quick refresher. We will send a
GraphQL mutation to our API that includes the user’s email address and password. If
the email address is present in our database and the password is correct, our API will
respond with a JWT. We can then store the token on the user’s device, as we’ve
already been doing, and send it along with every GraphQL request. This will allow us
to identify the user on every API request, without requiring them to constantly reenter their password.
With our form in place, we can write our GraphQL mutation in src/screens/signin.js.
First, we’ll add the Apollo libraries as well as our Loading component to our list of
imports:
Authentication with GraphQL Mutations | 287
import React from 'react';
import { View, Button, Text } from 'react-native';
import * as SecureStore from 'expo-secure-store';
import { useMutation, gql } from '@apollo/client';
import UserForm from '../components/UserForm';
import Loading from '../components/Loading';
Next, we can add our GraphQL query:
const SIGNIN_USER = gql`
 mutation signIn($email: String, $password: String!) {
 signIn(email: $email, password: $password)
 }
`;
And update our storeToken function to store a token string passed as a parameter:
const storeToken = token => {
 SecureStore.setItemAsync('token', token).then(
 props.navigation.navigate('App')
 );
};
Finally, we update the component as a GraphQL mutation. We’ll also pass several
property values to the UserForm component, allowing us to share the mutation data,
identify the type of form we are calling, and make use of the router’s navigation.
const SignIn = props => {
 const storeToken = token => {
 SecureStore.setItemAsync('token', token).then(
 props.navigation.navigate('App')
 );
 };
 const [signIn, { loading, error }] = useMutation(SIGNIN_USER, {
 onCompleted: data => {
 storeToken(data.signIn)
 }
 });
 // if loading, return a loading indicator
 if (loading) return <Loading />;
 return (
 <React.Fragment>
 {error && <Text>Error signing in!</Text>}
 <UserForm
 action={signIn}
 formType="signIn"
 navigation={props.navigation}
 />
 </React.Fragment>
 );
};
288 | Chapter 24: Mobile Application Authentication
Now we can make a simple change in our src/components/UserForm.js component,
which will enable it to pass the user-entered data to the mutation. Within the compo‐
nent, we will update our handleSubmit function to pass the form values to our
mutation:
const handleSubmit = () => {
 props.action({
 variables: {
 email: email,
 password: password
 }
 });
};
With our mutation written and form complete, users can now sign in to the applica‐
tion, which will store the returned JSON Web Token for future use.
Authenticated GraphQL Queries
Now that our users can sign-in to their account, we’ll need to use the stored token to
authenticate each request. This will allow us to request user-specific data, such as a
list of notes by the current user or a list of notes the user has marked as “favorites.” To
accomplish this, we’ll update the Apollo configuration to check for the existence of a
token and, when one is present, send that token’s value with each API call.
In src/Main.js, first add SecureStore to the list of imports and update the Apollo Cli‐
ent dependencies to include createHttpLink and setContext:
// import the Apollo libraries
import {
 ApolloClient,
 ApolloProvider,
 createHttpLink,
 InMemoryCache
} from '@apollo/client';
import { setContext } from 'apollo-link-context';
// import SecureStore for retrieving the token value
import * as SecureStore from 'expo-secure-store';
We can then update our Apollo Client configuration to send the token value with
each request:
// configure our API URI & cache
const uri = API_URI;
const cache = new InMemoryCache();
const httpLink = createHttpLink({ uri });
// return the headers to the context
const authLink = setContext(async (_, { headers }) => {
 return {
Authenticated GraphQL Queries | 289
 headers: {
 ...headers,
 authorization: (await SecureStore.getItemAsync('token')) || ''
 }
 };
});
// configure Apollo Client
const client = new ApolloClient({
 link: authLink.concat(httpLink),
 cache
});
With the token sent in the header of each request, we can now update the mynotes
and favorites screens to request user-specific data. If you followed along through
the web chapters, these queries should look very familiar.
In src/screens/mynotes.js:
import React from 'react';
import { Text, View } from 'react-native';
import { useQuery, gql } from '@apollo/client';
import NoteFeed from '../components/NoteFeed';
import Loading from '../components/Loading';
// our GraphQL query
const GET_MY_NOTES = gql`
 query me {
 me {
 id
 username
 notes {
 id
 createdAt
 content
 favoriteCount
 author {
 username
 id
 avatar
 }
 }
 }
 }
`;
const MyNotes = props => {
 const { loading, error, data } = useQuery(GET_MY_NOTES);
 // if the data is loading, our app will display a loading message
 if (loading) return <Loading />;
 // if there is an error fetching the data, display an error message
290 | Chapter 24: Mobile Application Authentication
 if (error) return <Text>Error loading notes</Text>;
 // if the query is successful and there are notes, return the feed of notes
 // else if the query is successful and there aren't notes, display a message
 if (data.me.notes.length !== 0) {
 return <NoteFeed notes={data.me.notes} navigation={props.navigation} />;
 } else {
 return <Text>No notes yet</Text>;
 }
};
MyNotes.navigationOptions = {
 title: 'My Notes'
};
export default MyNotes;
In src/screens/favorites.js:
import React from 'react';
import { Text, View } from 'react-native';
import { useQuery, gql } from '@apollo/client';
import NoteFeed from '../components/NoteFeed';
import Loading from '../components/Loading';
// our GraphQL query
const GET_MY_FAVORITES = gql`
 query me {
 me {
 id
 username
 favorites {
 id
 createdAt
 content
 favoriteCount
 author {
 username
 id
 avatar
 }
 }
 }
 }
`;
const Favorites = props => {
 const { loading, error, data } = useQuery(GET_MY_FAVORITES);
 // if the data is loading, our app will display a loading message
 if (loading) return <Loading />;
 // if there is an error fetching the data, display an error message
 if (error) return <Text>Error loading notes</Text>;
Authenticated GraphQL Queries | 291
 // if the query is successful and there are notes, return the feed of notes
 // else if the query is successful and there aren't notes, display a message
 if (data.me.favorites.length !== 0) {
 return <NoteFeed notes={data.me.favorites} navigation={props.navigation} />;
 } else {
 return <Text>No notes yet</Text>;
 }
};
Favorites.navigationOptions = {
 title: 'Favorites'
};
export default Favorites;
Figure 24-4. Passing the token in the header of each request allows us to make userspecific queries in our application
292 | Chapter 24: Mobile Application Authentication
We are now retrieving user-specific data based on the token value stored on the user’s
device (Figure 24-4).
Adding a Sign-up Form
Right now a user can sign in to an existing account, but they have no way to create an
account if one doesn’t exist. A common UI pattern is to add a link to a registration
form below the sign-in link (or vice versa). Let’s add a sign-up screen to allow users to
create a new account from within our application.
To begin, let’s create a new screen component at src/screens/signup.js. This component
will be nearly identical to our sign-in screen, but we’ll call our signUp GraphQL
mutation and pass a formType="signUp" property to our UserForm component:
import React from 'react';
import { Text } from 'react-native';
import * as SecureStore from 'expo-secure-store';
import { useMutation, gql } from '@apollo/client';
import UserForm from '../components/UserForm';
import Loading from '../components/Loading';
// signUp GraphQL mutation
const SIGNUP_USER = gql`
 mutation signUp($email: String!, $username: String!, $password: String!) {
 signUp(email: $email, username: $username, password: $password)
 }
`;
const SignUp = props => {
 // store the token with a key value of `token`
 // after the token is stored navigate to the app's main screen
 const storeToken = token => {
 SecureStore.setItemAsync('token', token).then(
 props.navigation.navigate('App')
 );
 };
 // the signUp mutation hook
 const [signUp, { loading, error }] = useMutation(SIGNUP_USER, {
 onCompleted: data => {
 storeToken(data.signUp);
 }
 });
 // if loading, return a loading indicator
 if (loading) return <Loading />;
 return (
 <React.Fragment>
Adding a Sign-up Form | 293
 {error && <Text>Error signing in!</Text>}
 <UserForm
 action={signUp}
 formType="signUp"
 navigation={props.navigation}
 />
 </React.Fragment>
 );
};
SignUp.navigationOptions = {
 title: 'Register'
};
export default SignUp;
With the screen created, we can add it to our router. In the src/screens/index.js file,
first add the new component to our list of file imports:
import SignUp from './signup';
Next, we will update our AuthStack to include the sign-up screen:
const AuthStack = createStackNavigator({
 SignIn: SignIn,
 SignUp: SignUp
});
With this, our component is created and routable; however, our UserForm component
does not contain all of the necessary fields. Rather than creating a registration form
component, we can make use of the formType property that we’re passing to User
Form to customize the form, depending on the type.
In our src/components/UserForm.js file, let’s first update the form to include a user‐
name field when the formType equals signUp:
const UserForm = props => {
 const [email, setEmail] = useState();
 const [password, setPassword] = useState();
 const [username, setUsername] = useState();
 const handleSubmit = () => {
 props.action({
 variables: {
 email: email,
 password: password,
 username: username
 }
 });
 };
 return (
 <FormView>
294 | Chapter 24: Mobile Application Authentication
 <FormLabel>Email</FormLabel>
 <StyledInput
 onChangeText={text => setEmail(text)}
 value={email}
 textContentType="emailAddress"
 autoCompleteType="email"
 autoFocus={true}
 autoCapitalize="none"
 />
 {props.formType === 'signUp' && (
 <View>
 <FormLabel>Username</FormLabel>
 <StyledInput
 onChangeText={text => setUsername(text)}
 value={username}
 textContentType="username"
 autoCapitalize="none"
 />
 </View>
 )}
 <FormLabel>Password</FormLabel>
 <StyledInput
 onChangeText={text => setPassword(text)}
 value={password}
 textContentType="password"
 secureTextEntry={true}
 />
 <FormButton onPress={handleSubmit}>
 <ButtonText>Submit</ButtonText>
 </FormButton>
 </FormView>
 );
};
Next, let’s add a link at the bottom of the sign-in form that will allow a user to route
to the sign-up form when pressed:
return (
 <FormView>
 {/* existing form component code is here */}
 {props.formType !== 'signUp' && (
 <TouchableOpacity onPress={() => props.navigation.navigate('SignUp')}>
 <Text>Sign up</Text>
 </TouchableOpacity>
 )}
 </FormView>
)
We can then use styled components to update the look of the link:
const SignUp = styled.TouchableOpacity`
 margin-top: 20px;
`;
Adding a Sign-up Form | 295
const Link = styled.Text`
 color: #0077cc;
 font-weight: bold;
`;
And in the component’s JSX:
{props.formType !== 'signUp' && (
 <SignUp onPress={() => props.navigation.navigate('SignUp')}>
 <Text>
 Need an account? <Link>Sign up.</Link>
 </Text>
 </SignUp>
)}
All together, our src/components/UserForm.js file will now be as follows:
import React, { useState } from 'react';
import { View, Text, TextInput, Button, TouchableOpacity } from 'react-native';
import styled from 'styled-components/native';
const FormView = styled.View`
 padding: 10px;
`;
const StyledInput = styled.TextInput`
 border: 1px solid gray;
 font-size: 18px;
 padding: 8px;
 margin-bottom: 24px;
`;
const FormLabel = styled.Text`
 font-size: 18px;
 font-weight: bold;
`;
const FormButton = styled.TouchableOpacity`
 background: #0077cc;
 width: 100%;
 padding: 8px;
`;
const ButtonText = styled.Text`
 text-align: center;
 color: #fff;
 font-weight: bold;
 font-size: 18px;
`;
const SignUp = styled.TouchableOpacity`
 margin-top: 20px;
`;
296 | Chapter 24: Mobile Application Authentication
const Link = styled.Text`
 color: #0077cc;
 font-weight: bold;
`;
const UserForm = props => {
 const [email, setEmail] = useState();
 const [password, setPassword] = useState();
 const [username, setUsername] = useState();
 const handleSubmit = () => {
 props.action({
 variables: {
 email: email,
 password: password,
 username: username
 }
 });
 };
 return (
 <FormView>
 <FormLabel>Email</FormLabel>
 <StyledInput
 onChangeText={text => setEmail(text)}
 value={email}
 textContentType="emailAddress"
 autoCompleteType="email"
 autoFocus={true}
 autoCapitalize="none"
 />
 {props.formType === 'signUp' && (
 <View>
 <FormLabel>Username</FormLabel>
 <StyledInput
 onChangeText={text => setUsername(text)}
 value={username}
 textContentType="username"
 autoCapitalize="none"
 />
 </View>
 )}
 <FormLabel>Password</FormLabel>
 <StyledInput
 onChangeText={text => setPassword(text)}
 value={password}
 textContentType="password"
 secureTextEntry={true}
 />
 <FormButton onPress={handleSubmit}>
 <ButtonText>Submit</ButtonText>
Adding a Sign-up Form | 297
 </FormButton>
 {props.formType !== 'signUp' && (
 <SignUp onPress={() => props.navigation.navigate('SignUp')}>
 <Text>
 Need an account? <Link>Sign up.</Link>
 </Text>
 </SignUp>
 )}
 </FormView>
 );
};
export default UserForm;
With these changes, a user can both sign in and register for an account with our
application (Figure 24-5).
Figure 24-5. A user can now register an account and navigate between the authentica‐
tion screens
298 | Chapter 24: Mobile Application Authentication
Conclusion
In this chapter we looked at how to bring authentication to an application. Through a
combination of React Native’s text form elements, React Navigation’s routing capabili‐
ties, Expo’s SecureStore library, and GraphQL mutations, we can create a userfriendly authentication flow. Having a solid understanding of this type of
authentication also enables us to explore additional React Native authentication
methods, such as Expo’s AppAuth or GoogleSignIn. In this next chapter, we’ll look at
how we can publish and distribute a React Native application.
Conclusion | 299

CHAPTER 25
Mobile Application Distribution
In my high school in the mid-1990s, it was all the rage to download games for your
TI-81 graphing calculator. Someone would get ahold of a copy of a game and then it
would spread like wildfire, each of us taking turns connecting our calculator to
another with a cord in order to load the game. Having a game on your calculator was
a way to fill the hours in the back of a class or study hall while maintaining the
appearance of doing schoolwork. As you can imagine, however, this distribution
method was slow, requiring two students to remain connected for several minutes
while others waited. Today, our digital pocket computers are capable of much more
than my humble graphing calculator, in part because we can easily extend their capa‐
bilities through installable third-party applications.
With our initial application development complete, we can now distribute our appli‐
cation so that others may access it. In this chapter we’ll look at how to configure our
app.json file for distribution. We’ll then publish our application publicly within Expo.
Finally, we’ll generate application packages that can be submitted to the Apple or
Google Play stores.
app.json Configuration
Expo applications include an app.json file, which is used to configure applicationspecific settings.
When we generate a new Expo application, an app.json file is automatically created
for us. Let’s take a look at the generated file for our application:
{
 "expo": {
 "name": "Notedly",
 "slug": "notedly-mobile",
 "description": "An example React Native app",
301
 "privacy": "public",
 "sdkVersion": "33.0.0",
 "platforms": ["ios", "android"],
 "version": "1.0.0",
 "orientation": "portrait",
 "icon": "./assets/icon.png",
 "splash": {
 "image": "./assets/splash.png",
 "resizeMode": "contain",
 "backgroundColor": "#ffffff"
 },
 "updates": {
 "fallbackToCacheTimeout": 1500
 },
 "assetBundlePatterns": ["**/*"],
 "ios": {
 "supportsTablet": true
 },
 "android": {}
 }
}
It is likely that most of these are self-explanatory, but let’s review the purpose of each:
name
The name of our application.
slug
The URL name for publishing the Expo app at expo.io/project-owner/slug.
description
A description of our project, which will be used when publishing the application
with Expo.
privacy
The Expo project’s public availability. This can be set to either public or
unlisted.
sdkVersion
The Expo SDK version number.
platforms
The platforms we are targeting, which can include ios, android, and web.
version
Our application’s version number, which should follow the Semantic Versioning
standards.
302 | Chapter 25: Mobile Application Distribution
orientation
Our application’s default orientation, which can be locked with portrait or land
scape values, or match the user’s device rotation with default.
icon
A path to the application icon, which will be used for both iOS and Android.
splash
The image location and settings for the app loading screen.
updates
A configuration for how our application should check for over the air (OTA)
updates when the app is loaded. The fallbackToCacheTimeout parameter allows
us to specify a length of time in milliseconds.
assetBundlePatterns
Allows us to specify the location of assets that should be bundled with our
application.
ios and android
Enable platform-specific settings.
This default configuration provides us with a solid basis for our application. There
are a number of additional settings, which can be found in the Expo documentation.
Icons and App Loading Screens
The small squarish icons found on our devices have become one of the most recog‐
nizable designs in modern society. Close your eyes and I’m sure you can imagine doz‐
ens of them, down to a logo or a specific background color. Additionally, when a user
taps an icon there is an initial static “splash screen,” which is displayed while the
application loads. Up until now we’ve used the default empty Expo icons and splash
screen. We can replace those with custom designs in our application.
I’ve included a Notedly icon and splash screen in the assets/custom folder. We can
make use of these by replacing the images in the assets directory with them or updat‐
ing our app.json configuration to point to the files in the custom subdirectory.
App Icons
The icon.png file is a square 1024×1024px PNG file. If we point to this file with our
app.json icon property, Expo will generate the appropriate icon sizes for various plat‐
forms and devices. The image should be exactly square and without any transparent
pixels. This is the simplest and most straightforward way to include an application
icon:
Icons and App Loading Screens | 303
"icon": "./assets/icon.png",
In addition to the single cross-platform icon, we have the option to include platformspecific icons. The main draw of this approach would be to include separate icon
styles for Android and iOS, particularly if you are interested in using Android’s adap‐
tive icons.
For iOS, we would continue to use a single 1024×1024 png. In the app.json file:
"ios": {
 "icon": IMAGE_PATH
}
To make use of Android’s adaptive icon, we would specify a foregroundImage, a back
groundColor (or backgroundImage), and a fallback static icon:
"android": {
 "adaptiveIcon": {
 "foregroundImage": IMAGE_PATH,
 "backgroundColor": HEX_CODE,
 "icon": IMAGE_PATH
 }
}
For our use case, we can continue to use the single static icon.
Splash Screens
The splash screen is a full screen image that will briefly display while our application
is booting on the device. We can replace the default Expo image with one found in
assets/custom. Though device sizes vary within and across platforms, I’ve chosen to
use a size of 1242×2436, as recommended by the Expo documentation. Expo will then
resize the image to work across device screens and aspect ratios.
We can configure our splash screen in the app.json file like so:
"splash": {
 "image": "./assets/splash.png",
 "backgroundColor": "#ffffff",
 "resizeMode": "contain"
},
By default, we are setting a white background color, which may be visible as the
image loads or, depending on our selected resizeMode, as a border around the splash
screen image. We can update this to match the color of our screen:
"backgroundColor": "#4A90E2",
The resizeMode dictates how the image should be resized for various screen sizes. By
setting this to contain, we preserve the aspect ratio of the original image. When you
use contain, some screen sizes or resolutions will see the backgroundColor as a bor‐
304 | Chapter 25: Mobile Application Distribution
der around the splash screen image. Alternately, we could set resizeMode to cover,
which will expand the image to fill the entire screen. Since our application has a sub‐
tle gradient, let’s set our resizeMode to cover:
"resizeMode": "cover"
Figure 25-1. Our application splash screen
With this, our icon and splash screen images are configured (see Figure 25-1). We are
now ready to look at how to distribute our application to make it accessible to others.
Expo Publish
During development, our application is accessible to us in the Expo Client application
on a physical device, over our local area network. This means that we can access the
application as long as our development machine and phone are on the same network.
Expo enables us to publish our project, which uploads the application to an Expo
Expo Publish | 305
CDN and gives us a publicly accessible URL. With this, anyone can run our applica‐
tion through the Expo Client app. This can be useful for testing or quick application
distribution.
To publish our project, we can click the “Publish or republish project” link in the
browser’s Expo Dev Tools (see Figure 25-2), or type expo publish in our terminal.
Figure 25-2. We can publish our application directly from Expo Dev Tools
Once the packaging has been completed, anyone can visit https://exp.host/@<user‐
name>/<slug> to access the application through the Expo Client App.
Creating Native Builds
While distributing directly through Expo is a great option for testing or quick use
cases, we will most likely want to release our application through the Apple App Store
or Google Play Store. To do so, we will build the files that can be uploaded to the
respective store.
306 | Chapter 25: Mobile Application Distribution
Windows Users
According to the Expo documentation, Windows users need to
enable Windows Subsystem for Linux (WSL). To accomplish this,
follow the Installation Guide for Windows 10 provided by Micro‐
soft.
iOS
Generating an iOS build requires a membership to the Apple Developer Program,
which costs $99 a year. With an account, we can then add a bundleIdentifier for
iOS in our app.json file. This identifier should follow reverse DNS notation:
"expo": {
"ios": {
 "bundleIdentifier": "com.yourdomain.notedly"
 }
}
With our app.json file updated, we can generate the build. In your terminal applica‐
tion, from the root of the project directory, enter:
$ expo build:ios
After running the build you’ll be prompted to sign in with your Apple ID. Once you
are signed in, you’ll be asked several questions about how you would like to handle
credentials. Expo is able to manage all credentials and certificates for us, which you
can permit by selecting the first option at each of the following prompts:
? How would you like to upload your credentials? (Use arrow keys)
❯ Expo handles all credentials, you can still provide overrides
 I will provide all the credentials and files needed, Expo does limited validat
ion
? Will you provide your own Apple Distribution Certificate? (Use arrow keys)
❯ Let Expo handle the process
 I want to upload my own file
 ? Will you provide your own Apple Push Notifications service key? (Use arrow keys)
❯ Let Expo handle the process
 I want to upload my own file
If you have an active Apple Developer Program account, Expo will then generate the
file, which can be submitted to the Apple App Store.
Android
For Android we can generate either an Android Package File (APK) or an Android
App Bundle (AAB) file. Android App Bundles are the more modern format, so let’s
Creating Native Builds | 307
go that route. If you are interested, the Android developers documentation offers a
detailed description of the benefits of App Bundles.
Before we generate the bundle, let’s update our app.json file to include an Android
package identifier. Similarly to iOS, this should be in reverse DNS notation:
"android": {
 "package": "com.yourdomain.notedly"
 }
With this, we can generate the app bundle from our terminal application. Be sure to
cd into the root of the project and run the following:
$ build:android -t app-bundle
App Bundles are required to be signed. Though we can generate a signature our‐
selves, Expo can manage the keystore for us. After running the command to generate
the bundle, you’ll see the following prompt:
? Would you like to upload a keystore or have us generate one for you?
If you don't know what this means, let us handle it! :)
 1) Let Expo handle the process!
 2) I want to upload my own keystore!
If you select 1, Expo will generate the App Bundle for you. At the end of the process,
you can download the file, which can be uploaded to the Google Play Store.
Distributing to App Stores
Because of the shifting review guidelines and associated costs, I won’t be walking
through the specifics of submitting our application to the Apple App Store or Google
Play Store. The Expo documentation does a nice job of collecting resources and
guidelines and is a helpful, up-to-date guide on how to navigate the app store distri‐
bution process.
Conclusion
In this chapter we’ve looked at how to publish and distribute a React Native applica‐
tion. Expo’s tooling allows us to quickly publish applications for testing and generate
production builds that can be uploaded to app stores. Expo also provides us with
options around levels of control for managing certificates and dependencies.
With this, we’ve successfully written and published a backend data API, a web appli‐
cation, a desktop application, and a cross-platform mobile application!
308 | Chapter 25: Mobile Application Distribution
Afterword
Here in the United States it’s common to give a new high school graduate a copy of
Dr. Suess’s Oh the Places You’ll Go! as a graduation gift.
Congratulations! Today is your day. You’re off to Great Places! You’re off and away!
If you’ve made it to the end of this book, a bit of a graduation celebration feels appro‐
priate. We’ve covered a lot of material, from building a GraphQL API with Node
through several types of UI clients, but we’ve only scratched the surface. Each of these
topics fills books and countless online tutorials on its own. I hope that rather than
feeling overwhelmed, you now feel equipped to more deeply explore the topics that
interest you and build amazing things.
JavaScript is the little programming language that could. What was once a humble
“toy language” is now the most popular programming language in the world. The
result is that knowing how to write JavaScript is a superpower that enables us to build
nearly any sort of application for any platform. Given that it’s a superpower, I’ll leave
you with one last cliche:
…with great power there must also come — great responsibility!
Technology can, and should, be a force for good. My hope is that you are able to
apply the things you’ve learned in this book toward making the world a better place.
That may include taking on a new job or side project that enables a better life for your
family, teaching others new skills, or building a product designed to bring happiness
or improve the lives of others. Whatever it may be, when you wield your powers for
good, we are all better off.
Please do not be a stranger. I would love to see and hear about anything you create.
Feel free to send me an email at adam@jseverywhere.io or join the Spectrum commu‐
nity. Thank you for reading.
— Adam
309

APPENDIX A
Running the API Locally
If you’ve chosen to follow along with the UI portion of the book, but not the API
development chapters, you will still need a copy of the API running locally.
The first step is to ensure that you have MongoDB installed and running on your sys‐
tem, as described in Chapter 1. With your database up and running, you can clone a
copy of the API and copy the final code. To clone the code to your local machine,
open the terminal, navigate to the directory where you keep your projects, and git
clone the project repository. If you haven’t done so already, it may also be helpful to
create a notedly directory to keep the project code organized:
$ cd Projects
# only run the following mkdir command if you do not yet have a notedly directory
$ mkdir notedly
$ cd notedly
$ git clone git@github.com:javascripteverywhere/api.git
$ cd api
Lastly, you’ll need to update your environment variables by making a copy of
the .sample.env file and populating the information in the newly created .env file.
In your terminal, run:
$ cp .env.example .env
Now, in your text editor, update the values of the .env file:
## Database
DB_HOST=mongodb://localhost:27017/notedly
TEST_DB=mongodb://localhost:27017/notedly-test
## Authentication
JWT_SECRET=YOUR_PASSWORD
311
Finally, you can start the API. In your terminal, run:
$ npm start
After working through these instructions, you should have a copy of the Notedly API
running locally on your system.
312 | Appendix A: Running the API Locally
APPENDIX B
Running the Web App Locally
If you’ve chosen to follow along with the Electron portion of the book, but not the
web development chapters, you will still need a copy of the web app running locally.
The first step is to ensure that you have a copy of the API running locally. If you
haven’t already, please reference Appendix A for running the API locally.
With your API up and running, you can clone a copy of the web app. To clone the
code to our local machine, open the terminal, navigate to the directory where you
keep your projects, and git clone the project repository:
$ cd Projects
# if keeping your projects in a notedly folder, cd into the notedly directory
$ cd notedly
$ git clone git@github.com:javascripteverywhere/web.git
$ cd web
Next, you’ll need to update your environment variables by making a copy of
the .sample.env file and populating the information in the newly created .env file.
In your terminal, run:
$ cp .env.example .env
Now, in your text editor, update the values of the .env file to make sure that it matches
the URL of your locally running API. If everything is kept at the default values, you
shouldn’t need to make any changes.
API_URI=http://localhost:4000/api
Finally, you can run the final web code example. In your terminal application, run:
$ npm run final
After working through these instructions, you should have a copy of the Notedly web
application running locally on your system.
313

Index
Symbols
.remove(), 69
<div> tag, 113
<Image>, 236
<Text>, 236
<view>, 236
A
AAB (Android App Bundle), 307
account creation flow, 55
Android App Bundle (AAB), 307
API (see application programming interface)
API deployment, 91-100
application code deployment, 97-100
hosting database, 91-97
project setup, 97-99
testing, 100
to Heroku's servers, 99
Apollo Client, 135-152
about, 135
dynamic queries, 148-150
GraphQL, 263-269
pagination, 150-152
querying an API, 138-147
setting up, 136
Apollo GraphQL platform, 88
Apollo Server
about, 17
resolver functions, 26
ApolloProvider, 137
app icons, 225, 303
app stores, distributing to, 308
app.json configuration, 301-303
app.listen, 15
appId, 224
application authentication flow, 55
application code deployment
project setup, 97-99
testing, 100
to Heroku's servers, 99
application programming interface (API), 9-12
about, 9-10
Electron, 213
getting started with, 11
GraphQL for, 10
integrating authentication into, 59-64
querying an, 138-147
running locally, 136, 311-312
turning server into an, 17-21
application styling, 121-133
adding global styles, 127
component styles, 129-132
creating a button component, 125-127
creating a layout component, 121-123
CSS, 124-132
CSS-in-JS, 124
args, defined, 26
arguments, 26
attaching headers to requests, 162
authenticated GraphQL queries, 289-293
authentication
mobile application, 273-299
resolvers, 61-64
routing flow, 273-282
user accounts and, 55-67
(see also user accounts and authentica‐
tion)
AuthenticationError, 70
315
authloading.js, 273
B
bcrypt, 57
browserWindow, 209
button component
creating a, 125-127
mobile application authentication, 285
C
Cascading Style Sheets (CSS), 124-132
adding global styles, 127
component styles, 129-132
creating a button component, 125-127
CSS-in-JS, 124
code signing, 226
collections, defined, 32
command-line prompts, terminal, 3
command-line tools (Mac only), 3
component styles, 129-132
conditional rendering, 151
content security policy (CSP), 219
context function
CRUD operations and, 47
defined, 27
CORS (cross-origin resource sharing), 84
create(), 40
create-react-app, 103
createBottomTabNavigator, 243
createSwitchNavigator, 275
cross-origin resource sharing (CORS), 84
CRUD operations, 45-53, 177-199
creating new notes, 177-183
date and time, 51-53
deleting notes, 193
reading user notes, 183-186
resolvers, 49-51
separating GraphQL schema and resolvers,
45-48
toggling favorites, 195-196
updating notes, 186-192
writing GraphQL CRUD schema, 49
CSP (content security policy), 219
CSS (see Cascading Style Sheets)
CSS-in-JS, 124
cursor-based pagination, 85
D
data limitations, 87
database, 31-44
about, 31
MongoDB, 32-37
reading/writing data from application,
37-44
DateTime function, 51-53
deleteNote mutation, 72, 193
deployment pipeline, 203-205
hosting source code with Git, 203
Netlify, 205
details, 83-89
Apollo GraphQL platform, 88
cross-origin resource sharing, 84
data limitations, 87
Express Helmet, 83
pagination, 84-87
subscriptions, 88
testing, 88
web application and express.js best practi‐
ces, 83
developer tools, 211
development environment, 1-8
about, 1
command-line tools and homebrew (Mac
only), 3
ESLint, 8
Expo, 7
Git, 6
installing and running MongoDB for
macOS, 6
installing and running MongoDB for Win‐
dows, 6
installing Node.js and NPM for macOS, 4
installing Node.js and NPM for Windows, 5
MongoDB, 5
navigating filesystem, 2
Node.js and NPM, 4
Prettier, 7
terminal, 2
text editor, 2
using a dedicated application, 2
VSCode, 2
distribution, mobile application, 301-308
dynamic queries, 148-150
E
Electron, 207-213
316 | Index
about, 207
API, 213
app icons, 225
building for current platform, 225
building for multiple platforms, 226
code signing, 226
configuration, 218
content security policy, 219
deployment, 223-227
developer tools, 211
developing, 209
Electron Builder, 223
getting started, 208
integrating an existing web application with,
215-222
integrating web application, 215-219
macOS application window details, 211
warnings and errors, 216-218
Electron Builder, 223
configuring, 224
Electron Forge, 224
Electron Security Warning (Insecure ContentSecurity-Policy), 218
Electron Security Warning (Insecure Resour‐
ces), 218
electron-util library, 211
emoji characters, 119
encrypting passwords, 57
errors, 216-218
ESLint, 8
Expo, 7
Expo Publish, 305
Express Helmet, 83
Express.js, 83
F
fetchMore, 150
filesystem, 2
find command, 32, 33
find(), 39
findOneAndUpdate(), 50
FlatList, 256
flexbox, 239
ForbiddenError, 70
formType, 294
G
Git, 6, 203
global styles, 127
GraphQL
about, 10
API, 17-30
Apollo Client, 263-269
CRUD operations, 45-48
mobile application authentication, 287-289
writing queries, 264-269
GraphQL API, 17-30
adapting API, 23-30
components of, 21
mutations, 23
queries, 23
resolvers, 23
schemas, 21
turning server into an API, 17-21
gravatar utility function, 61
H
hashing, 57
header, 58
Heroku's servers, 99
Homebrew, 3
hosting database, 91-97
htmlFor, 155
I
icons, mobile application shell, 251
info, defined, 27
iOS, 307
isLoggedIn state query, 190
J
jQuery, 102
JSON Web Tokens (JWT), 58, 161
JSX, 104
L
layout component, 121-123
limit(), 87
linking, 117
list
creating, 256-263
making a list routable, 261
loading indicator, 269-270
local state management, 163-165
localStorage, 161
logging out, 166-168
long-term support (LTS), 5
Index | 317
M
macOS
Electron and, 211
Heroku command-line tools, 97
MongoDB installation, 6
Node.js installation, 4
main process, 209
map(), 142
Markdown, 10
match.params, 148
mobile application authentication, 273-299
adding a sign-up form, 293-298
authenticated GraphQL queries, 289-293
authentication routing flow, 273-282
creating a sign-in form, 282-286
GraphQL mutations, 287-289
mobile application distribution, 301-308
Android, 307
app icons, 303
app stores, 308
app.json configuration, 301-303
creating Native builds, 306
Expo Publish, 305
icons and app loading screens, 303-305
iOS, 307
splash screens, 304
mobile application shell, 235-253
adding screen titles, 249
icons, 251
React Native building blocks, 235-237
routing, 242-250
stack navigation, 245-248
style and styled components, 237-241
tabbed routing with React Navigation,
242-244
module.exports(), 46
mongo command, 32
MongoDB, 5, 32-37
connecting, 34-37
getting started with, 32
macOS installation, 6
Windows installation, 6
MongoDB Atlas, 91
Mongoose Object Document Mapper (ODM),
34
Mongoose schema, 37
mutations, 23
CRUD operations and, 49
new note, 180
resolver for, 28
user schemas, 59
N
nested queries, 80-82
Netlify, 205
newNote, 28
and user parameters, 70
creating, 177-183
node index.js, 15
node src/index.js, 14
Node Version Manager (NVM), 4
Node.js, 4
macOS installation, 4
managing versions of, 4
Windows installation, 5
Nodemon, 14
note query, defined, 27
noteSchema, 37
NPM, 4
macOS installation, 4
Windows installation, 5
npm run dev, 19
NVM (Node Version Manager), 4
O
ODM (Mongoose Object Document Mapper),
34
offset pagination, 84
onChange function, 157
onClick handler, 151
P
pagination, 84-87, 150-152
Parcel, 110, 136
parent, defined, 26
passwords
encrypting, 57
MongoDB, 96
password reset flow, 56
payload, 58
permissions, user, 72
PowerShell, 2
(see also terminal)
Prettier, 7
productName, 224
protected routes, 173
318 | Index
Q
queries, 23
GraphQL, 264-269
nested, 80-82
R
react forms, 157
React Native, 229-234
about, 229-231
adding a loading indicator, 269-270
creating list and scrollable content views,
256-263
getting started, 231-234
making a list routable, 261
mobile application shell, 235-237
React Navigation, 242-244
reading user notes, 183-186
redirects, 162
refetchQueries, 181
Representational State Transfer (REST), 10
resetStore function, 167
resizeMode, 304
resolvers, 23
adding the user to the, 64-67
Apollo Server functions, 26
CRUD, 49-51
CRUD operations separating schemas from,
45-48
mutations, 23, 28
pagination and, 85
queries, 23
REST (Representational State Transfer), 10
root <div>, 112
routing
adding screen titles, 249
stack navigation, 245-248
tabbed, 242-244
tabbed routing with React Navigation,
242-244
web client building, 114-117
S
salting, 57
scalar type, creating custom, 51
schemas
CRUD operations separating resolvers from,
45-48
GraphQL API, 21
Mongoose, 37
screen titles, 249
scrollable content views, 256-263
ScrollView, 259
SectionList, 256
SecureStore library, 274
security, local storage and, 161
sessions, JSON Web Tokens vs., 59
settings.js, 274
sign-in forms, 168-173, 282-286
sign-up forms, 153-161
JSON Web Token and local storage, 161
mobile application authentication, 293-298
react forms and state, 157
signUp mutation, 158-160
signature, 58
signIn mutation, 63
signin.js, 274
signUp mutation, 61, 158-160
splash screens, 304
stack navigation, 245-248, 276
state
about, 107
web authentication and (see web authentica‐
tion and state)
static websites, 201
storeToken, 288
Styled Components, 125, 237-241
styling, 121-133
subscriptions, 88
SyntaxError, 217
T
tabbed routing, 242-244
terminal, 2
navigating filesystem, 2
using a dedicated application, 2
VSCode, 2
testing, 88
about, 88
API deployment, 100
textarea form, 177
timestamps, 51-53
toggleFavorite, 76-80, 77, 195-196
U
UI (see user interfaces)
universal Javascript, 202
updateNote mutation, 50, 72, 186-192
Index | 319
updateQuery, 152
use command, 32
useApolloClient, 159, 163
useEffect, 116
useMutation, 159, 189
user accounts and authentication, 55-67
adding the user to the resolver context,
64-67
application authentication flow, 55
authentication resolvers, 61-64
core concepts, 56-59
encrypting passwords, 57
integrating authentication into API, 59-64
JSON web tokens, 58
user schemas, 59-61
user actions, 69-82
about, 69
attaching a user to new notes, 70-72
nested queries, 80-82
toggling note favorites, 76-80
user permissions for updates and deletes, 72
user queries, 73-76
user interfaces (UI), 101-108
declarative interfaces with JavaScript, 103
history, 102
React library and building, 103-108
role of, 56
web client building, 118-120
user permissions, 72
user queries, 73-76
user schemas, 59-61
user sign-in flow, 56
useState component, 106, 283
V
Visual Studio Code (VSCode), 2
W
warnings and errors, 216-218
web application
best practices, 83
building, 13-16
deployment, 201-206
running locally, 313-313
web application building, 13-16
extending port options, 15
Hello World, 13
Nodemon, 14
web client building, 112
web application deployment, 201-206
deployment pipeline, 203-205
hosting source code with Git, 203
Netlify, 205
static websites, 201
web authentication and state, 153-175
attaching headers to requests, 162
JSON Web Token and local storage, 161
local state management, 163-165
logging out, 166-168
protected routes, 173
react forms, 157
redirects, 162
sign-in form creation, 168-173
sign-up form creation, 153-161
signUp mutation, 158-160
web client building, 109-120
about, 109
building out the web application, 112
getting started, 110-112
linking, 117
routing, 114-117
UI components, 118-120
whitespace, 144
Windows
creating Native build, 307
Heroku command-line tools, 97
MongoDB installation, 6
Node.js installation, 5
withRouter, 167
X
Xcode, 3
320 | Index
About the Author
Adam D. Scott is an engineering manager, web developer, and educator based in
Connecticut. He currently works as the Web Development Lead at the Consumer
Financial Protection Bureau, where he focuses on building open source web applica‐
tions with his talented team. Additionally, he has worked in education for over a dec‐
ade, teaching and writing curriculum on a range of technical topics. He is the author
of WordPress for Education (Packt, 2012), the Introduction to Modern Front-End
Development video course (O’Reilly, 2015), and the Ethical Web Development report
series (O’Reilly, 2016–2017).
Colophon
The animal on the cover of JavaScript Everywhere is a common bronze-winged dove
(Phaps chalcoptera), one of the most common members of the Columbidae family liv‐
ing in Australia. These birds are scattered throughout the continent in a wide range of
habitats and will most likely be found foraging on the ground for the seeds of acacia
shrubs.
Bronzewings are cautious birds—the slightest disturbance will trigger them to flap
their wings in a loud flurry and retreat to the nearest mulga tree. On a bright day,
sunlight will reveal iridescent patches of bronze and green on their wings. A yellow
and white forehead with a pink breast indicates a male, while females have a light
gray forehead and breast. Both, however, have a stark white line that curves from
under their eyes toward the back of their nape.
A bronzewing nest measures about 10 inches across and 4 inches deep, just large
enough to fit the two smooth, white eggs that are laid concurrently. After about 14–16
days, during which both parents incubate the eggs, they will hatch. Unlike most birds,
both sexes of bronzewings share the responsibility of feeding their young, which
involves secreting a milk-like substance from their “crop,” a muscular pouch near the
throat that is used for food storage.
While the bronze-winged dove’s current conservation status is designated as of Least
Concern, many of the animals on O’Reilly covers are endangered; all of them are
important to the world.
The cover illustration is by Karen Montgomery, based on a black and white engraving
from Lydekker’s Royal Natural History. The cover fonts are Gilroy Semibold and
Guardian Sans. The text font is Adobe Minion Pro; the heading font is Adobe Myriad
Condensed; and the code font is Dalton Maag’s Ubuntu Mono.
There’s much more
where this came from.
Experience books, videos, live online
training courses, and more from O’Reilly
and our 200+ partners—all in one place.
Learn more at oreilly.com/online-learning
©2019 O’Reilly Media, Inc. O’Reilly is a registered trademark of O’Reilly Media, Inc. | 175

1. Preface
a. Conventions Used in This Book
b. Using Code Examples
c. O’Reilly Online Learning
d. How to Contact Us
e. Acknowledgments
2. 1. Welcome to React
a. A Strong Foundation
b. React’s Past and Future
i. Learning React: Second Edition Changes
c. Working with the Files
i. File Repository
ii. React Developer Tools
iii. Installing Node.js
3. 2. JavaScript for React
a. Declaring Variables
i. The const Keyword
ii. The let Keyword
iii. Template Strings
b. Creating Functions
i. Function Declarations
ii. Function Expressions
iii. Default Parameters
iv. Arrow Functions
c. Compiling JavaScript
d. Objects and Arrays
i. Destructuring Objects
ii. Destructuring Arrays
iii. Object Literal Enhancement
iv. The Spread Operator
e. Asynchronous JavaScript
i. Simple Promises with Fetch
ii. Async/Await
iii. Building Promises
f. Classes
g. ES6 Modules
i. CommonJS
4. 3. Functional Programming with JavaScript
a. What It Means to Be Functional
b. Imperative Versus Declarative
c. Functional Concepts
i. Immutability
ii. Pure Functions
iii. Data Transformations
iv. Higher-Order Functions
v. Recursion
vi. Composition
vii. Putting It All Together
5. 4. How React Works
a. Page Setup
b. React Elements
c. ReactDOM
i. Children
d. React Components
i. React Components: A Historical Tour
6. 5. React with JSX
a. React Elements as JSX
i. JSX Tips
ii. Mapping Arrays with JSX
b. Babel
c. Recipes as JSX
d. React Fragments
e. Intro to webpack
i. Creating the Project
ii. Loading the Bundle
iii. Source Mapping
iv. Create React App
7. 6. React State Management
a. Building a Star Rating Component
b. The useState Hook
c. Refactoring for Advanced Reusability
d. State in Component Trees
i. Sending State Down a Component Tree
ii. Sending Interactions Back up a
Component Tree
e. Building Forms
i. Using Refs
ii. Controlled Components
iii. Creating Custom Hooks
iv. Adding Colors to State
f. React Context
i. Placing Colors in Context
ii. Retrieving Colors with useContext
iii. Stateful Context Providers
iv. Custom Hooks with Context
8. 7. Enhancing Components with Hooks
a. Introducing useEffect
i. The Dependency Array
ii. Deep Checking Dependencies
iii. When to useLayoutEffect
iv. Rules to Follow with Hooks
v. Improving Code with useReducer
vi. useReducer to Handle Complex State
vii. Improving Component Performance
viii. shouldComponentUpdate and
PureComponent
ix. When to Refactor
9. 8. Incorporating Data
a. Requesting Data
i. Sending Data with a Request
ii. Uploading Files with fetch
iii. Authorized Requests
iv. Saving Data Locally
v. Handling Promise States
b. Render Props
c. Virtualized Lists
i. Creating a Fetch Hook
ii. Creating a Fetch Component
iii. Handling Multiple Requests
iv. Memozing Values
v. Waterfall Requests
vi. Throttling the Network Speed
vii. Parallel Requests
viii. Waiting for Values
ix. Canceling Requests
d. Introducing GraphQL
i. GitHub GraphQL API
ii. Making a GraphQL Request
10. 9. Suspense
a. Error Boundaries
b. Code Splitting
i. Introducing: The Suspense Component
ii. Using Suspense with Data
iii. Throwing Promises
iv. Building Suspenseful Data Sources
v. Fiber
11. 10. React Testing
a. ESLint
i. ESLint Plug-Ins
b. Prettier
i. Configuring Prettier by Project
ii. Prettier in VSCode
c. Typechecking for React Applications
i. PropTypes
ii. Flow
iii. TypeScript
d. Test-Driven Development
i. TDD and Learning
e. Incorporating Jest
i. Create React App and Testing
f. Testing React Components
i. Queries
ii. Testing Events
iii. Using Code Coverage
12. 11. React Router
a. Incorporating the Router
b. Router Properties
i. Nesting Routes
c. Using Redirects
i. Routing Parameters
13. 12. React and the Server
a. Isomorphic Versus Universal
i. Client and Server Domains
b. Server Rendering React
c. Server Rendering with Next.js
d. Gatsby
e. React in the Future
14. Index
Learning React
SECOND EDITION
Modern Patterns for Developing React Apps
Alex Banks and Eve Porcello
Learning React
by Alex Banks and Eve Porcello
Copyright © 2020 Alex Banks and Eve Porcello. All rights reserved.
Printed in the United States of America.
Published by O’Reilly Media, Inc., 1005 Gravenstein Highway North,
Sebastopol, CA 95472.
O’Reilly books may be purchased for educational, business, or sales
promotional use. Online editions are also available for most titles
(http://oreilly.com). For more information, contact our
corporate/institutional sales department: 800-998-9938 or
corporate@oreilly.com.
Acquisitions Editor: Jennifer Pollock
Development Editor: Angela Rufino
Production Editor: Kristen Brown
Copyeditor: Holly Bauer Forsyth
Proofreader: Abby Wheeler
Indexer: Judith McConville
Interior Designer: David Futato
Cover Designer: Karen Montgomery
Illustrator: Rebecca Demarest
May 2017: First Edition
June 2020: Second Edition
Revision History for the Second Edition
2020-06-12: First Release
See http://oreilly.com/catalog/errata.csp?isbn=9781492051725 for
release details.
The O’Reilly logo is a registered trademark of O’Reilly Media, Inc.
Learning React, the cover image, and related trade dress are trademarks
of O’Reilly Media, Inc.
The views expressed in this work are those of the authors, and do not
represent the publisher’s views. While the publisher and the authors
have used good faith efforts to ensure that the information and
instructions contained in this work are accurate, the publisher and the
authors disclaim all responsibility for errors or omissions, including
without limitation responsibility for damages resulting from the use of
or reliance on this work. Use of the information and instructions
contained in this work is at your own risk. If any code samples or other
technology this work contains or describes is subject to open source
licenses or the intellectual property rights of others, it is your
responsibility to ensure that your use thereof complies with such
licenses and/or rights.
978-1-492-05172-5
[LSI]
Preface
This book is for developers who want to learn the React library while
learning the latest techniques currently emerging in the JavaScript
language. This is an exciting time to be a JavaScript developer. The
ecosystem is exploding with new tools, syntax, and best practices that
promise to solve many of our development problems. Our aim with this
book is to organize these techniques so you can get to work with React
right away. We’ll get into state management, React Router, testing, and
server rendering, so we promise not to introduce only the basics and
then throw you to the wolves.
This book does not assume any knowledge of React at all. We’ll
introduce all of React’s basics from scratch. Similarly, we won’t
assume that you’ve worked with the latest JavaScript syntax. This will
be introduced in Chapter 2 as a foundation for the rest of the chapters.
You’ll be better prepared for the contents of the book if you’re
comfortable with HTML, CSS, and JavaScript. It’s almost always best
to be comfortable with these big three before diving into a JavaScript
library.
Along the way, check out the GitHub repository. All of the examples
are there and will allow you to practice hands-on.
Conventions Used in This Book
The following typographical conventions are used in this book:
Italic
Indicates new terms, URLs, email addresses, filenames, and file
extensions.
Constant width
Used for program listings, as well as within paragraphs to refer to
program elements such as variable or function names, databases,
data types, environment variables, statements, and keywords.
Constant width bold
Shows commands or other text that should be typed literally by the
user.
TIP
This element signifies a tip or suggestion.
NOTE
This element signifies a general note.
WARNING
This element indicates a warning or caution.
Using Code Examples
Supplemental material (code examples, exercises, etc.) is available for
download at https://github.com/moonhighway/learning-react.
If you have a technical question or a problem using the code examples,
please send email to bookquestions@oreilly.com.
This book is here to help you get your job done. In general, if example
code is offered with this book, you may use it in your programs and
documentation. You do not need to contact us for permission unless
you’re reproducing a significant portion of the code. For example,
writing a program that uses several chunks of code from this book does
not require permission. Selling or distributing examples from O’Reilly
books does require permission. Answering a question by citing this
book and quoting example code does not require permission.
Incorporating a significant amount of example code from this book into
your product’s documentation does require permission.
We appreciate, but generally do not require, attribution. An attribution
usually includes the title, author, publisher, and ISBN. For example:
“Learning React by Alex Banks and Eve Porcello (O’Reilly).
Copyright 2020 Alex Banks and Eve Porcello, 978-1-492-05172-5.”
If you feel your use of code examples falls outside fair use or the
permission given above, feel free to contact us at
permissions@oreilly.com.
O’Reilly Online Learning
NOTE
For more than 40 years, O’Reilly Media has provided technology and business
training, knowledge, and insight to help companies succeed.
Our unique network of experts and innovators share their knowledge
and expertise through books, articles, and our online learning platform.
O’Reilly’s online learning platform gives you on-demand access to live
training courses, in-depth learning paths, interactive coding
environments, and a vast collection of text and video from O’Reilly
and 200+ other publishers. For more information, visit
http://oreilly.com.
How to Contact Us
Please address comments and questions concerning this book to the
publisher:
O’Reilly Media, Inc.
1005 Gravenstein Highway North
Sebastopol, CA 95472
800-998-9938 (in the United States or Canada)
707-829-0515 (international or local)
707-829-0104 (fax)
We have a web page for this book, where we list errata, examples, and
any additional information. You can access this page at
https://oreil.ly/learningReact_2e.
Email bookquestions@oreilly.com to comment or ask technical
questions about this book.
For news and information about our books and courses, visit
http://oreilly.com.
Find us on Facebook: http://facebook.com/oreilly
Follow us on Twitter: http://twitter.com/oreillymedia
Watch us on YouTube: http://www.youtube.com/oreillymedia
Acknowledgments
Our journey with React wouldn’t have started without some good oldfashioned luck. We used YUI when we created the training materials
for the full-stack JavaScript program we taught internally at Yahoo.
Then in August 2014, development on YUI ended. We had to change
all our course files, but to what? What were we supposed to use on the
front-end now? The answer: React. We didn’t fall in love with React
immediately; it took us a couple hours to get hooked. It looked like
React could potentially change everything. We got in early and got
really lucky.
We appreciate the help of Angela Rufino and Jennifer Pollock for all
the support in developing this second edition. We also want to
acknowledge Ally MacDonald for all her editing help in the first
edition. We’re grateful to our tech reviewers, Scott Iwako, Adam
Rackis, Brian Sletten, Max Firtman, and Chetan Karande.
There’s also no way this book could have existed without Sharon
Adams and Marilyn Messineo. They conspired to purchase Alex’s first
computer, a Tandy TRS 80 Color Computer. It also wouldn’t have
made it to book form without the love, support, and encouragement of
Jim and Lorri Porcello and Mike and Sharon Adams.
We’d also like to acknowledge Coffee Connexion in Tahoe City,
California, for giving us the coffee we needed to finish this book, and
its owner, Robin, who gave us the timeless advice: “A book on
programming? Sounds boring!”
Chapter 1. Welcome to React
What makes a JavaScript library good? Is it the number of stars on
GitHub? The number of downloads on npm? Is the number of tweets
that ThoughtLeaders™ write about it on a daily basis important? How
do we pick the best tool to use to build the best thing? How do we
know it’s worth our time? How do we know it’s good?
When React was first released, there was a lot of conversation around
whether it was good, and there were many skeptics. It was new, and the
new can often be upsetting.
To respond to these critiques, Pete Hunt from the React team wrote an
article called “Why React?” that recommended that you “give it
[React] five minutes.” He wanted to encourage people to work with
React first before thinking that the team’s approach was too wild.
Yes, React is a small library that doesn’t come with everything you
might need out of the box to build your application. Give it five
minutes.
Yes, in React, you write code that looks like HTML right in your
JavaScript code. And yes, those tags require preprocessing to run in a
browser. And you’ll probably need a build tool like webpack for that.
Give it five minutes.
As React approaches a decade of use, a lot of teams decided that it’s
good because they gave it five minutes. We’re talking Uber, Twitter,
Airbnb, and Twitter—huge companies that tried React and realized that
it could help teams build better products faster. At the end of the day,
isn’t that what we’re all here for? Not for the tweets. Not for the stars.
Not for the downloads. We’re here to build cool stuff with tools that
we like to use. We’re here for the glory of shipping stuff that we’re
proud to say we built. If you like doing those types of things, you’ll
probably like working with React.
A Strong Foundation
Whether you’re brand new to React or looking to this text to learn
some of the latest features, we want this book to serve as a strong
foundation for all your future work with the library. The goal of this
book is to avoid confusion in the learning process by putting things in a
sequence: a learning roadmap.
Before digging into React, it’s important to know JavaScript. Not all of
JavaScript, not every pattern, but having a comfort with arrays, objects,
and functions before jumping into this book will be useful.
In the next chapter, we’ll look at newer JavaScript syntax to get you
acquainted with the latest JavaScript features, especially those that are
frequently used with React. Then we’ll give an introduction to
functional JavaScript so you can understand the paradigm that gave
birth to React. A nice side effect of working with React is that it can
make you a stronger JavaScript developer by promoting patterns that
are readable, reusable, and testable. Sort of like a gentle, helpful
brainwashing.
From there, we’ll cover foundational React knowledge to understand
how to build out a user interface with components. Then we’ll learn to
compose these components and add logic with props and state. We’ll
cover React Hooks, which allow us to reuse stateful logic between
components.
Once the basics are in place, we’ll build a new application that allows
users to add, edit, and delete colors. We’ll learn how Hooks and
Suspense can help us with data fetching. Throughout the construction
of that app, we’ll introduce a variety of tools from the broader React
ecosystem that are used to handle common concerns like routing,
testing, and server-side rendering.
We hope to get you up to speed with the React ecosystem faster by
approaching it this way—not just to scratch the surface, but to equip
you with the tools and skills necessary to build real-world React
applications.
React’s Past and Future
React was first created by Jordan Walke, a software engineer at
Facebook. It was incorporated into Facebook’s newsfeed in 2011 and
later on Instagram when it was acquired by Facebook in 2012. At
JSConf 2013, React was made open source, and it joined the crowded
category of UI libraries like jQuery, Angular, Dojo, Meteor, and others.
At that time, React was described as “the V in MVC.” In other words,
React components acted as the view layer or the user interface for your
JavaScript applications.
From there, community adoption started to spread. In January 2015,
Netflix announced that they were using React to power their UI
development. Later that month, React Native, a library for building
mobile applications using React, was released. Facebook also released
ReactVR, another tool that brought React to a broader range of
rendering targets. In 2015 and 2016, a huge number of popular tools
like React Router, Redux, and Mobx came on the scene to handle tasks
like routing and state management. After all, React was billed as a
library: concerned with implementing a specific set of features, not
providing a tool for every use case.
Another huge event on the timeline was the release of React Fiber in
2017. Fiber was a rewrite of React’s rendering algorithm that was sort
of magical in its execution. It was a full rewrite of React’s internals that
changed barely anything about the public API. It was a way of making
React more modern and performant without affecting its users.
More recently in 2019, we saw the release of Hooks, a new way of
adding and sharing stateful logic across components. We also saw the
release of Suspense, a way to optimize asynchronous rendering with
React.
In the future, we’ll inevitably see more change, but one of the reasons
for React’s success is the strong team that has worked on the project
over the years. The team is ambitious yet cautious, pushing forwardthinking optimizations while constantly considering the impact any
changes to the library will send cascading through the community.
As changes are made to React and related tools, sometimes there are
breaking changes. In fact, future versions of these tools may break
some of the example code in this book. You can still follow along with
the code samples. We’ll provide exact version information in the
package.json file so that you can install these packages at the correct
version.
Beyond this book, you can stay on top of changes by following along
with the official React blog. When new versions of React are released,
the core team will write a detailed blog post and changelog about
what’s new. The blog has also been translated into an ever-expanding
list of languages, so if English isn’t your native language, you can find
localized versions of the docs on the languages page of the docs site.
Learning React: Second Edition Changes
This is the second edition of Learning React. We felt it was important
to update the book because React has evolved quite a bit over the past
few years. We intend to focus on all the current best practices that are
advocated by the React team, but we’ll also share information about
deprecated React features. There’s a lot of React code that was written
years ago using old styles that still works well and must be maintained.
In all cases, we’ll make mention of these features in a sidebar in case
you find yourself working with legacy React applications.
Working with the Files
In this section, we’ll discuss how to work with the files for this book
and how to install some useful React tools.
File Repository
The GitHub repository associated with this book provides all the code
files organized by chapter.
React Developer Tools
We’d highly recommend installing React Developer Tools to support
your work on React projects. These tools are available as a browser
extension for Chrome and Firefox and as a standalone app for use with
Safari, IE, and React Native. Once you install the dev tools, you’ll be
able to inspect the React component tree, view props and state details,
and even view which sites are currently using React in production.
These are really useful when debugging and when learning about how
React is used in other projects.
To install, head over to the GitHub repository. There, you’ll find links
to the Chrome and Firefox extensions.
Once installed, you’ll be able to see which sites are using React.
Anytime the React icon is illuminated in the browser toolbar as shown
in Figure 1-1, you’ll know that the site has React on the page.
Figure 1-1. Viewing the React Developer Tools in Chrome
Then, when you open the developer tools, there will be a new tab
visible called React, as shown in Figure 1-2. Clicking on that will show
all the components that make up the page you’re currently viewing.
Figure 1-2. Inspecting the DOM with the React Developer Tools
Installing Node.js
Node.js is a JavaScript runtime environment used to build full-stack
applications. Node is open source and can be installed on Windows,
macOS, Linux, and other platforms. We’ll be using Node in Chapter 12
when we build an Express server.
You need to have Node installed, but you do not need to be a Node
expert in order to use React. If you’re not sure if Node.js is installed on
your machine, you can open a Terminal or Command Prompt window
and type:
node -v
When you run this command, you should see a node version number
returned to you, ideally 8.6.2 or higher. If you type the command and
see an error message that says “Command not found,” Node.js is not
installed. This is easily fixed by installing Node.js from the Node.js
website. Just go through the installer’s automated steps, and when you
type in the node -v command again, you’ll see the version number.
NPM
When you installed Node.js, you also installed npm, the Node package
manager. In the JavaScript community, engineers share open source
code projects to avoid having to rewrite frameworks, libraries, or
helper functions on their own. React itself is an example of a useful
npm library. We’ll use npm to install a variety of packages throughout
this book.
Most JavaScript projects you encounter today will contain an assorted
collection of files plus a package.json file. This file describes the
project and all its dependencies. If you run npm install in the folder
that contains the package.json file, npm will install all the packages
listed in the project.
If you’re starting your own project from scratch and want to include
dependencies, simply run the command:
npm init -y
This will initialize the project and create a package.json file. From
there, you can install your own dependencies with npm. To install a
package with npm, you’ll run:
npm install package-name
To remove a package with npm, you’ll run:
npm remove package-name
YARN
An alternative to npm is Yarn. It was released in 2016 by Facebook in
collaboration with Exponent, Google, and Tilde. The project helps
Facebook and other companies manage their dependencies reliably. If
you’re familiar with the npm workflow, getting up to speed with Yarn
is fairly simple. First, install Yarn globally with npm:
npm install -g yarn
Then, you’re ready to install packages. When installing dependencies
from package.json, in place of npm install, you can run yarn.
To install a specific package with yarn, run:
yarn add package-name
To remove a dependency, the command is familiar, too:
yarn remove package-name
Yarn is used in production by Facebook and is included in projects like
React, React Native, and Create React App. If you ever find a project
that contains a yarn.lock file, the project uses yarn. Similar to the npm
install command, you can install all the dependencies of the project
by typing yarn.
Now that you have your environment set up for React development,
you’re ready to start walking the path of learning React. In Chapter 2,
we’ll get up to speed with the latest JavaScript syntax that’s most
commonly found in React code.
Chapter 2. JavaScript for
React
Since its release in 1995, JavaScript has gone through many changes.
At first, we used JavaScript to add interactive elements to web pages:
button clicks, hover states, form validation, etc.. Later, JavaScript got
more robust with DHTML and AJAX. Today, with Node.js, JavaScript
has become a real software language that’s used to build full-stack
applications. JavaScript is everywhere.
JavaScript’s evolution has been guided by a group of individuals from
companies that use JavaScript, browser vendors, and community
leaders. The committee in charge of shepherding the changes to
JavaScript over the years is the European Computer Manufacturers
Association (ECMA). Changes to the language are community-driven,
originating from proposals written by community members. Anyone
can submit a proposal to the ECMA committee. The responsibility of
the ECMA committee is to manage and prioritize these proposals to
decide what’s included in each spec.
The first release of ECMAScript was in 1997, ECMAScript1. This was
followed in 1998 by ECMAScript2. ECMAScript3 came out in 1999,
adding regular expressions, string handling, and more. The process of
agreeing on an ECMAScript4 became a chaotic, political mess that
proved to be impossible. It was never released. In 2009,
ECMAScript5(ES5) was released, bringing features like new array
methods, object properties, and library support for JSON.
Since then, there has been a lot more momentum in this space. After
ES6 or ES2015 was released in, yes, 2015, there have been yearly
releases of new JS features. Anything that’s part of the stage proposals
is typically called ESNext, which is a simplified way of saying this is
the next stuff that will be part of the JavaScript spec.
Proposals are taken through clearly defined stages, from stage 0, which
represents the newest proposals, up through stage 4, which represents
the finished proposals. When a proposal gains traction, it’s up to the
browser vendors like Chrome and Firefox to implement the features.
Consider the const keyword. When creating variables, we used to use
var in all cases. The ECMA committee decided there should be a
const keyword to declare constants (more on that later in the chapter).
When const was first introduced, you couldn’t just write const in
JavaScript code and expect it to run in a browser. Now you can
because browser vendors have changed the browser to support it.
Many of the features we’ll discuss in this chapter are already supported
by the newest browsers, but we’ll also be covering how to compile
your JavaScript code. This is the process of transforming new syntax
that the browser doesn’t recognize into older syntax that the browser
understands. The kangax compatibility table is a great place to stay
informed about the latest JavaScript features and their varying degrees
of support by browsers.
In this chapter, we’ll show you all the JavaScript syntax we’ll be using
throughout the book. We hope to provide a good baseline of JavaScript
syntax knowledge that will carry you through all of your work with
React. If you haven’t made the switch to the latest syntax yet, now
would be a good time to get started. If you’re already comfortable with
the latest language features, skip to the next chapter.
Declaring Variables
Prior to ES2015, the only way to declare a variable was with the var
keyword. We now have a few different options that provide improved
functionality.
The const Keyword
A constant is a variable that cannot be overwritten. Once declared, you
cannot change its value. A lot of the variables that we create in
JavaScript should not be overwritten, so we’ll be using const a lot.
Like other languages had done before it, JavaScript introduced
constants with ES6.
Before constants, all we had were variables, and variables could be
overwritten:
var pizza = true;
pizza = false;
console.log(pizza); // false
We cannot reset the value of a constant variable, and it will generate a
console error (as shown in Figure 2-1) if we try to overwrite the value:
const pizza = true;
pizza = false;
Figure 2-1. An attempt at overwriting a constant
The let Keyword
JavaScript now has lexical variable scope. In JavaScript, we create
code blocks with curly braces ({}). In functions, these curly braces
block off the scope of any variable declared with var. On the other
hand, consider if/else statements. If you’re coming from other
languages, you might assume that these blocks would also block
variable scope. This was not the case until let came along.
If a variable is created inside of an if/else block, that variable is not
scoped to the block:
var topic = "JavaScript";
if (topic) {
var topic = "React";
console.log("block", topic); // block React
}
console.log("global", topic); // global React
The topic variable inside the if block resets the value of topic
outside of the block.
With the let keyword, we can scope a variable to any code block.
Using let protects the value of the global variable:
var topic = "JavaScript";
if (topic) {
let topic = "React";
console.log("block", topic); // React
}
console.log("global", topic); // JavaScript
The value of topic is not reset outside of the block.
Another area where curly braces don’t block off a variable’s scope is in
for loops:
var div,
container = document.getElementById("container");
for (var i = 0; i < 5; i++) {
div = document.createElement("div");
div.onclick = function() {
alert("This is box #" + i);
};
container.appendChild(div);
}
In this loop, we create five divs to appear within a container. Each div
is assigned an onclick handler that creates an alert box to display the
index. Declaring i in the for loop creates a global variable named i,
then iterates over it until its value reaches 5. When you click on any of
these boxes, the alert says that i is equal to 5 for all divs, because the
current value for the global i is 5 (see Figure 2-2).
Figure 2-2. i is equal to 5 for each box
Declaring the loop counter i with let instead of var does block off the
scope of i. Now clicking on any box will display the value for i that
was scoped to the loop iteration (see Figure 2-3):
const container = document.getElementById("container");
let div;
for (let i = 0; i < 5; i++) {
div = document.createElement("div");
div.onclick = function() {
alert("This is box #: " + i);
};
container.appendChild(div);
}
Figure 2-3. The scope of i is protected with let
The scope of i is protected with let.
Template Strings
Template strings provide us with an alternative to string concatenation.
They also allow us to insert variables into a string. You’ll hear these
referred to as template strings, template literals, or string templates
interchangeably.
Traditional string concatenation uses plus signs to compose a string
using variable values and strings:
console.log(lastName + ", " + firstName + " " + middleName);
With a template, we can create one string and insert the variable values
by surrounding them with ${ }:
console.log(`${lastName}, ${firstName} ${middleName}`);
Any JavaScript that returns a value can be added to a template string
between the ${ } in a template string.
Template strings honor whitespace, making it easier to draft up email
templates, code examples, or anything else that contains whitespace.
Now you can have a string that spans multiple lines without breaking
your code:
const email = `
Hello ${firstName},
Thanks for ordering ${qty} tickets to ${event}.
Order Details
${firstName} ${middleName} ${lastName}
${qty} x $${price} = $${qty*price} to ${event}
You can pick your tickets up 30 minutes before
the show.
Thanks,
${ticketAgent}
`
Previously, using an HTML string directly in our JavaScript code was
not so easy to do because we’d need to run it together on one line. Now
that the whitespace is recognized as text, you can insert formatted
HTML that is easy to read and understand:
document.body.innerHTML = `
<section>
<header>
<h1>The React Blog</h1>
</header>
<article>
<h2>${article.title}</h2>
${article.body}
</article>
<footer>
<p>copyright ${new Date().getYear()} | The React Blog</p>
</footer>
</section>
`;
Notice that we can include variables for the page title and article text as
well.
Creating Functions
Any time you want to perform some sort of repeatable task with
JavaScript, you can use a function. Let’s take a look at some of the
different syntax options that can be used to create a function and the
anatomy of those functions.
Function Declarations
A function declaration or function definition starts with the function
keyword, which is followed by the name of the function,
logCompliment. The JavaScript statements that are part of the function
are defined between the curly braces:
function logCompliment() {
console.log("You're doing great!");
}
Once you’ve declared the function, you’ll invoke or call it to see it
execute:
function logCompliment() {
console.log("You're doing great!");
}
logCompliment();
Once invoked, you’ll see the compliment logged to the console.
Function Expressions
Another option is to use a function expression. This just involves
creating the function as a variable:
const logCompliment = function() {
console.log("You're doing great!");
};
logCompliment();
The result is the same, and You're doing great! is logged to the
console.
One thing to be aware of when deciding between a function declaration
and a function expression is that function declarations are hoisted and
function expressions are not. In other words, you can invoke a function
before you write a function declaration. You cannot invoke a function
created by a function expression. This will cause an error. For example:
// Invoking the function before it's declared
hey();
// Function Declaration
function hey() {
alert("hey!");
}
This works. You’ll see the alert appear in the browser. It works
because the function is hoisted, or moved up, to the top of the file’s
scope. Trying the same exercise with a function expression will cause
an error:
// Invoking the function before it's declared
hey();
// Function Expression
const hey = function() {
alert("hey!");
};
TypeError: hey is not a function
This is obviously a small example, but this TypeError can occasionally
arise when importing files and functions in a project. If you see it, you
can always refactor as a declaration.
PASSING ARGUMENTS
The logCompliment function currently takes in no arguments or
parameters. If we want to provide dynamic variables to the function,
we can pass named parameters to a function simply by adding them to
the parentheses. Let’s start by adding a firstName variable:
const logCompliment = function(firstName) {
console.log(`You're doing great, ${firstName}`);
};
logCompliment("Molly");
Now when we call the logCompliment function, the firstName value
sent will be added to the console message.
We could add to this a bit by creating another argument called
message. Now, we won’t hard-code the message. We’ll pass in a
dynamic value as a parameter:
const logCompliment = function(firstName, message) {
console.log(`${firstName}: ${message}`);
};
logCompliment("Molly", "You're so cool");
FUNCTION RETURNS
The logCompliment function currently logs the compliment to the
console, but more often, we’ll use a function to return a value. Let’s
add a return statement to this function. A return statement specifies
the value returned by the function. We’ll rename the function
createCompliment:
const createCompliment = function(firstName, message) {
return `${firstName}: ${message}`;
};
createCompliment("Molly", "You're so cool");
If you wanted to check to see if the function is executing as expected,
just wrap the function call in a console.log:
console.log(createCompliment("You're so cool", "Molly"));
Default Parameters
Languages including C++ and Python allow developers to declare
default values for function arguments. Default parameters are included
in the ES6 spec, so in the event that a value is not provided for the
argument, the default value will be used.
For example, we can set up default strings for the parameters name and
activity:
function logActivity(name = "Shane McConkey", activity = "skiing") {
console.log(`${name} loves ${activity}`);
}
If no arguments are provided to the logActivity function, it will run
correctly using the default values. Default arguments can be any type,
not just strings:
const defaultPerson = {
name: {
first: "Shane",
last: "McConkey"
},
favActivity: "skiing"
};
function logActivity(person = defaultPerson) {
console.log(`${person.name.first} loves ${person.favActivity}`);
}
Arrow Functions
Arrow functions are a useful new feature of ES6. With arrow functions,
you can create functions without using the function keyword. You
also often do not have to use the return keyword. Let’s consider a
function that takes in a firstName and returns a string, turning the
person into a lord. Anyone can be a lord:
const lordify = function(firstName) {
return `${firstName} of Canterbury`;
};
console.log(lordify("Dale")); // Dale of Canterbury
console.log(lordify("Gail")); // Gail of Canterbury
With an arrow function, we can simplify the syntax tremendously:
const lordify = firstName => `${firstName} of Canterbury`;
With the arrow, we now have an entire function declaration on one
line. The function keyword is removed. We also remove return
because the arrow points to what should be returned. Another benefit is
that if the function only takes one argument, we can remove the
parentheses around the arguments.
More than one argument should be surrounded by parentheses:
// Typical function
const lordify = function(firstName, land) {
return `${firstName} of ${land}`;
};
// Arrow Function
const lordify = (firstName, land) => `${firstName} of ${land}`;
console.log(lordify("Don", "Piscataway")); // Don of Piscataway
console.log(lordify("Todd", "Schenectady")); // Todd of Schenectady
We can keep this as a one-line function because there is only one
statement that needs to be returned. If there are multiple lines, you’ll
use curly braces:
const lordify = (firstName, land) => {
if (!firstName) {
throw new Error("A firstName is required to lordify");
}
if (!land) {
throw new Error("A lord must have a land");
}
return `${firstName} of ${land}`;
};
console.log(lordify("Kelly", "Sonoma")); // Kelly of Sonoma
console.log(lordify("Dave")); // ! JAVASCRIPT ERROR
These if/else statements are surrounded with brackets but still
benefit from the shorter syntax of the arrow function.
RETURNING OBJECTS
What happens if you want to return an object? Consider a function
called person that builds an object based on parameters passed in for
firstName and lastName:
const person = (firstName, lastName) =>
{
first: firstName,
last: lastName
}
console.log(person("Brad", "Janson"));
As soon as you run this, you’ll see the error: Uncaught SyntaxError:
Unexpected token :. To fix this, just wrap the object you’re
returning with parentheses:
const person = (firstName, lastName) => ({
first: firstName,
last: lastName
});
console.log(person("Flad", "Hanson"));
These missing parentheses are the source of countless bugs in
JavaScript and React apps, so it’s important to remember this one!
ARROW FUNCTIONS AND SCOPE
Regular functions do not block this. For example, this becomes
something else in the setTimeout callback, not the tahoe object:
const tahoe = {
mountains: ["Freel", "Rose", "Tallac", "Rubicon", "Silver"],
print: function(delay = 1000) {
setTimeout(function() {
console.log(this.mountains.join(", "));
}, delay);
}
};
tahoe.print(); // Uncaught TypeError: Cannot read property 'join' of
undefined
This error is thrown because it’s trying to use the .join method on
what this is. If we log this, we’ll see that it refers to the Window
object:
console.log(this); // Window {}
To solve this problem, we can use the arrow function syntax to protect
the scope of this:
const tahoe = {
mountains: ["Freel", "Rose", "Tallac", "Rubicon", "Silver"],
print: function(delay = 1000) {
setTimeout(() => {
console.log(this.mountains.join(", "));
}, delay);
}
};
tahoe.print(); // Freel, Rose, Tallac, Rubicon, Silver
This works as expected, and we can .join the resorts with a comma.
Be careful that you’re always keeping scope in mind. Arrow functions
do not block off the scope of this:
const tahoe = {
mountains: ["Freel", "Rose", "Tallac", "Rubicon", "Silver"],
print: (delay = 1000) => {
setTimeout(() => {
console.log(this.mountains.join(", "));
}, delay);
}
};
tahoe.print(); // Uncaught TypeError: Cannot read property 'join' of
undefined
Changing the print function to an arrow function means that this is
actually the window.
Compiling JavaScript
When a new JavaScript feature is proposed and gains support, the
community often wants to use it before it’s supported by all browsers.
The only way to be sure that your code will work is to convert it to
more widely compatible code before running it in the browser. This
process is called compiling. One of the most popular tools for
JavaScript compilation is Babel.
In the past, the only way to use the latest JavaScript features was to
wait weeks, months, or even years until browsers supported them.
Now, Babel has made it possible to use the latest features of JavaScript
right away. The compiling step makes JavaScript similar to other
languages. It’s not quite traditional compiling: our code isn’t compiled
to binary. Instead, it’s transformed into syntax that can be interpreted
by a wider range of browsers. Also, JavaScript now has source code,
meaning that there will be some files that belong to your project that
don’t run in the browser.
As an example, let’s look at an arrow function with some default
arguments:
const add = (x = 5, y = 10) => console.log(x + y);
If we run Babel on this code, it will generate the following:
"use strict";
var add = function add() {
var x =
arguments.length <= 0 || arguments[0] === undefined ? 5 :
arguments[0];
var y =
arguments.length <= 1 || arguments[1] === undefined ? 10 :
arguments[1];
return console.log(x + y);
};
Babel added a “use strict” declaration to run in strict mode. The
variables x and y are defaulted using the arguments array, a technique
you may be familiar with. The resulting JavaScript is more widely
supported.
A great way to learn more about how Babel works is to check out the
Babel REPL on the documentation website. Type some new syntax on
the left side, then see some older syntax created.
The process of JavaScript compilation is typically automated by a build
tool like webpack or Parcel. We’ll discuss that in more detail later in
the book.
Objects and Arrays
Since ES2016, JavaScript syntax has supported creative ways of
scoping variables within objects and arrays. These creative techniques
are widely used among the React community. Let’s take a look at a few
of them, including destructuring, object literal enhancement, and the
spread operator.
Destructuring Objects
Destructuring assignment allows you to locally scope fields within an
object and to declare which values will be used. Consider the
sandwich object. It has four keys, but we only want to use the values
of two. We can scope bread and meat to be used locally:
const sandwich = {
bread: "dutch crunch",
meat: "tuna",
cheese: "swiss",
toppings: ["lettuce", "tomato", "mustard"]
};
const { bread, meat } = sandwich;
console.log(bread, meat); // dutch crunch tuna
The code pulls bread and meat out of the object and creates local
variables for them. Also, since we declared these destructed variables
using let, the bread and meat variables can be changed without
changing the original sandwich:
const sandwich = {
bread: "dutch crunch",
meat: "tuna",
cheese: "swiss",
toppings: ["lettuce", "tomato", "mustard"]
};
let { bread, meat } = sandwich;
bread = "garlic";
meat = "turkey";
console.log(bread); // garlic
console.log(meat); // turkey
console.log(sandwich.bread, sandwich.meat); // dutch crunch tuna
We can also destructure incoming function arguments. Consider this
function that would log a person’s name as a lord:
const lordify = regularPerson => {
console.log(`${regularPerson.firstname} of Canterbury`);
};
const regularPerson = {
firstname: "Bill",
lastname: "Wilson"
};
lordify(regularPerson); // Bill of Canterbury
Instead of using dot notation syntax to dig into objects, we can
destructure the values we need out of regularPerson:
const lordify = ({ firstname }) => {
console.log(`${firstname} of Canterbury`);
};
const regularPerson = {
firstname: "Bill",
lastname: "Wilson"
};
lordify(regularPerson); // Bill of Canterbury
Let’s take this one level farther to reflect a data change. Now, the
regularPerson object has a new nested object on the spouse key:
const regularPerson = {
firstname: "Bill",
lastname: "Wilson",
spouse: {
firstname: "Phil",
lastname: "Wilson"
}
};
If we wanted to lordify the spouse’s first name, we’d adjust the
function’s destructured arguments slightly:
const lordify = ({ spouse: { firstname } }) => {
console.log(`${firstname} of Canterbury`);
};
lordify(regularPerson); // Phil of Canterbury
Using the colon and nested curly braces, we can destructure the
firstname from the spouse object.
Destructuring Arrays
Values can also be destructured from arrays. Imagine that we wanted to
assign the first value of an array to a variable name:
const [firstAnimal] = ["Horse", "Mouse", "Cat"];
console.log(firstAnimal); // Horse
We can also pass over unnecessary values with list matching using
commas. List matching occurs when commas take the place of
elements that should be skipped. With the same array, we can access
the last value by replacing the first two values with commas:
const [, , thirdAnimal] = ["Horse", "Mouse", "Cat"];
console.log(thirdAnimal); // Cat
Later in this section, we’ll take this example a step farther by
combining array destructuring and the spread operator.
Object Literal Enhancement
Object literal enhancement is the opposite of destructuring. It’s the
process of restructuring or putting the object back together. With object
literal enhancement, we can grab variables from the global scope and
add them to an object:
const name = "Tallac";
const elevation = 9738;
const funHike = { name, elevation };
console.log(funHike); // {name: "Tallac", elevation: 9738}
name and elevation are now keys of the funHike object.
We can also create object methods with object literal enhancement or
restructuring:
const name = "Tallac";
const elevation = 9738;
const print = function() {
console.log(`Mt. ${this.name} is ${this.elevation} feet tall`);
};
const funHike = { name, elevation, print };
funHike.print(); // Mt. Tallac is 9738 feet tall
Notice we use this to access the object keys.
When defining object methods, it’s no longer necessary to use the
function keyword:
// Old
var skier = {
name: name,
sound: sound,
powderYell: function() {
var yell = this.sound.toUpperCase();
console.log(`${yell} ${yell} ${yell}!!!`);
},
speed: function(mph) {
this.speed = mph;
console.log("speed:", mph);
}
};
// New
const skier = {
name,
sound,
powderYell() {
let yell = this.sound.toUpperCase();
console.log(`${yell} ${yell} ${yell}!!!`);
},
speed(mph) {
this.speed = mph;
console.log("speed:", mph);
}
};
Object literal enhancement allows us to pull global variables into
objects and reduces typing by making the function keyword
unnecessary.
The Spread Operator
The spread operator is three dots (...) that perform several different
tasks. First, the spread operator allows us to combine the contents of
arrays. For example, if we had two arrays, we could make a third array
that combines the two arrays into one:
const peaks = ["Tallac", "Ralston", "Rose"];
const canyons = ["Ward", "Blackwood"];
const tahoe = [...peaks, ...canyons];
console.log(tahoe.join(", ")); // Tallac, Ralston, Rose, Ward, Blackwood
All of the items from peaks and canyons are pushed into a new array
called tahoe.
Let’s take a look at how the spread operator can help us deal with a
problem. Using the peaks array from the previous sample, let’s
imagine that we wanted to grab the last item from the array rather than
the first. We could use the Array.reverse method to reverse the array
in combination with array destructuring:
const peaks = ["Tallac", "Ralston", "Rose"];
const [last] = peaks.reverse();
console.log(last); // Rose
console.log(peaks.join(", ")); // Rose, Ralston, Tallac
See what happened? The reverse function has actually altered or
mutated the array. In a world with the spread operator, we don’t have
to mutate the original array. Instead, we can create a copy of the array
and then reverse it:
const peaks = ["Tallac", "Ralston", "Rose"];
const [last] = [...peaks].reverse();
console.log(last); // Rose
console.log(peaks.join(", ")); // Tallac, Ralston, Rose
Since we used the spread operator to copy the array, the peaks array is
still intact and can be used later in its original form.
The spread operator can also be used to get the remaining items in the
array:
const lakes = ["Donner", "Marlette", "Fallen Leaf", "Cascade"];
const [first, ...others] = lakes;
console.log(others.join(", ")); // Marlette, Fallen Leaf, Cascade
We can also use the three-dot syntax to collect function arguments as
an array. When used in a function, these are called rest parameters.
Here, we build a function that takes in n number of arguments using
the spread operator, then uses those arguments to print some console
messages:
function directions(...args) {
let [start, ...remaining] = args;
let [finish, ...stops] = remaining.reverse();
console.log(`drive through ${args.length} towns`);
console.log(`start in ${start}`);
console.log(`the destination is ${finish}`);
console.log(`stopping ${stops.length} times in between`);
}
directions("Truckee", "Tahoe City", "Sunnyside", "Homewood", "Tahoma");
The directions function takes in the arguments using the spread
operator. The first argument is assigned to the start variable. The last
argument is assigned to a finish variable using Array.reverse. We
then use the length of the arguments array to display how many towns
we’re going through. The number of stops is the length of the
arguments array minus the finish stop. This provides incredible
flexibility because we could use the directions function to handle
any number of stops.
The spread operator can also be used for objects (see the GitHub page
for Rest/Spread Properties). Using the spread operator with objects is
similar to using it with arrays. In this example, we’ll use it the same
way we combined two arrays into a third array, but instead of arrays,
we’ll use objects:
const morning = {
breakfast: "oatmeal",
lunch: "peanut butter and jelly"
};
const dinner = "mac and cheese";
const backpackingMeals = {
...morning,
dinner
};
console.log(backpackingMeals);
// {
// breakfast: "oatmeal",
// lunch: "peanut butter and jelly",
// dinner: "mac and cheese"
// }
Asynchronous JavaScript
The code samples that have been part of this chapter so far have been
synchronous. When we write synchronous JavaScript code, we’re
providing a list of instructions that execute immediately in order. For
example, if we wanted to use JavaScript to handle some simple DOM
manipulation, we’d write the code to do so like this:
const header = document.getElementById("heading");
header.innerHTML = "Hey!";
These are instructions. “Yo, go select that element with an id of
heading. Then when you’re done with that, how about you set that
inner HTML to Hey.” It works synchronously. While each operation is
happening, nothing else is happening.
With the modern web, we need to perform asynchronous tasks. These
tasks often have to wait for some work to finish before they can be
completed. We might need to access a database. We might need to
stream video or audio content. We might need to fetch data from an
API. With JavaScript, asynchronous tasks do not block the main
thread. JavaScript is free to do something else while we wait for the
API to return data. JavaScript has evolved a lot over the past few years
to make handling these asynchronous actions easier. Let’s explore
some of the features that make this possible.
Simple Promises with Fetch
Making a request to a REST API used to be pretty cumbersome. We’d
have to write 20+ lines of nested code just to load some data into our
app. Then the fetch() function showed up and simplified our lives.
Thanks to the ECMAScript committee for making fetch happen.
Let’s get some data from the randomuser.me API. This API has
information like email address, name, phone number, location, and so
on for fake members and is great to use as dummy data. fetch takes in
the URL for this resource as its only parameter:
console.log(fetch("https://api.randomuser.me/?nat=US&results=1"));
When we log this, we see that there is a pending promise. Promises
give us a way to make sense out of asynchronous behavior in
JavaScript. The promise is an object that represents whether the async
operation is pending, has been completed, or has failed. Think of this
like the browser saying, “Hey, I’m going to try my best to go get this
data. Either way, I’ll come back and let you know how it went.”
So back to the fetch result. The pending promise represents a state
before the data has been fetched. We need to chain on a function called
.then(). This function will take in a callback function that will run if
the previous operation was successful. In other words, fetch some data,
then do something else.
The something else we want to do is turn the response into JSON:
fetch("https://api.randomuser.me/?nat=US&results=1").then(res =>
console.log(res.json())
);
The then method will invoke the callback function once the promise
has resolved. Whatever you return from this function becomes the
argument of the next then function. So we can chain together then
functions to handle a promise that has been successfully resolved:
fetch("https://api.randomuser.me/?nat=US&results=1")
.then(res => res.json())
.then(json => json.results)
.then(console.log)
.catch(console.error);
First, we use fetch to make a GET request to randomuser.me. If the
request is successful, we’ll then convert the response body to JSON.
Next, we’ll take the JSON data and return the results, then we’ll send
the results to the console.log function, which will log them to the
console. Finally, there is a catch function that invokes a callback if the
fetch did not resolve successfully. Any error that occurred while
fetching data from randomuser.me will be based on that callback. Here,
we simply log the error to the console using console.error.
Async/Await
Another popular approach for handling promises is to create an async
function. Some developers prefer the syntax of async functions because
it looks more familiar, like code that’s found in a synchronous
function. Instead of waiting for the results of a promise to resolve and
handling it with a chain of then functions, async functions can be told
to wait for the promise to resolve before further executing any code
found in the function.
Let’s make another API request but wrap the functionality with an
async function:
const getFakePerson = async () => {
let res = await fetch("https://api.randomuser.me/?nat=US&results=1");
let { results } = res.json();
console.log(results);
};
getFakePerson();
Notice that the getFakePerson function is declared using the async
keyword. This makes it an asynchronous function that can wait for
promises to resolve before executing the code any further. The await
keyword is used before promise calls. This tells the function to wait for
the promise to resolve. This code accomplishes the exact same task as
the code in the previous section that uses then functions. Well, almost
the exact same task…
const getFakePerson = async () => {
try {
let res = await fetch("https://api.randomuser.me/?nat=US&results=1");
let { results } = res.json();
console.log(results);
} catch (error) {
console.error(error);
}
};
getFakePerson();
There we go—now this code accomplishes the exact same task as the
code in the previous section that uses then functions. If the fetch call
is successful, the results are logged to the console. If it’s unsuccessful,
then we’ll log the error to the console using console.error. When
using async and await, you need to surround your promise call in a
try…catch block to handle any errors that may occur due to an
unresolved promise.
Building Promises
When making an asynchronous request, one of two things can happen:
everything goes as we hope, or there’s an error. There can be many
different types of successful or unsuccessful requests. For example, we
could try several ways to obtain the data to reach success. We could
also receive multiple types of errors. Promises give us a way to
simplify back to a simple pass or fail.
The getPeople function returns a new promise. The promise makes a
request to the API. If the promise is successful, the data will load. If the
promise is unsuccessful, an error will occur:
const getPeople = count =>
new Promise((resolves, rejects) => {
const api = `https://api.randomuser.me/?nat=US&results=${count}`;
const request = new XMLHttpRequest();
request.open("GET", api);
request.onload = () =>
request.status === 200
? resolves(JSON.parse(request.response).results)
: reject(Error(request.statusText));
request.onerror = err => rejects(err);
request.send();
});
With that, the promise has been created, but it hasn’t been used yet. We
can use the promise by calling the getPeople function and passing in
the number of members that should be loaded. The then function can
be chained on to do something once the promise has been fulfilled.
When a promise is rejected, any details are passed back to the catch
function, or the catch block if using async/await syntax:
getPeople(5)
.then(members => console.log(members))
.catch(error => console.error(`getPeople failed: ${error.message}`))
);
Promises make dealing with asynchronous requests easier, which is
good, because we have to deal with a lot of asynchronicity in
JavaScript. A solid understanding of asynchronous behavior is essential
for the modern JavaScript engineer.
Classes
Prior to ES2015, there was no official class syntax in the JavaScript
spec. When classes were introduced, there was a lot of excitement
about how similar the syntax of classes was to traditional objectoriented languages like Java and C++. The past few years saw the
React library leaning on classes heavily to construct user interface
components. Today, React is beginning to move away from classes,
instead using functions to construct components. You’ll still see classes
all over the place, particularly in legacy React code and in the world of
JavaScript, so let’s take a quick look at them.
JavaScript uses something called prototypical inheritance. This
technique can be wielded to create structures that feel object-oriented.
For example, we can create a Vacation constructor that needs to be
invoked with a new operator:
function Vacation(destination, length) {
this.destination = destination;
this.length = length;
}
Vacation.prototype.print = function() {
console.log(this.destination + " | " + this.length + " days");
};
const maui = new Vacation("Maui", 7);
maui.print(); // Maui | 7 days
This code creates something that feels like a custom type in an objectoriented language. A Vacation has properties (destination, length), and
it has a method (print). The maui instance inherits the print method
through the prototype. If you are or were a developer accustomed to
more standard classes, this might fill you with a deep rage. ES2015
introduced class declaration to quiet that rage, but the dirty secret is
that JavaScript still works the same way. Functions are objects, and
inheritance is handled through the prototype. Classes provide a
syntactic sugar on top of that gnarly prototype syntax:
class Vacation {
constructor(destination, length) {
this.destination = destination;
this.length = length;
}
print() {
console.log(`${this.destination} will take ${this.length} days.`);
}
}
When you’re creating a class, the class name is typically capitalized.
Once you’ve created the class, you can create a new instance of the
class using the new keyword. Then you can call the custom method on
the class:
const trip = new Vacation("Santiago, Chile", 7);
trip.print(); // Chile will take 7 days.
Now that a class object has been created, you can use it as many times
as you’d like to create new vacation instances. Classes can also be
extended. When a class is extended, the subclass inherits the properties
and methods of the superclass. These properties and methods can be
manipulated from here, but as a default, all will be inherited.
You can use Vacation as an abstract class to create different types of
vacations. For instance, an Expedition can extend the Vacation class
to include gear:
class Expedition extends Vacation {
constructor(destination, length, gear) {
super(destination, length);
this.gear = gear;
}
print() {
super.print();
console.log(`Bring your ${this.gear.join(" and your ")}`);
}
}
That’s simple inheritance: the subclass inherits the properties of the
superclass. By calling the print method of Vacation, we can append
some new content onto what is printed in the print method of
Expedition. Creating a new instance works the exact same way—
create a variable and use the new keyword:
const trip = new Expedition("Mt. Whitney", 3, [
"sunglasses",
"prayer flags",
"camera"
]);
trip.print();
// Mt. Whitney will take 3 days.
// Bring your sunglasses and your prayer flags and your camera
ES6 Modules
A JavaScript module is a piece of reusable code that can easily be
incorporated into other JavaScript files without causing variable
collisions. JavaScript modules are stored in separate files, one file per
module. There are two options when creating and exporting a module:
you can export multiple JavaScript objects from a single module or one
JavaScript object per module.
In text-helpers.js, two functions are exported:
export const print=(message) => log(message, new Date())
export const log=(message, timestamp) =>
console.log(`${timestamp.toString()}: ${message}`)
export can be used to export any JavaScript type that will be
consumed in another module. In this example, the print function and
log function are being exported. Any other variables declared in texthelpers.js will be local to that module.
Modules can also export a single main variable. In these cases, you can
use export default. For example, the mt-freel.js file can export a
specific expedition:
export default new Expedition("Mt. Freel", 2, ["water", "snack"]);
export default can be used in place of export when you wish to
export only one type. Again, both export and export default can be
used on any JavaScript type: primitives, objects, arrays, and functions.
Modules can be consumed in other JavaScript files using the import
statement. Modules with multiple exports can take advantage of object
destructuring. Modules that use export default are imported into a
single variable:
import { print, log } from "./text-helpers";
import freel from "./mt-freel";
print("printing a message");
log("logging a message");
freel.print();
You can scope module variables locally under different variable
names:
import { print as p, log as l } from "./text-helpers";
p("printing a message");
l("logging a message");
You can also import everything into a single variable using *:
import * as fns from './text-helpers`
This import and export syntax is not yet fully supported by all
browsers or by Node. However, like any emerging JavaScript syntax,
it’s supported by Babel. This means you can use these statements in
your source code and Babel will know where to find the modules you
want to include in your compiled JavaScript.
CommonJS
CommonJS is the module pattern that’s supported by all versions of
Node (see the Node.js documentation on modules). You can still use
these modules with Babel and webpack. With CommonJS, JavaScript
objects are exported using module.exports.
For example, in CommonJS, we can export the print and log
functions as an object:
const print(message) => log(message, new Date())
const log(message, timestamp) =>
console.log(`${timestamp.toString()}: ${message}`}
module.exports = {print, log}
CommonJS does not support an import statement. Instead, modules
are imported with the require function:
const { log, print } = require("./txt-helpers");
JavaScript is indeed moving quickly and adapting to the increasing
demands that engineers are placing on the language, and browsers are
quickly implementing new features. For up-to-date compatibility
information, see the ESNext compatibility table. Many of the features
that are included in the latest JavaScript syntax are present because
they support functional programming techniques. In functional
JavaScript, we can think of our code as being a collection of functions
that can be composed into applications. In the next chapter, we’ll
explore functional techniques in more detail and will discuss why you
might want to use them.
Chapter 3. Functional
Programming with JavaScript
When you start to explore React, you’ll likely notice that the topic of
functional programming comes up a lot. Functional techniques are
being used more and more in JavaScript projects, particularly React
projects.
It’s likely that you’ve already written functional JavaScript code
without thinking about it. If you’ve mapped or reduced an array, then
you’re already on your way to becoming a functional JavaScript
programmer. Functional programming techniques are core not only to
React but to many of the libraries in the React ecosystem as well.
If you’re wondering where this functional trend came from, the answer
is the 1930s, with the invention of lambda calculus, or λ-calculus.
Functions have been a part of calculus since it emerged in the 17th
century. Functions can be sent to functions as arguments or returned
from functions as results. More complex functions, called higherorder functions, can manipulate functions and use them as either
arguments or results or both. In the 1930s, Alonzo Church was at
Princeton experimenting with these higher-order functions when he
invented lambda calculus.
In the late 1950s, John McCarthy took the concepts derived from λcalculus and applied them to a new programming language called Lisp.
1
Lisp implemented the concept of higher-order functions and functions
as first-class members or first-class citizens. A function is considered a
first-class member when it can be declared as a variable and sent to
functions as an argument. These functions can even be returned from
functions.
In this chapter, we’re going to go over some of the key concepts of
functional programming, and we’ll cover how to implement functional
techniques with JavaScript.
What It Means to Be Functional
JavaScript supports functional programming because JavaScript
functions are first-class citizens. This means that functions can do the
same things that variables can do. The latest JavaScript syntax adds
language improvements that can beef up your functional programming
techniques, including arrow functions, promises, and the spread
operator.
In JavaScript, functions can represent data in your application. You
may have noticed that you can declare functions with the var, let, or
const keywords the same way you can declare strings, numbers, or
any other variables:
var log = function(message) {
console.log(message);
};
log("In JavaScript, functions are variables");
// In JavaScript, functions are variables
We can write the same function using an arrow function. Functional
programmers write a lot of small functions, and the arrow function
syntax makes that much easier:
const log = message => {
console.log(message);
};
Since functions are variables, we can add them to objects:
const obj = {
message: "They can be added to objects like variables",
log(message) {
console.log(message);
}
};
obj.log(obj.message);
// They can be added to objects like variables
Both of these statements do the same thing: they store a function in a
variable called log. Additionally, the const keyword was used to
declare the second function, which will prevent it from being
overwritten.
We can also add functions to arrays in JavaScript:
const messages = [
"They can be inserted into arrays",
message => console.log(message),
"like variables",
message => console.log(message)
];
messages[1](messages[0]); // They can be inserted into arrays
messages[3](messages[2]); // like variables
Functions can be sent to other functions as arguments, just like other
variables:
const insideFn = logger => {
logger("They can be sent to other functions as arguments");
};
insideFn(message => console.log(message));
// They can be sent to other functions as arguments
They can also be returned from other functions, just like variables:
const createScream = function(logger) {
return function(message) {
logger(message.toUpperCase() + "!!!");
};
};
const scream = createScream(message => console.log(message));
scream("functions can be returned from other functions");
scream("createScream returns a function");
scream("scream invokes that returned function");
// FUNCTIONS CAN BE RETURNED FROM OTHER FUNCTIONS!!!
// CREATESCREAM RETURNS A FUNCTION!!!
// SCREAM INVOKES THAT RETURNED FUNCTION!!!
The last two examples were of higher-order functions: functions that
either take or return other functions. We could describe the same
createScream higher-order function with arrows:
const createScream = logger => message => {
logger(message.toUpperCase() + "!!!");
};
If you see more than one arrow used during a function declaration, this
means that you’re using a higher-order function.
We can say that JavaScript supports functional programming because
its functions are first-class citizens. This means that functions are data.
They can be saved, retrieved, or flow through your applications just
like variables.
Imperative Versus Declarative
Functional programming is a part of a larger programming paradigm:
declarative programming. Declarative programming is a style of
programming where applications are structured in a way that prioritizes
describing what should happen over defining how it should happen.
In order to understand declarative programming, we’ll contrast it with
imperative programming, or a style of programming that’s only
concerned with how to achieve results with code. Let’s consider a
common task: making a string URL-friendly. Typically, this can be
accomplished by replacing all of the spaces in a string with hyphens,
since spaces are not URL-friendly. First, let’s examine an imperative
approach to this task:
const string = "Restaurants in Hanalei";
const urlFriendly = "";
for (var i = 0; i < string.length; i++) {
if (string[i] === " ") {
urlFriendly += "-";
} else {
urlFriendly += string[i];
}
}
console.log(urlFriendly); // "Restaurants-in-Hanalei"
In this example, we loop through every character in the string,
replacing spaces as they occur. The structure of this program is only
concerned with how such a task can be achieved. We use a for loop
and an if statement and set values with an equality operator. Just
looking at the code alone does not tell us much. Imperative programs
require lots of comments in order to understand what’s going on.
Now let’s look at a declarative approach to the same problem:
const string = "Restaurants in Hanalei";
const urlFriendly = string.replace(/ /g, "-");
console.log(urlFriendly);
Here we are using string.replace along with a regular expression to
replace all instances of spaces with hyphens. Using string.replace is
a way of describing what’s supposed to happen: spaces in the string
should be replaced. The details of how spaces are dealt with are
abstracted away inside the replace function. In a declarative program,
the syntax itself describes what should happen, and the details of how
things happen are abstracted away.
Declarative programs are easy to reason about because the code itself
describes what is happening. For example, read the syntax in the
following sample. It details what happens after members are loaded
from an API:
const loadAndMapMembers = compose(
combineWith(sessionStorage, "members"),
save(sessionStorage, "members"),
scopeMembers(window),
logMemberInfoToConsole,
logFieldsToConsole("name.first"),
countMembersBy("location.state"),
prepStatesForMapping,
save(sessionStorage, "map"),
renderUSMap
);
getFakeMembers(100).then(loadAndMapMembers);
The declarative approach is more readable and, thus, easier to reason
about. The details of how each of these functions is implemented are
abstracted away. Those tiny functions are named well and combined in
a way that describes how member data goes from being loaded to being
saved and printed on a map, and this approach does not require many
comments. Essentially, declarative programming produces applications
that are easier to reason about, and when it’s easier to reason about an
application, that application is easier to scale. Additional details about
the declarative programming paradigm can be found at the Declarative
Programming wiki.
Now, let’s consider the task of building a document object model, or
DOM. An imperative approach would be concerned with how the
DOM is constructed:
const target = document.getElementById("target");
const wrapper = document.createElement("div");
const headline = document.createElement("h1");
wrapper.id = "welcome";
headline.innerText = "Hello World";
wrapper.appendChild(headline);
target.appendChild(wrapper);
This code is concerned with creating elements, setting elements, and
adding them to the document. It would be very hard to make changes,
add features, or scale 10,000 lines of code where the DOM is
constructed imperatively.
Now let’s take a look at how we can construct a DOM declaratively
using a React component:
const { render } = ReactDOM;
const Welcome = () => (
<div id="welcome">
<h1>Hello World</h1>
</div>
);
render(<Welcome />, document.getElementById("target"));
React is declarative. Here, the Welcome component describes the DOM
that should be rendered. The render function uses the instructions
declared in the component to build the DOM, abstracting away the
details of how the DOM is to be rendered. We can clearly see that we
want to render our Welcome component into the element with the ID of
target.
Functional Concepts
Now that you’ve been introduced to functional programming and what
it means to be “functional” or “declarative,” we’ll move on to
introducing the core concepts of functional programming:
immutability, purity, data transformation, higher-order functions, and
recursion.
Immutability
To mutate is to change, so to be immutable is to be unchangeable. In a
functional program, data is immutable. It never changes.
If you need to share your birth certificate with the public but want to
redact or remove private information, you essentially have two choices:
you can take a big Sharpie to your original birth certificate and cross
out your private data, or you can find a copy machine. Finding a copy
machine, making a copy of your birth certificate, and writing all over
that copy with that big Sharpie would be preferable. This way you can
have a redacted birth certificate to share and your original that’s still
intact.
This is how immutable data works in an application. Instead of
changing the original data structures, we build changed copies of those
data structures and use them instead.
To understand how immutability works, let’s take a look at what it
means to mutate data. Consider an object that represents the color
lawn:
let color_lawn = {
title: "lawn",
color: "#00FF00",
rating: 0
};
We could build a function that would rate colors and use that function
to change the rating of the color object:
function rateColor(color, rating) {
color.rating = rating;
return color;
}
console.log(rateColor(color_lawn, 5).rating); // 5
console.log(color_lawn.rating); // 5
In JavaScript, function arguments are references to the actual data.
Setting the color’s rating like this changes or mutates the original color
object. (Imagine if you tasked a business with redacting and sharing
your birth certificate and they returned your original birth certificate
with black marker covering the important details. You’d hope that a
business would have the common sense to make a copy of your birth
certificate and return the original unharmed.) We can rewrite the
rateColor function so that it does not harm the original goods (the
color object):
const rateColor = function(color, rating) {
return Object.assign({}, color, { rating: rating });
};
console.log(rateColor(color_lawn, 5).rating); // 5
console.log(color_lawn.rating); // 0
Here, we used Object.assign to change the color rating.
Object.assign is the copy machine. It takes a blank object, copies the
color to that object, and overwrites the rating on the copy. Now we can
have a newly rated color object without having to change the original.
We can write the same function using an arrow function along with the
object spread operator. This rateColor function uses the spread
operator to copy the color into a new object and then overwrite its
rating:
const rateColor = (color, rating) => ({
...color,
rating
});
This version of the rateColor function is exactly the same as the
previous one. It treats color as an immutable object, does so with less
syntax, and looks a little bit cleaner. Notice that we wrap the returned
object in parentheses. With arrow functions, this is a required step
since the arrow can’t just point to an object’s curly braces.
Let’s consider an array of color names:
let list = [{ title: "Rad Red" }, { title: "Lawn" }, { title: "Party
Pink" }];
We could create a function that will add colors to that array using
Array.push:
const addColor = function(title, colors) {
colors.push({ title: title });
return colors;
};
console.log(addColor("Glam Green", list).length); // 4
console.log(list.length); // 4
However, Array.push is not an immutable function. This addColor
function changes the original array by adding another field to it. In
order to keep the colors array immutable, we must use Array.concat
instead:
const addColor = (title, array) => array.concat({ title });
console.log(addColor("Glam Green", list).length); // 4
console.log(list.length); // 3
Array.concat concatenates arrays. In this case, it takes a new object
with a new color title and adds it to a copy of the original array.
You can also use the spread operator to concatenate arrays in the same
way it can be used to copy objects. Here’s the emerging JavaScript
equivalent of the previous addColor function:
const addColor = (title, list) => [...list, { title }];
This function copies the original list to a new array and then adds a
new object containing the color’s title to that copy. It is immutable.
Pure Functions
A pure function is a function that returns a value that’s computed based
on its arguments. Pure functions take at least one argument and always
return a value or another function. They do not cause side effects, set
global variables, or change anything about application state. They treat
their arguments as immutable data.
In order to understand pure functions, let’s first take a look at an
impure function:
const frederick = {
name: "Frederick Douglass",
canRead: false,
canWrite: false
};
function selfEducate() {
frederick.canRead = true;
frederick.canWrite = true;
return frederick;
}
selfEducate();
console.log(frederick);
// {name: "Frederick Douglass", canRead: true, canWrite: true}
The selfEducate function is not a pure function. It does not take any
arguments, and it does not return a value or a function. It also changes
a variable outside of its scope: Frederick. Once the selfEducate
function is invoked, something about the “world” has changed. It
causes side effects:
const frederick = {
name: "Frederick Douglass",
canRead: false,
canWrite: false
};
const selfEducate = person => {
person.canRead = true;
person.canWrite = true;
return person;
};
console.log(selfEducate(frederick));
console.log(frederick);
// {name: "Frederick Douglass", canRead: true, canWrite: true}
// {name: "Frederick Douglass", canRead: true, canWrite: true}
PURE FUNCTIONS ARE TESTABLE
Pure functions are naturally testable. They do not change anything about their
environment or “world,” and therefore do not require a complicated test setup or
teardown. Everything a pure function needs to operate it accesses via arguments.
When testing a pure function, you control the arguments, and thus you can
estimate the outcome. This selfEducate function is also impure: it causes side
effects. Invoking this function mutates the objects that are sent to it. If we could
treat the arguments sent to this function as immutable data, then we would have a
pure function.
Let’s have this function take an argument:
const frederick = {
name: "Frederick Douglass",
canRead: false,
canWrite: false
};
const selfEducate = person => ({
...person,
canRead: true,
canWrite: true
});
console.log(selfEducate(frederick));
console.log(frederick);
// {name: "Frederick Douglass", canRead: true, canWrite: true}
// {name: "Frederick Douglass", canRead: false, canWrite: false}
Finally, this version of selfEducate is a pure function. It computes a
value based on the argument that was sent to it: the person. It returns a
new person object without mutating the argument sent to it and
therefore has no side effects.
Now let’s examine an impure function that mutates the DOM:
function Header(text) {
let h1 = document.createElement("h1");
h1.innerText = text;
document.body.appendChild(h1);
}
Header("Header() caused side effects");
The Header function creates a heading—one element with specific text
—and adds it to the DOM. This function is impure. It does not return a
function or a value, and it causes side effects: a changed DOM.
In React, the UI is expressed with pure functions. In the following
sample, Header is a pure function that can be used to create h1
elements just like in the previous example. However, this function on
its own does not cause side effects because it does not mutate the
DOM. This function will create an h1 element, and it’s up to some
other part of the application to use that element to change the DOM:
const Header = props => <h1>{props.title}</h1>;
Pure functions are another core concept of functional programming.
They will make your life much easier because they will not affect your
application’s state. When writing functions, try to follow these three
rules:
1. The function should take in at least one argument.
2. The function should return a value or another function.
3. The function should not change or mutate any of its
arguments.
Data Transformations
How does anything change in an application if the data is immutable?
Functional programming is all about transforming data from one form
to another. We’ll produce transformed copies using functions. These
functions make our code less imperative and thus reduce complexity.
You do not need a special framework to understand how to produce
one dataset that is based upon another. JavaScript already has the
necessary tools for this task built into the language. There are two core
functions that you must master in order to be proficient with functional
JavaScript: Array.map and Array.reduce.
In this section, we’ll take a look at how these and some other core
functions transform data from one type to another.
Consider this array of high schools:
const schools = ["Yorktown", "Washington & Liberty", "Wakefield"];
We can get a comma-delimited list of these and some other strings by
using the Array.join function:
console.log(schools.join(", "));
// "Yorktown, Washington & Liberty, Wakefield"
Array.join is a built-in JavaScript array method that we can use to
extract a delimited string from our array. The original array is still
intact; join simply provides a different take on it. The details of how
this string is produced are abstracted away from the programmer.
If we wanted to create a function that creates a new array of the schools
that begin with the letter “W,” we could use the Array.filter
method:
const wSchools = schools.filter(school => school[0] === "W");
console.log(wSchools);
// ["Washington & Liberty", "Wakefield"]
Array.filter is a built-in JavaScript function that produces a new
array from a source array. This function takes a predicate as its only
argument. A predicate is a function that always returns a Boolean
value: true or false. Array.filter invokes this predicate once for
every item in the array. That item is passed to the predicate as an
argument, and the return value is used to decide if that item will be
added to the new array. In this case, Array.filter is checking every
school to see if its name begins with a “W.”
When it’s time to remove an item from an array, we should use
Array.filter over Array.pop or Array.splice because
Array.filter is immutable. In this next sample, the cutSchool
function returns new arrays that filter out specific school names:
const cutSchool = (cut, list) => list.filter(school => school !== cut);
console.log(cutSchool("Washington & Liberty", schools).join(", "));
// "Yorktown, Wakefield"
console.log(schools.join("\n"));
// Yorktown
// Washington & Liberty
// Wakefield
In this case, the cutSchool function is used to return a new array that
does not contain “Washington & Liberty.” Then, the join function is
used with this new array to create a string out of the remaining two
school names. cutSchool is a pure function. It takes a list of schools
and the name of the school that should be removed and returns a new
array without that specific school.
Another array function that is essential to functional programming is
Array.map. Instead of a predicate, the Array.map method takes a
function as its argument. This function will be invoked once for every
item in the array, and whatever it returns will be added to the new
array:
const highSchools = schools.map(school => `${school} High School`);
console.log(highSchools.join("\n"));
// Yorktown High School
// Washington & Liberty High School
// Wakefield High School
console.log(schools.join("\n"));
// Yorktown
// Washington & Liberty
// Wakefield
In this case, the map function was used to append “High School” to
each school name. The schools array is still intact.
In the last example, we produced an array of strings from an array of
strings. The map function can produce an array of objects, values,
arrays, other functions—any JavaScript type. Here’s an example of the
map function returning an object for every school:
const highSchools = schools.map(school => ({ name: school }));
console.log(highSchools);
// [
// { name: "Yorktown" },
// { name: "Washington & Liberty" },
// { name: "Wakefield" }
// ]
An array containing objects was produced from an array that contains
strings.
If you need to create a pure function that changes one object in an array
of objects, map can be used for this, too. In the following example,
we’ll change the school with the name of “Stratford” to “HB
Woodlawn” without mutating the schools array:
let schools = [
{ name: "Yorktown" },
{ name: "Stratford" },
{ name: "Washington & Liberty" },
{ name: "Wakefield" }
];
let updatedSchools = editName("Stratford", "HB Woodlawn", schools);
console.log(updatedSchools[1]); // { name: "HB Woodlawn" }
console.log(schools[1]); // { name: "Stratford" }
The schools array is an array of objects. The updatedSchools
variable calls the editName function and we send it the school we want
to update, the new school, and the schools array. This changes the
new array but makes no edits to the original:
const editName = (oldName, name, arr) =>
arr.map(item => {
if (item.name === oldName) {
return {
...item,
name
};
} else {
return item;
}
});
Within editName, the map function is used to create a new array of
objects based upon the original array. The editName function can be
written entirely in one line. Here’s an example of the same function
using a shorthand if/else statement:
const editName = (oldName, name, arr) =>
arr.map(item => (item.name === oldName ? { ...item, name } : item));
If you need to transform an array into an object, you can use
Array.map in conjunction with Object.keys. Object.keys is a
method that can be used to return an array of keys from an object.
Let’s say we needed to transform the schools object into an array of
schools:
const schools = {
Yorktown: 10,
"Washington & Liberty": 2,
Wakefield: 5
};
const schoolArray = Object.keys(schools).map(key => ({
name: key,
wins: schools[key]
}));
console.log(schoolArray);
// [
// {
// name: "Yorktown",
// wins: 10
// },
// {
// name: "Washington & Liberty",
// wins: 2
// },
// {
// name: "Wakefield",
// wins: 5
// }
// ]
In this example, Object.keys returns an array of school names, and
we can use map on that array to produce a new array of the same
length. The name of the new object will be set using the key, and wins
is set equal to the value.
So far, we’ve learned that we can transform arrays with Array.map and
Array.filter. We’ve also learned that we can change arrays into
objects by combining Object.keys with Array.map. The final tool
that we need in our functional arsenal is the ability to transform arrays
into primitives and other objects.
The reduce and reduceRight functions can be used to transform an
array into any value, including a number, string, boolean, object, or
even a function.
Let’s say we need to find the maximum number in an array of
numbers. We need to transform an array into a number; therefore, we
can use reduce:
const ages = [21, 18, 42, 40, 64, 63, 34];
const maxAge = ages.reduce((max, age) => {
console.log(`${age} > ${max} = ${age > max}`);
if (age > max) {
return age;
} else {
return max;
}
}, 0);
console.log("maxAge", maxAge);
// 21 > 0 = true
// 18 > 21 = false
// 42 > 21 = true
// 40 > 42 = false
// 64 > 42 = true
// 63 > 64 = false
// 34 > 64 = false
// maxAge 64
The ages array has been reduced into a single value: the maximum
age, 64. reduce takes two arguments: a callback function and an
original value. In this case, the original value is 0, which sets the initial
maximum value to 0. The callback is invoked once for every item in
the array. The first time this callback is invoked, age is equal to 21, the
first value in the array, and max is equal to 0, the initial value. The
callback returns the greater of the two numbers, 21, and that becomes
the max value during the next iteration. Each iteration compares each
age against the max value and returns the greater of the two. Finally,
the last number in the array is compared and returned from the
previous callback.
If we remove the console.log statement from the preceding function
and use a shorthand if/else statement, we can calculate the max
value in any array of numbers with the following syntax:
const max = ages.reduce((max, value) => (value > max ? value : max), 0);
ARRAY.REDUCERIGHT
Array.reduceRight works the same way as Array.reduce; the difference is that
it starts reducing from the end of the array rather than the beginning.
Sometimes we need to transform an array into an object. The following
example uses reduce to transform an array that contains colors into a
hash:
const colors = [
{
id: "xekare",
title: "rad red",
rating: 3
},
{
id: "jbwsof",
title: "big blue",
rating: 2
},
{
id: "prigbj",
title: "grizzly grey",
rating: 5
},
{
id: "ryhbhsl",
title: "banana",
rating: 1
}
];
const hashColors = colors.reduce((hash, { id, title, rating }) => {
hash[id] = { title, rating };
return hash;
}, {});
console.log(hashColors);
// {
// "xekare": {
// title:"rad red",
// rating:3
// },
// "jbwsof": {
// title:"big blue",
// rating:2
// },
// "prigbj": {
// title:"grizzly grey",
// rating:5
// },
// "ryhbhsl": {
// title:"banana",
// rating:1
// }
// }
In this example, the second argument sent to the reduce function is an
empty object. This is our initial value for the hash. During each
iteration, the callback function adds a new key to the hash using
bracket notation and sets the value for that key to the id field of the
array. Array.reduce can be used in this way to reduce an array to a
single value—in this case, an object.
We can even transform arrays into completely different arrays using
reduce. Consider reducing an array with multiple instances of the
same value to an array of unique values. The reduce method can be
used to accomplish this task:
const colors = ["red", "red", "green", "blue", "green"];
const uniqueColors = colors.reduce(
(unique, color) =>
unique.indexOf(color) !== -1 ? unique : [...unique, color],
[]
);
console.log(uniqueColors);
// ["red", "green", "blue"]
In this example, the colors array is reduced to an array of distinct
values. The second argument sent to the reduce function is an empty
array. This will be the initial value for distinct. When the distinct
array does not already contain a specific color, it will be added.
Otherwise, it will be skipped, and the current distinct array will be
returned.
map and reduce are the main weapons of any functional programmer,
and JavaScript is no exception. If you want to be a proficient
JavaScript engineer, then you must master these functions. The ability
to create one dataset from another is a required skill and is useful for
any type of programming paradigm.
Higher-Order Functions
The use of higher-order functions is also essential to functional
programming. We’ve already mentioned higher-order functions, and
we’ve even used a few in this chapter. Higher-order functions are
functions that can manipulate other functions. They can take functions
in as arguments or return functions or both.
The first category of higher-order functions are functions that expect
other functions as arguments. Array.map, Array.filter, and
Array.reduce all take functions as arguments. They are higher-order
functions.
Let’s take a look at how we can implement a higher-order function. In
the following example, we create an invokeIf callback function that
will test a condition and invoke a callback function when it’s true and
another callback function when the condition is false:
const invokeIf = (condition, fnTrue, fnFalse) =>
condition ? fnTrue() : fnFalse();
const showWelcome = () => console.log("Welcome!!!");
const showUnauthorized = () => console.log("Unauthorized!!!");
invokeIf(true, showWelcome, showUnauthorized); // "Welcome!!!"
invokeIf(false, showWelcome, showUnauthorized); // "Unauthorized!!!"
invokeIf expects two functions: one for true and one for false. This is
demonstrated by sending both showWelcome and showUnauthorized
to invokeIf. When the condition is true, showWelcome is invoked.
When it’s false, showUnauthorized is invoked.
Higher-order functions that return other functions can help us handle
the complexities associated with asynchronicity in JavaScript. They
can help us create functions that can be used or reused at our
convenience.
Currying is a functional technique that involves the use of higher-order
functions.
The following is an example of currying. The userLogs function hangs
on to some information (the username) and returns a function that can
be used and reused when the rest of the information (the message) is
made available. In this example, log messages will all be prepended
with the associated username. Notice that we’re using the
getFakeMembers function that returns a promise from Chapter 2:
const userLogs = userName => message =>
console.log(`${userName} -> ${message}`);
const log = userLogs("grandpa23");
log("attempted to load 20 fake members");
getFakeMembers(20).then(
members => log(`successfully loaded ${members.length} members`),
error => log("encountered an error loading members")
);
// grandpa23 -> attempted to load 20 fake members
// grandpa23 -> successfully loaded 20 members
// grandpa23 -> attempted to load 20 fake members
// grandpa23 -> encountered an error loading members
userLogs is the higher-order function. The log function is produced
from userLogs, and every time the log function is used, “grandpa23”
is prepended to the message.
Recursion
Recursion is a technique that involves creating functions that recall
themselves. Often, when faced with a challenge that involves a loop, a
recursive function can be used instead. Consider the task of counting
down from 10. We could create a for loop to solve this problem, or we
could alternatively use a recursive function. In this example,
countdown is the recursive function:
const countdown = (value, fn) => {
fn(value);
return value > 0 ? countdown(value - 1, fn) : value;
};
countdown(10, value => console.log(value));
// 10
// 9
// 8
// 7
// 6
// 5
// 4
// 3
// 2
// 1
// 0
countdown expects a number and a function as arguments. In this
example, it’s invoked with a value of 10 and a callback function. When
countdown is invoked, the callback is invoked, which logs the current
value. Next, countdown checks the value to see if it’s greater than 0. If
it is, countdown recalls itself with a decremented value. Eventually, the
value will be 0, and countdown will return that value all the way back
up the call stack.
Recursion is a pattern that works particularly well with asynchronous
processes. Functions can recall themselves when they’re ready, like
when the data is available or when a timer has finished.
The countdown function can be modified to count down with a delay.
This modified version of the countdown function can be used to create
a countdown clock:
const countdown = (value, fn, delay = 1000) => {
fn(value);
return value > 0
? setTimeout(() => countdown(value - 1, fn, delay), delay)
: value;
};
const log = value => console.log(value);
countdown(10, log);
In this example, we create a 10-second countdown by initially invoking
countdown once with the number 10 in a function that logs the
countdown. Instead of recalling itself right away, the countdown
function waits one second before recalling itself, thus creating a clock.
Recursion is a good technique for searching data structures. You can
use recursion to iterate through subfolders until a folder that contains
only files is identified. You can also use recursion to iterate though the
HTML DOM until you find an element that does not contain any
children. In the next example, we’ll use recursion to iterate deeply into
an object to retrieve a nested value:
const dan = {
type: "person",
data: {
gender: "male",
info: {
id: 22,
fullname: {
first: "Dan",
last: "Deacon"
}
}
}
};
deepPick("type", dan); // "person"
deepPick("data.info.fullname.first", dan); // "Dan"
deepPick can be used to access Dan’s type, stored immediately in the
first object, or to dig down into nested objects to locate Dan’s first
name. Sending a string that uses dot notation, we can specify where to
locate values that are nested deep within an object:
const deepPick = (fields, object = {}) => {
const [first, ...remaining] = fields.split(".");
return remaining.length
? deepPick(remaining.join("."), object[first])
: object[first];
};
The deepPick function is either going to return a value or recall itself
until it eventually returns a value. First, this function splits the dot-
notated fields string into an array and uses array destructuring to
separate the first value from the remaining values. If there are
remaining values, deepPick recalls itself with slightly different data,
allowing it to dig one level deeper.
This function continues to call itself until the fields string no longer
contains dots, meaning that there are no more remaining fields. In this
sample, you can see how the values for first, remaining, and
object[first] change as deepPick iterates through:
deepPick("data.info.fullname.first", dan); // "Dan"
// First Iteration
// first = "data"
// remaining.join(".") = "info.fullname.first"
// object[first] = { gender: "male", {info} }
// Second Iteration
// first = "info"
// remaining.join(".") = "fullname.first"
// object[first] = {id: 22, {fullname}}
// Third Iteration
// first = "fullname"
// remaining.join("." = "first"
// object[first] = {first: "Dan", last: "Deacon" }
// Finally...
// first = "first"
// remaining.length = 0
// object[first] = "Deacon"
Recursion is a powerful functional technique that’s fun to implement.
Composition
Functional programs break up their logic into small, pure functions that
are focused on specific tasks. Eventually, you’ll need to put these
smaller functions together. Specifically, you may need to combine
them, call them in series or parallel, or compose them into larger
functions until you eventually have an application.
When it comes to composition, there are a number of different
implementations, patterns, and techniques. One that you may be
familiar with is chaining. In JavaScript, functions can be chained
together using dot notation to act on the return value of the previous
function.
Strings have a replace method. The replace method returns a template
string, which will also have a replace method. Therefore, we can chain
together replace methods with dot notation to transform a string:
const template = "hh:mm:ss tt";
const clockTime = template
.replace("hh", "03")
.replace("mm", "33")
.replace("ss", "33")
.replace("tt", "PM");
console.log(clockTime);
// "03:33:33 PM"
In this example, the template is a string. By chaining replace methods
to the end of the template string, we can replace hours, minutes,
seconds, and time of day in the string with new values. The template
itself remains intact and can be reused to create more clock time
displays.
The both function is one function that pipes a value through two
separate functions. The output of civilian hours becomes the input
for appendAMPM, and we can change a date using both of these
functions combined into one:
const both = date => appendAMPM(civilianHours(date));
However, this syntax is hard to comprehend and therefore tough to
maintain or scale. What happens when we need to send a value through
20 different functions?
A more elegant approach is to create a higher-order function we can
use to compose functions into larger functions:
const both = compose(
civilianHours,
appendAMPM
);
both(new Date());
This approach looks much better. It’s easy to scale because we can add
more functions at any point. This approach also makes it easy to
change the order of the composed functions.
The compose function is a higher-order function. It takes functions as
arguments and returns a single value:
const compose = (...fns) => arg =>
fns.reduce((composed, f) => f(composed), arg);
compose takes in functions as arguments and returns a single function.
In this implementation, the spread operator is used to turn those
function arguments into an array called fns. A function is then
returned that expects one argument, arg. When this function is
invoked, the fns array is piped starting with the argument we want to
send through the function. The argument becomes the initial value for
compose, then each iteration of the reduced callback returns. Notice
that the callback takes two arguments: composed and a function f.
Each function is invoked with compose, which is the result of the
previous function’s output. Eventually, the last function will be
invoked and the last result returned.
This is a simple example of a compose function designed to illustrate
composition techniques. This function becomes more complex when
it’s time to handle more than one argument or deal with arguments that
are not functions.
Putting It All Together
Now that we’ve been introduced to the core concepts of functional
programming, let’s put those concepts to work for us and build a small
JavaScript application.
Our challenge is to build a ticking clock. The clock needs to display
hours, minutes, seconds, and time of day in civilian time. Each field
must always have double digits, meaning leading zeros need to be
applied to single-digit values like 1 or 2. The clock must also tick and
change the display every second.
First, let’s review an imperative solution for the clock:
// Log Clock Time every Second
setInterval(logClockTime, 1000);
function logClockTime() {
// Get Time string as civilian time
let time = getClockTime();
// Clear the Console and log the time
console.clear();
console.log(time);
}
function getClockTime() {
// Get the Current Time
let date = new Date();
let time = "";
// Serialize clock time
let time = {
hours: date.getHours(),
minutes: date.getMinutes(),
seconds: date.getSeconds(),
ampm: "AM"
};
// Convert to civilian time
if (time.hours == 12) {
time.ampm = "PM";
} else if (time.hours > 12) {
time.ampm = "PM";
time.hours -= 12;
}
// Prepend a 0 on the hours to make double digits
if (time.hours < 10) {
time.hours = "0" + time.hours;
}
// prepend a 0 on the minutes to make double digits
if (time.minutes < 10) {
time.minutes = "0" + time.minutes;
}
// prepend a 0 on the seconds to make double digits
if (time.seconds < 10) {
time.seconds = "0" + time.seconds;
}
// Format the clock time as a string "hh:mm:ss tt"
return time.hours + ":" + time.minutes + ":" + time.seconds + " " +
time.ampm;
}
This solution works, and the comments help us understand what’s
happening. However, these functions are large and complicated. Each
function does a lot. They’re hard to comprehend, they require
comments, and they’re tough to maintain. Let’s see how a functional
approach can produce a more scalable application.
Our goal will be to break the application logic up into smaller parts:
functions. Each function will be focused on a single task, and we’ll
compose them into larger functions that we can use to create the clock.
First, let’s create some functions that give us values and manage the
console. We’ll need a function that gives us one second, a function that
gives us the current time, and a couple of functions that will log
messages on a console and clear the console. In functional programs,
we should use functions over values wherever possible. We’ll invoke
the function to obtain the value when needed:
const oneSecond = () => 1000;
const getCurrentTime = () => new Date();
const clear = () => console.clear();
const log = message => console.log(message);
Next, we’ll need some functions for transforming data. These three
functions will be used to mutate the Date object into an object that can
be used for our clock:
serializeClockTime
Takes a date object and returns an object for clock time that
contains hours, minutes, and seconds.
civilianHours
Takes the clock time object and returns an object where hours are
converted to civilian time. For example: 1300 becomes 1:00.
appendAMPM
Takes the clock time object and appends time of day (AM or PM)
to that object.
const serializeClockTime = date => ({
hours: date.getHours(),
minutes: date.getMinutes(),
seconds: date.getSeconds()
});
const civilianHours = clockTime => ({
...clockTime,
hours: clockTime.hours > 12 ? clockTime.hours - 12 : clockTime.hours
});
const appendAMPM = clockTime => ({
...clockTime,
ampm: clockTime.hours >= 12 ? "PM" : "AM"
});
These three functions are used to transform data without changing the
original. They treat their arguments as immutable objects.
Next, we’ll need a few higher-order functions:
display
Takes a target function and returns a function that will send a time
to the target. In this example, the target will be console.log.
formatClock
Takes a template string and uses it to return clock time formatted
based on the criteria from the string. In this example, the template
is “hh:mm:ss tt”. From there, formatClock will replace the
placeholders with hours, minutes, seconds, and time of day.
prependZero
Takes an object’s key as an argument and prepends a zero to the
value stored under that object’s key. It takes in a key to a specific
field and prepends values with a zero if the value is less than 10.
const display = target => time => target(time);
const formatClock = format => time =>
format
.replace("hh", time.hours)
.replace("mm", time.minutes)
.replace("ss", time.seconds)
.replace("tt", time.ampm);
const prependZero = key => clockTime => ({
...clockTime,
key: clockTime[key] < 10 ? "0" + clockTime[key] : clockTime[key]
});
These higher-order functions will be invoked to create the functions
that will be reused to format the clock time for every tick. Both
formatClock and prependZero will be invoked once, initially setting
up the required template or key. The inner functions they return will be
invoked once every second to format the time for display.
Now that we have all of the functions required to build a ticking clock,
we’ll need to compose them. We’ll use the compose function that we
defined in the last section to handle composition:
convertToCivilianTime
A single function that takes clock time as an argument and
transforms it into civilian time by using both civilian hours.
doubleDigits
A single function that takes civilian clock time and makes sure the
hours, minutes, and seconds display double digits by prepending
zeros where needed.
startTicking
Starts the clock by setting an interval that invokes a callback every
second. The callback is composed using all our functions. Every
second the console is cleared, currentTime is obtained, converted,
civilianized, formatted, and displayed.
const convertToCivilianTime = clockTime =>
compose(
appendAMPM,
civilianHours
)(clockTime);
const doubleDigits = civilianTime =>
compose(
prependZero("hours"),
prependZero("minutes"),
prependZero("seconds")
)(civilianTime);
const startTicking = () =>
setInterval(
compose(
clear,
getCurrentTime,
serializeClockTime,
convertToCivilianTime,
doubleDigits,
formatClock("hh:mm:ss tt"),
display(log)
),
oneSecond()
);
startTicking();
This declarative version of the clock achieves the same results as the
imperative version. However, there quite a few benefits to this
approach. First, all of these functions are easily testable and reusable.
They can be used in future clocks or other digital displays. Also, this
program is easily scalable. There are no side effects. There are no
global variables outside of functions themselves. There could still be
bugs, but they’ll be easier to find.
In this chapter, we’ve introduced functional programming principles.
Throughout the book when we discuss best practices in React, we’ll
continue to demonstrate how many React concepts are based in
functional techniques. In the next chapter, we’ll dive into React
officially with an improved understanding of the principles that guided
its development.
1
D
a
n
a
S. S
c
o
t
t
,
“
λ
-
C
a
l
c
u
l
u
s: T
h
e
n
&
N
o
w
”.
Chapter 4. How React Works
So far on your journey, you’ve brushed up on the latest syntax. You’ve
reviewed the functional programming patterns that guided React’s
creation. These steps have prepared you to take the next step, to do
what you came here to do: to learn how React works. Let’s get into
writing some real React code.
When you work with React, it’s more than likely that you’ll be creating
your apps with JSX. JSX is a tag-based JavaScript syntax that looks a
lot like HTML. It’s a syntax we’ll dive deep into in the next chapter
and continue to use for the rest of the book. To truly understand React,
though, we need to understand its most atomic units: React elements.
From there, we’ll get into React elements. From there, we’ll get into
React components by looking at how we can create custom
components that compose other components and elements.
Page Setup
In order to work with React in the browser, we need to include two
libraries: React and ReactDOM. React is the library for creating views.
ReactDOM is the library used to actually render the UI in the browser.
Both libraries are available as scripts from the unpkg CDN (links are
included in the following code). Let’s set up an HTML document:
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>React Samples</title>
</head>
<body>
<!-- Target container -->
<div id="root"></div>
<!-- React library & ReactDOM (Development Version)-->
<script
src="https://unpkg.com/react@16/umd/react.development.js">
</script>
<script
src="https://unpkg.com/react-dom@16/umd/react-dom.development.js">
</script>
<script>
// Pure React and JavaScript code
</script>
</body>
</html>
These are the minimum requirements for working with React in the
browser. You can place your JavaScript in a separate file, but it must
be loaded somewhere in the page after React has been loaded. We’re
going to be using the development version of React to see all of the
error messages and warnings in the browser console. You can choose
to use the minified production version using react.production.min.js
and react-dom.production.min.js, which will strip away those
warnings.
React Elements
HTML is simply a set of instructions that a browser follows when
constructing the DOM. The elements that make up an HTML
document become DOM elements when the browser loads HTML and
renders the user interface.
Let’s say you have to construct an HTML hierarchy for a recipe. A
possible solution for such a task might look something like this:
<section id="baked-salmon">
<h1>Baked Salmon</h1>
<ul class="ingredients">
<li>2 lb salmon</li>
<li>5 sprigs fresh rosemary</li>
<li>2 tablespoons olive oil</li>
<li>2 small lemons</li>
<li>1 teaspoon kosher salt</li>
<li>4 cloves of chopped garlic</li>
</ul>
<section class="instructions">
<h2>Cooking Instructions</h2>
<p>Preheat the oven to 375 degrees.</p>
<p>Lightly coat aluminum foil with oil.</p>
<p>Place salmon on foil</p>
<p>Cover with rosemary, sliced lemons, chopped garlic.</p>
<p>Bake for 15-20 minutes until cooked through.</p>
<p>Remove from oven.</p>
</section>
</section>
In HTML, elements relate to one another in a hierarchy that resembles
a family tree. We could say that the root element (in this case, a
section) has three children: a heading, an unordered list of ingredients,
and a section for the instructions.
In the past, websites consisted of independent HTML pages. When the
user navigated these pages, the browser would request and load
different HTML documents. The invention of AJAX (Asynchronous
JavaScript and XML) brought us the single-page application, or SPA.
Since browsers could request and load tiny bits of data using AJAX,
entire web applications could now run out of a single page and rely on
JavaScript to update the user interface.
In an SPA, the browser initially loads one HTML document. As users
navigate through the site, they actually stay on the same page.
JavaScript destroys and creates a new user interface as the user
interacts with the application. It may feel as though you’re jumping
from page to page, but you’re actually still on the same HTML page,
and JavaScript is doing the heavy lifting.
The DOM API is a collection of objects that JavaScript can use to
interact with the browser to modify the DOM. If you’ve used
document.createElement or document.appendChild, you’ve
worked with the DOM API.
React is a library that’s designed to update the browser DOM for us.
We no longer have to be concerned with the complexities associated
with building high-performing SPAs because React can do that for us.
With React, we do not interact with the DOM API directly. Instead, we
provide instructions for what we want React to build, and React will
take care of rendering and reconciling the elements we’ve instructed it
to create.
The browser DOM is made up of DOM elements. Similarly, the React
DOM is made up of React elements. DOM elements and React
elements may look the same, but they’re actually quite different. A
React element is a description of what the actual DOM element should
look like. In other words, React elements are the instructions for how
the browser DOM should be created.
We can create a React element to represent an h1 using
React.createElement:
React.createElement("h1", { id: "recipe-0" }, "Baked Salmon");
The first argument defines the type of element we want to create. In
this case, we want to create an h1 element. The second argument
represents the element’s properties. This h1 currently has an id of
recipe-0. The third argument represents the element’s children: any
nodes that are inserted between the opening and closing tag (in this
case, just some text).
During rendering, React will convert this element to an actual DOM
element:
<h1 id="recipe-0">Baked Salmon</h1>
The properties are similarly applied to the new DOM element: the
properties are added to the tag as attributes, and the child text is added
as text within the element. A React element is just a JavaScript literal
that tells React how to construct the DOM element.
If you were to log this element, it would look like this:
{
$$typeof: Symbol(React.element),
"type": "h1",
"key": null,
"ref": null,
"props": {id: "recipe-0", children: "Baked Salmon"},
"_owner": null,
"_store": {}
}
This is the structure of a React element. There are fields that are used
by React: _owner, _store, and $$typeof. The key and ref fields are
important to React elements, but we’ll introduce those later. For now,
let’s take a closer look at the type and props fields.
The type property of the React element tells React what type of
HTML or SVG element to create. The props property represents the
data and child elements required to construct a DOM element. The
children property is for displaying other nested elements as text.
CREATING ELEMENTS
We’re taking a peek at the object that React.createElement returns. You won’t
actually create these elements by hand; instead, you’ll use the
React.createElement function.
ReactDOM
Once we’ve created a React element, we’ll want to see it in the
browser. ReactDOM contains the tools necessary to render React
elements in the browser. ReactDOM is where we’ll find the render
method.
We can render a React element, including its children, to the DOM
with ReactDOM.render. The element we want to render is passed as
the first argument, and the second argument is the target node, where
we should render the element:
const dish = React.createElement("h1", null, "Baked Salmon");
ReactDOM.render(dish, document.getElementById("root"));
Rendering the title element to the DOM would add an h1 element to
the div with the id of root, which we would already have defined in
our HTML. We build this div inside the body tag:
<body>
<div id="root">
<h1>Baked Salmon</h1>
</div>
</body>
Anything related to rendering elements to the DOM is found in the
ReactDOM package. In versions of React earlier than React 16, you
could only render one element to the DOM. Today, it’s possible to
render arrays as well. When the ability to do this was announced at
ReactConf 2017, everyone clapped and screamed. It was a big deal.
This is what that looks like:
const dish = React.createElement("h1", null, "Baked Salmon");
const dessert = React.createElement("h2", null, "Coconut Cream Pie");
ReactDOM.render([dish, dessert], document.getElementById("root"));
This will render both of these elements as siblings inside of the root
container. We hope you just clapped and screamed!
In the next section, we’ll get an understanding of how to use
props.children.
Children
React renders child elements using props.children. In the previous
section, we rendered a text element as a child of the h1 element, and
thus props.children was set to Baked Salmon. We could render
other React elements as children, too, creating a tree of elements. This
is why we use the term element tree: the tree has one root element from
which many branches grow.
Let’s consider the unordered list that contains ingredients:
<ul>
<li>2 lb salmon</li>
<li>5 sprigs fresh rosemary</li>
<li>2 tablespoons olive oil</li>
<li>2 small lemons</li>
<li>1 teaspoon kosher salt</li>
<li>4 cloves of chopped garlic</li>
</ul>
In this sample, the unordered list is the root element, and it has six
children. We can represent this ul and its children with
React.createElement:
React.createElement(
"ul",
null,
React.createElement("li", null, "2 lb salmon"),
React.createElement("li", null, "5 sprigs fresh rosemary"),
React.createElement("li", null, "2 tablespoons olive oil"),
React.createElement("li", null, "2 small lemons"),
React.createElement("li", null, "1 teaspoon kosher salt"),
React.createElement("li", null, "4 cloves of chopped garlic")
);
Every additional argument sent to the createElement function is
another child element. React creates an array of these child elements
and sets the value of props.children to that array.
If we were to inspect the resulting React element, we would see each
list item represented by a React element and added to an array called
props.children. If you console log this element:
const list = React.createElement(
"ul",
null,
React.createElement("li", null, "2 lb salmon"),
React.createElement("li", null, "5 sprigs fresh rosemary"),
React.createElement("li", null, "2 tablespoons olive oil"),
React.createElement("li", null, "2 small lemons"),
React.createElement("li", null, "1 teaspoon kosher salt"),
React.createElement("li", null, "4 cloves of chopped garlic")
);
console.log(list);
The result will look like this:
{
"type": "ul",
"props": {
"children": [
{ "type": "li", "props": { "children": "2 lb salmon" } … },
{ "type": "li", "props": { "children": "5 sprigs fresh rosemary"} …
},
{ "type": "li", "props": { "children": "2 tablespoons olive oil" } …
},
{ "type": "li", "props": { "children": "2 small lemons"} … },
{ "type": "li", "props": { "children": "1 teaspoon kosher salt"} … },
{ "type": "li", "props": { "children": "4 cloves of chopped garlic"}
… }
]
...
}
}
We can now see that each list item is a child. Earlier in this chapter, we
introduced HTML for an entire recipe rooted in a section element. To
create this using React, we’ll use a series of createElement calls:
React.createElement(
"section",
{ id: "baked-salmon" },
React.createElement("h1", null, "Baked Salmon"),
React.createElement(
"ul",
{ className: "ingredients" },
React.createElement("li", null, "2 lb salmon"),
React.createElement("li", null, "5 sprigs fresh rosemary"),
React.createElement("li", null, "2 tablespoons olive oil"),
React.createElement("li", null, "2 small lemons"),
React.createElement("li", null, "1 teaspoon kosher salt"),
React.createElement("li", null, "4 cloves of chopped garlic")
),
React.createElement(
"section",
{ className: "instructions" },
React.createElement("h2", null, "Cooking Instructions"),
React.createElement("p", null, "Preheat the oven to 375 degrees."),
React.createElement("p", null, "Lightly coat aluminum foil with
oil."),
React.createElement("p", null, "Place salmon on foil."),
React.createElement(
"p",
null,
"Cover with rosemary, sliced lemons, chopped garlic."
),
React.createElement(
"p",
null,
"Bake for 15-20 minutes until cooked through."
),
React.createElement("p", null, "Remove from oven.")
)
);
CLASSNAME IN REACT
Any element that has an HTML class attribute is using className for that
property instead of class. Since class is a reserved word in JavaScript, we have
to use className to define the class attribute of an HTML element. This sample
is what pure React looks like. Pure React is ultimately what runs in the browser. A
React app is a tree of React elements all stemming from a single root element.
React elements are the instructions React will use to build a UI in the browser.
CONSTRUCTING ELEMENTS WITH DATA
The major advantage of using React is its ability to separate data from
UI elements. Since React is just JavaScript, we can add JavaScript
logic to help us build the React component tree. For example,
ingredients can be stored in an array, and we can map that array to the
React elements.
Let’s go back and think about the unordered list for a moment:
React.createElement(
"ul",
null,
React.createElement("li", null, "2 lb salmon"),
React.createElement("li", null, "5 sprigs fresh rosemary"),
React.createElement("li", null, "2 tablespoons olive oil"),
React.createElement("li", null, "2 small lemons"),
React.createElement("li", null, "1 teaspoon kosher salt"),
React.createElement("li", null, "4 cloves of chopped garlic")
);
The data used in this list of ingredients can easily be represented using
a JavaScript array:
const items = [
"2 lb salmon",
"5 sprigs fresh rosemary",
"2 tablespoons olive oil",
"2 small lemons",
"1 teaspoon kosher salt",
"4 cloves of chopped garlic"
];
We want to use this data to generate the correct number of list items
without having to hard-code each one. We can map over the array and
create list items for as many ingredients as there are:
React.createElement(
"ul",
{ className: "ingredients" },
items.map(ingredient => React.createElement("li", null, ingredient))
);
This syntax creates a React element for each ingredient in the array.
Each string is displayed in the list item’s children as text. The value for
each ingredient is displayed as the list item.
When running this code, you’ll see a console warning like the one
shown in Figure 4-1.
Figure 4-1. Console warning
When we build a list of child elements by iterating through an array,
React likes each of those elements to have a key property. The key
property is used by React to help it update the DOM efficiently. You
can make this warning go away by adding a unique key property to
each of the list item elements. You can use the array index for each
ingredient as that unique value:
React.createElement(
"ul",
{ className: "ingredients" },
items.map((ingredient, i) =>
React.createElement("li", { key: i }, ingredient)
)
);
We’ll cover keys in more detail when we discuss JSX, but adding this
to each list item will clear the console warning.
React Components
No matter its size, its contents, or what technologies are used to create
it, a user interface is made up of parts. Buttons. Lists. Headings. All of
these parts, when put together, make up a user interface. Consider a
recipe application with three different recipes. The data is different in
each box, but the parts needed to create a recipe are the same (see
Figure 4-2).
Figure 4-2. Recipes app
In React, we describe each of these parts as a component. Components
allow us to reuse the same structure, and then we can populate those
structures with different sets of data.
When considering a user interface you want to build with React, look
for opportunities to break down your elements into reusable pieces. For
example, the recipes in Figure 4-3 have a title, ingredients list, and
instructions. All are part of a larger recipe or app component. We could
create a component for each of the highlighted parts: ingredients,
instructions, and so on.
Figure 4-3. Each component is outlined: App, IngredientsList, Instructions
Think about how scalable this is. If we want to display one recipe, our
component structure will support this. If we want to display 10,000
recipes, we’ll just create 10,000 new instances of that component.
We’ll create a component by writing a function. That function will
return a reusable part of a user interface. Let’s create a function that
returns an unordered list of ingredients. This time, we’ll make dessert
with a function called IngredientsList:
function IngredientsList() {
return React.createElement(
"ul",
{ className: "ingredients" },
React.createElement("li", null, "1 cup unsalted butter"),
React.createElement("li", null, "1 cup crunchy peanut butter"),
React.createElement("li", null, "1 cup brown sugar"),
React.createElement("li", null, "1 cup white sugar"),
React.createElement("li", null, "2 eggs"),
React.createElement("li", null, "2.5 cups all purpose flour"),
React.createElement("li", null, "1 teaspoon baking powder"),
React.createElement("li", null, "0.5 teaspoon salt")
);
}
ReactDOM.render(
React.createElement(IngredientsList, null, null),
document.getElementById("root")
);
The component’s name is IngredientsList, and the function outputs
elements that look like this:
<IngredientsList>
<ul className="ingredients">
<li>1 cup unsalted butter</li>
<li>1 cup crunchy peanut butter</li>
<li>1 cup brown sugar</li>
<li>1 cup white sugar</li>
<li>2 eggs</li>
<li>2.5 cups all purpose flour</li>
<li>1 teaspoon baking powder</li>
<li>0.5 teaspoon salt</li>
</ul>
</IngredientsList>
This is pretty cool, but we’ve hardcoded this data into the component.
What if we could build one component and then pass data into that
component as properties? And then what if that component could
render the data dynamically? Maybe someday that will happen!
Just kidding—that day is now. Here’s an array of secretIngredients
needed to put together a recipe:
const secretIngredients = [
"1 cup unsalted butter",
"1 cup crunchy peanut butter",
"1 cup brown sugar",
"1 cup white sugar",
"2 eggs",
"2.5 cups all purpose flour",
"1 teaspoon baking powder",
"0.5 teaspoon salt"
];
Then we’ll adjust the IngredientsList component to map over these
items, constructing an li for however many items are in the items
array:
function IngredientsList() {
return React.createElement(
"ul",
{ className: "ingredients" },
items.map((ingredient, i) =>
React.createElement("li", { key: i }, ingredient)
)
);
}
Then we’ll pass those secretIngredients as a property called items,
which is the second argument used in createElement:
ReactDOM.render(
React.createElement(IngredientsList, { items: secretIngredients },
null),
document.getElementById("root")
);
Now, let’s look at the DOM. The data property items is an array with
eight ingredients. Because we made the li tags using a loop, we were
able to add a unique key using the index of the loop:
<IngredientsList items="[...]">
<ul className="ingredients">
<li key="0">1 cup unsalted butter</li>
<li key="1">1 cup crunchy peanut butter</li>
<li key="2">1 cup brown sugar</li>
<li key="3">1 cup white sugar</li>
<li key="4">2 eggs</li>
<li key="5">2.5 cups all purpose flour</li>
<li key="6">1 teaspoon baking powder</li>
<li key="7">0.5 teaspoon salt</li>
</ul>
</IngredientsList>
Creating our component this way will make the component more
flexible. Whether the items array is one item or a hundred items long,
the component will render each as a list item.
Another adjustment we can make here is to reference the items array
from React props. Instead of mapping over the global items, we’ll
make items available on the props object. Start by passing props to
the function, then mapping over props.items:
function IngredientsList(props) {
return React.createElement(
"ul",
{ className: "ingredients" },
props.items.map((ingredient, i) =>
React.createElement("li", { key: i }, ingredient)
)
);
}
We could also clean up the code a bit by destructuring items from
props:
function IngredientsList({ items }) {
return React.createElement(
"ul",
{ className: "ingredients" },
items.map((ingredient, i) =>
React.createElement("li", { key: i }, ingredient)
)
);
}
Everything that’s associated with the UI for IngredientsList is
encapsulated into one component. Everything we need is right there.
React Components: A Historical Tour
Before there were function components, there were other ways to
create components. While we won’t spend a great deal of time on these
approaches, it’s important to understand the history of React
components, particularly when dealing with these APIs in legacy
codebases. Let’s take a little historical tour of React APIs of times gone
by.
TOUR STOP 1: CREATECLASS
When React was first made open source in 2013, there was one way to
create a component: createClass. The use of React.createClass to
create a component looks like this:
const IngredientsList = React.createClass({
displayName: "IngredientsList",
render() {
return React.createElement(
"ul",
{ className: "ingredients" },
this.props.items.map((ingredient, i) =>
React.createElement("li", { key: i }, ingredient)
)
);
}
});
Components that used createClass would have a render() method
that described the React element(s) that should be returned and
rendered. The idea of the component was the same: we’d describe a
reusable bit of UI to render.
In React 15.5 (April 2017), React started throwing warnings if
createClass was used. In React 16 (September 2017),
React.createClass was officially deprecated and was moved to its
own package, create-react-class.
TOUR STOP 2: CLASS COMPONENTS
When class syntax was added to JavaScript with ES 2015, React
introduced a new method for creating React components. The
React.Component API allowed you to use class syntax to create a new
component instance:
class IngredientsList extends React.Component {
render() {
return React.createElement(
"ul",
{ className: "ingredients" },
this.props.items.map((ingredient, i) =>
React.createElement("li", { key: i }, ingredient)
)
);
}
}
It’s still possible to create a React component using class syntax, but be
forewarned that React.Component is on the path to deprecation as
well. Although it’s still supported, you can expect this to go the way of
React.createClass, another old friend who shaped you but who you
won’t see as often because they moved away and you moved on. From
now on, we’ll use functions to create components in this book and only
briefly point out older patterns for reference.
Chapter 5. React with JSX
In the last chapter, we dove deep into how React works, breaking down
our React applications into small reusable pieces called components.
These components render trees of elements and other components.
Using the createElement function is a good way to see how React
works, but as React developers, that’s not what we do. We don’t go
around composing complex, barely readable trees of JavaScript syntax
and call it fun. In order to work efficiently with React, we need one
more thing: JSX.
JSX combines the JS from JavaScript and the X from XML. It is a
JavaScript extension that allows us to define React elements using a
tag-based syntax directly within our JavaScript code. Sometimes JSX
is confused with HTML because they look similar. JSX is just another
way of creating React elements, so you don’t have to pull your hair out
looking for the missing comma in a complex createElement call.
In this chapter, we’re going to discuss how to use JSX to construct a
React application.
React Elements as JSX
Facebook’s React team released JSX when they released React to
provide a concise syntax for creating complex DOM trees with
attributes. They also hoped to make React more readable like HTML
and XML. In JSX, an element’s type is specified with a tag. The tag’s
attributes represent the properties. The element’s children can be added
between the opening and closing tags.
You can also add other JSX elements as children. If you have an
unordered list, you can add child list item elements to it with JSX tags.
It looks very similar to HTML:
<ul>
<li>1 lb Salmon</li>
<li>1 cup Pine Nuts</li>
<li>2 cups Butter Lettuce</li>
<li>1 Yellow Squash</li>
<li>1/2 cup Olive Oil</li>
<li>3 Cloves of Garlic</li>
</ul>
JSX works with components as well. Simply define the component
using the class name. We pass an array of ingredients to the
IngredientsList as a property with JSX, as shown in Figure 5-1.
Figure 5-1. Creating the IngredientsList with JSX
When we pass the array of ingredients to this component, we need to
surround it with curly braces. This is called a JavaScript expression,
and we must use these when passing JavaScript values to components
as properties. Component properties will take two types: either a string
or a JavaScript expression. JavaScript expressions can include arrays,
objects, and even functions. In order to include them, you must
surround them in curly braces.
JSX Tips
JSX might look familiar, and most of the rules result in syntax that’s
similar to HTML. However, there are a few considerations you should
understand when working with JSX.
NESTED COMPONENTS
JSX allows you to add components as children of other components.
For example, inside the IngredientsList, we can render another
component called Ingredient multiple times:
<IngredientsList>
<Ingredient />
<Ingredient />
<Ingredient />
</IngredientsList>
CLASSNAME
Since class is a reserved word in JavaScript, className is used to
define the class attribute instead:
<h1 className="fancy">Baked Salmon</h1>
JAVASCRIPT EXPRESSIONS
JavaScript expressions are wrapped in curly braces and indicate where
variables will be evaluated and their resulting values returned. For
example, if we want to display the value of the title property in an
element, we can insert that value using a JavaScript expression. The
variable will be evaluated and its value returned:
<h1>{title}</h1>
Values of types other than string should also appear as JavaScript
expressions:
<input type="checkbox" defaultChecked={false} />
EVALUATION
The JavaScript that’s added in between the curly braces will get
evaluated. This means that operations such as concatenation or addition
will occur. This also means that functions found in JavaScript
expressions will be invoked:
<h1>{"Hello" + title}</h1>
<h1>{title.toLowerCase().replace}</h1>
Mapping Arrays with JSX
JSX is JavaScript, so you can incorporate JSX directly inside of
JavaScript functions. For example, you can map an array to JSX
elements:
<ul>
{props.ingredients.map((ingredient, i) => (
<li key="{i}">{ingredient}</li>
))}
</ul>
JSX looks clean and readable, but it can’t be interpreted with a
browser. All JSX must be converted into createElement calls.
Luckily, there’s an excellent tool for this task: Babel.
Babel
Many software languages require you to compile your source code.
JavaScript is an interpreted language: the browser interprets the code as
text, so there’s no need to compile JavaScript. However, not all
browsers support the latest JavaScript syntax, and no browser supports
JSX syntax. Since we want to use the latest features of JavaScript along
with JSX, we’re going to need a way to convert our fancy source code
into something that the browser can interpret. This process is called
compiling, and it’s what Babel is designed to do.
The first version of the project was called 6to5, and it was released in
September 2014. 6to5 was a tool that could be used to convert ES6
syntax to ES5 syntax, which was more widely supported by web
browsers. As the project grew, it aimed to be a platform to support all
of the latest changes in ECMAScript. It also grew to support
converting JSX into JavaScript. The project was renamed Babel in
February 2015.
Babel is used in production at Facebook, Netflix, PayPal, Airbnb, and
more. Previously, Facebook had created a JSX transformer that was
their standard, but it was soon retired in favor of Babel.
There are many ways of working with Babel. The easiest way to get
started is to include a link to the Babel CDN directly in your HTML,
which will compile any code in script blocks that have a type of
“text/babel.” Babel will compile the source code on the client before
running it. Although this may not be the best solution for production,
it’s a great way to get started with JSX:
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>React Examples</title>
</head>
<body>
<div id="root"></div>
<!-- React Library & React DOM -->
<script
src="https://unpkg.com/react@16.8.6/umd/react.development.js">
</script>
<script
src="https://unpkg.com/react-dom@16.8.6/umd/react-dom.development.js">
</script>
<script
src="https://unpkg.com/@babel/standalone/babel.min.js">
</script>
<script type="text/babel">
// JSX code here. Or link to separate JavaScript file that contains
JSX.
</script>
</body>
</html>
CONSOLE WARNING IN THE BROWSER WITH
IN-BROWSER BABEL
When using the in-browser transformer, you’ll see a warning that says to
precompile scripts for production. Don’t worry about that warning for the
purposes of this and any other small demos. We’ll upgrade to production-ready
Babel later in the chapter.
Recipes as JSX
JSX provides us with a nice, clean way to express React elements in
our code that makes sense to us and is immediately readable by
developers. The drawback of JSX is that it’s not readable by the
browser. Before our code can be interpreted by the browser, it needs to
be converted from JSX into JavaScript.
This data array contains two recipes, and this represents our
application’s current state:
const data = [
{
name: "Baked Salmon",
ingredients: [
{ name: "Salmon", amount: 1, measurement: "l lb" },
{ name: "Pine Nuts", amount: 1, measurement: "cup" },
{ name: "Butter Lettuce", amount: 2, measurement: "cups" },
{ name: "Yellow Squash", amount: 1, measurement: "med" },
{ name: "Olive Oil", amount: 0.5, measurement: "cup" },
{ name: "Garlic", amount: 3, measurement: "cloves" }
],
steps: [
"Preheat the oven to 350 degrees.",
"Spread the olive oil around a glass baking dish.",
"Add the yellow squash and place in the oven for 30 mins.",
"Add the salmon, garlic, and pine nuts to the dish.",
"Bake for 15 minutes.",
"Remove from oven. Add the lettuce and serve."
]
},
{
name: "Fish Tacos",
ingredients: [
{ name: "Whitefish", amount: 1, measurement: "l lb" },
{ name: "Cheese", amount: 1, measurement: "cup" },
{ name: "Iceberg Lettuce", amount: 2, measurement: "cups" },
{ name: "Tomatoes", amount: 2, measurement: "large" },
{ name: "Tortillas", amount: 3, measurement: "med" }
],
steps: [
"Cook the fish on the grill until cooked through.",
"Place the fish on the 3 tortillas.",
"Top them with lettuce, tomatoes, and cheese."
]
}
];
The data is expressed in an array of two JavaScript objects. Each object
contains the name of the recipe, a list of the ingredients required, and a
list of steps necessary to cook the recipe.
We can create a UI for these recipes with two components: a Menu
component for listing the recipes and a Recipe component that
describes the UI for each recipe. It’s the Menu component that we’ll
render to the DOM. We’ll pass our data to the Menu component as a
property called recipes:
// The data, an array of Recipe objects
const data = [ ... ];
// A function component for an individual Recipe
function Recipe (props) {
...
}
// A function component for the Menu of Recipes
function Menu (props) {
...
}
// A call to ReactDOM.render to render our Menu into the current DOM
ReactDOM.render(
<Menu recipes={data} title="Delicious Recipes" />,
document.getElementById("root")
);
The React elements within the Menu component are expressed as JSX.
Everything is contained within an article element. A header
element, an h1 element, and a div.recipes element are used to
describe the DOM for our menu. The value for the title property will
be displayed as text within the h1:
function Menu(props) {
return (
<article>
<header>
<h1>{props.title}</h1>
</header>
<div className="recipes" />
</article>
);
}
Inside of the div.recipes element, we add a component for each
recipe:
<div className="recipes">
{props.recipes.map((recipe, i) => (
<Recipe
key={i}
name={recipe.name}
ingredients={recipe.ingredients}
steps={recipe.steps}
/>
))}
</div>
In order to list the recipes within the div.recipes element, we use
curly braces to add a JavaScript expression that will return an array of
children. We can use the map function on the props.recipes array to
return a component for each object within the array. As mentioned
previously, each recipe contains a name, some ingredients, and cooking
instructions (steps). We’ll need to pass this data to each Recipe as
props. Also remember that we should use the key property to uniquely
identify each element.
You could also refactor this to use spread syntax. The JSX spread
operator works like the object spread operator. It will add each field of
the recipe object as a property of the Recipe component. The syntax
here will supply all properties to the component:
{
props.recipes.map((recipe, i) => <Recipe key={i} {...recipe} />);
}
Remember that this shortcut will provide all the properties to the
Recipe component. This could be a good thing but might also add too
many properties to the component.
Another place we can make a syntax improvement to our Menu
component is where we take in the props argument. We can use object
destructuring to scope the variables to this function. This allows us to
access the title and recipes variables directly, no longer having to
prefix them with props:
function Menu({ title, recipes }) {
return (
<article>
<header>
<h1>{title}</h1>
</header>
<div className="recipes">
{recipes.map((recipe, i) => (
<Recipe key={i} {...recipe} />
))}
</div>
</article>
);
}
Now let’s code the component for each individual recipe:
function Recipe({ name, ingredients, steps }) {
return (
<section id={name.toLowerCase().replace(/ /g, "-")}>
<h1>{name}</h1>
<ul className="ingredients">
{ingredients.map((ingredient, i) => (
<li key={i}>{ingredient.name}</li>
))}
</ul>
<section className="instructions">
<h2>Cooking Instructions</h2>
{steps.map((step, i) => (
<p key={i}>{step}</p>
))}
</section>
</section>
);
}
Each recipe has a string for the name, an array of objects for
ingredients, and an array of strings for the steps. Using object
destructuring, we can tell this component to locally scope those fields
by name so we can access them directly without having to use
props.name, props.ingredients, or props.steps.
The first JavaScript expression we see is being used to set the id
attribute for the root section element. It’s converting the recipe’s
name to a lowercase string and globally replacing spaces with dashes.
The result is that “Baked Salmon” will be converted to “baked-salmon”
(and likewise, if we had a recipe with the name “Boston Baked Beans,”
it would be converted to “boston-baked-beans”) before it’s used as the
id attribute in our UI. The value for name is also being displayed in an
h1 as a text node.
Inside of the unordered list, a JavaScript expression is mapping each
ingredient to an li element that displays the name of the ingredient.
Within our instructions section, we see the same pattern being used to
return a paragraph element where each step is displayed. These map
functions are returning arrays of child elements.
The complete code for the application should look like this:
const data = [
{
name: "Baked Salmon",
ingredients: [
{ name: "Salmon", amount: 1, measurement: "l lb" },
{ name: "Pine Nuts", amount: 1, measurement: "cup" },
{ name: "Butter Lettuce", amount: 2, measurement: "cups" },
{ name: "Yellow Squash", amount: 1, measurement: "med" },
{ name: "Olive Oil", amount: 0.5, measurement: "cup" },
{ name: "Garlic", amount: 3, measurement: "cloves" }
],
steps: [
"Preheat the oven to 350 degrees.",
"Spread the olive oil around a glass baking dish.",
"Add the yellow squash and place in the oven for 30 mins.",
"Add the salmon, garlic, and pine nuts to the dish.",
"Bake for 15 minutes.",
"Remove from oven. Add the lettuce and serve."
]
},
{
name: "Fish Tacos",
ingredients: [
{ name: "Whitefish", amount: 1, measurement: "l lb" },
{ name: "Cheese", amount: 1, measurement: "cup" },
{ name: "Iceberg Lettuce", amount: 2, measurement: "cups" },
{ name: "Tomatoes", amount: 2, measurement: "large" },
{ name: "Tortillas", amount: 3, measurement: "med" }
],
steps: [
"Cook the fish on the grill until hot.",
"Place the fish on the 3 tortillas.",
"Top them with lettuce, tomatoes, and cheese."
]
}
];
function Recipe({ name, ingredients, steps }) {
return (
<section id={name.toLowerCase().replace(/ /g, "-")}>
<h1>{name}</h1>
<ul className="ingredients">
{ingredients.map((ingredient, i) => (
<li key={i}>{ingredient.name}</li>
))}
</ul>
<section className="instructions">
<h2>Cooking Instructions</h2>
{steps.map((step, i) => (
<p key={i}>{step}</p>
))}
</section>
</section>
);
}
function Menu({ title, recipes }) {
return (
<article>
<header>
<h1>{title}</h1>
</header>
<div className="recipes">
{recipes.map((recipe, i) => (
<Recipe key={i} {...recipe} />
))}
</div>
</article>
);
}
ReactDOM.render(
<Menu recipes={data} title="Delicious Recipes" />,
document.getElementById("root")
);
When we run this code in the browser, React will construct a UI using
our instructions with the recipe data as shown in Figure 5-2.
If you’re using Google Chrome and have the React Developer Tools
Extension installed, you can take a look at the present state of the
component tree. To do this, open the developer tools and select the
Components tab, as shown in Figure 5-3.
Here we can see the Menu and its child elements. The data array
contains two objects for recipes, and we have two Recipe elements.
Each Recipe element has properties for the recipe name, ingredients,
and steps. The ingredients and steps are passed down to their own
components as data.
The components are constructed based on the application’s data being
passed to the Menu component as a property. If we change the recipes
array and rerender our Menu component, React will change this DOM
a
s
e
f
f
i
c
i
e
n
t
l
y
a
s
p
o
s
s
i
b
l
e.
Figure 5-2. Delicious Recipes output

Figure 5-3. Resulting virtual DOM in React Developer Tools
React Fragments
In the previous section, we rendered the Menu component, a parent
component that rendered the Recipe component. We want to take a
moment to look at a small example of rendering two sibling
components using a React fragment. Let’s start by creating a new
component called Cat that we’ll render to the DOM at the root:
function Cat({ name }) {
return <h1>The cat's name is {name}</h1>;
}
ReactDOM.render(<Cat name="Jungle" />, document.getElementById("root"));
This will render the h1 as expected, but what might happen if we added
a p tag to the Cat component at the same level as the h1?
function Cat({ name }) {
return (
<h1>The cat's name is {name}</h1>
<p>He's good.</p>
);
}
Immediately, we’ll see an error in the console that reads Adjacent JSX
elements must be wrapped in an enclosing tag and
recommends using a fragment. This is where fragments come into
play! React will not render two or more adjacent or sibling elements as
a component, so we used to have to wrap these in an enclosing tag like
a div. This led to a lot of unnecessary tags being created, though, and a
bunch of wrappers without much purpose. If we use a React fragment,
we can mimic the behavior of a wrapper without actually creating a
new tag.
Start by wrapping the adjacent tags, the h1 and p, with a
React.Fragment tag:
function Cat({ name }) {
return (
<React.Fragment>
<h1>The cat's name is {name}</h1>
<p>He's good.</p>
</React.Fragment>
);
}
Adding this clears the warning. You also can use a fragment shorthand
to make this look even cleaner:
function Cat({ name }) {
return (
<>
<h1>The cat's name is {name}</h1>
<p>He's good.</p>
</>
);
}
If you look at the DOM, the fragment is not visible in the resulting tree:
<div id="root">
<h1>The cat's name is Jungle</h1>
<p>He's good</p>
</div>
Fragments are a relatively new feature of React and do away with the
need for extra wrapper tags that can pollute the DOM.
Intro to webpack
Once we start working with React in real projects, there are a lot of
questions to consider: How do we want to deal with JSX and ESNext
transformation? How can we manage our dependencies? How can we
optimize our images and CSS?
Many different tools have emerged to answer these questions,
including Browserify, gulp, Grunt, Prepack, and more. Due to its
features and widespread adoption by large companies, webpack has
also emerged as one of the leading tools for bundling.
The React ecosystem has matured to include tools like create-react-app,
Gatsby, and Code Sandbox. When you use these tools, a lot of the
details about how the code gets compiled are abstracted away. For the
remainder of this chapter, we are going to set up our own webpack
build. This day in age, understanding that your JavaScript/React code
is being compiled by something like webpack is vital, but knowing
how to compile your JavaScript/React with something like webpack is
not as important. We understand if you want to skip ahead.
Webpack is billed as a module bundler. A module bundler takes all of
our different files (JavaScript, LESS, CSS, JSX, ESNext, and so on)
and turns them into a single file. The two main benefits of bundling are
modularity and network performance.
Modularity will allow you to break down your source code into parts,
or modules, that are easier to work with, especially in a team
environment.
Network performance is gained by only needing to load one
dependency in the browser: the bundle. Each script tag makes an
HTTP request, and there’s a latency penalty for each HTTP request.
Bundling all the dependencies into a single file allows you to load
everything with one HTTP request, thereby avoiding additional
latency.
Aside from code compilation, webpack also can handle:
Code splitting
Splits up your code into different chunks that can be loaded when
you need them. Sometimes these are called rollups or layers; the
aim is to break up code as needed for different pages or devices.
Minification
Removes whitespace, line breaks, lengthy variable names, and
unnecessary code to reduce the file size.
Feature Flagging
Sends code to one or more—but not all—environments when
testing out features.
Hot Module Replacement (HMR)
Watches for changes in source code. Changes only the updated
modules immediately.
The Recipes app we built earlier in this chapter has some limitations
that webpack will help us alleviate. Using a tool like webpack to
statically build client JavaScript makes it possible for teams to work
together on large-scale web applications. We can also gain the
following benefits by incorporating the webpack module bundler:
Modularity
Using the module pattern to export modules that will later be
imported or required by another part of the application makes
source code more approachable. It allows development teams to
work together, by allowing them to create and work with separate
files that will be statically combined into a single file before
sending to production.
Composition
With modules, we can build small, simple, reusable React
components that we can compose efficiently into applications.
Smaller components are easier to comprehend, test, and reuse.
They’re also easier to replace down the line when enhancing
applications.
Speed
Packaging all the application’s modules and dependencies into a
single client bundle will reduce the load time of an application
because there’s latency associated with each HTTP request.
Packaging everything together in a single file means that the client
will only need to make a single request. Minifying the code in the
bundle will improve load time as well.
Consistency
Since webpack will compile JSX and JavaScript, we can start using
tomorrow’s JavaScript syntax today. Babel supports a wide range
of ESNext syntax, which means we don’t have to worry about
whether the browser supports our code. It allows developers to
consistently use cutting-edge JavaScript syntax.
Creating the Project
To demonstrate how we might set up a React project from scratch, let’s
go ahead and create a new folder on our computer called recipes-app:
mkdir recipes-app
cd recipes-app
For this project, we’re going to go through the following steps:
1. Create the project.
2. Break down the recipe app into components that live in
different files.
3. Set up a webpack build that incorporates Babel.
CREATE-REACT-APP
There’s a tool called Create React App that can be used to autogenerate a React
project with all of this preconfigured. We’re going to take a closer look at what’s
happening behind the scenes before abstracting these steps away with a tool.
1. CREATE THE PROJECT
Next, we’ll create the project and package.json file with npm, sending
the -y flag to use all of the defaults. We’ll also install webpack,
webpack-cli, react, and react-dom:
npm init -y
npm install react react-dom serve
If we’re using npm 5, we don’t need to send the --save flag when
installing. Next, we’ll create the following directory structure to house
the components:
recipes-app (folder)
> node_modules (already added with npm install command)
> package.json (already added with npm init command)
> package-lock.json (already added with npm init command)
> index.html
> /src (folder)
> index.js
> /data (folder)
> recipes.json
> /components (folder)
> Recipe.js
> Instructions.js
> Ingredients.js
FILE ORGANIZATION
There’s no one way to organize the files in a React project. This is just one
possible strategy.
2. BREAK COMPONENTS INTO MODULES
Currently, the Recipe component is doing quite a bit. We’re displaying
the name of the recipe, constructing an unordered list of ingredients,
and displaying the instructions, with each step getting its own
paragraph element. This component should be placed in the Recipe.js
file. In any file where we’re using JSX, we’ll need to import React at
the top:
// ./src/components/Recipe.js
import React from "react";
export default function Recipe({ name, ingredients, steps }) {
return (
<section id="baked-salmon">
<h1>{name}</h1>
<ul className="ingredients">
{ingredients.map((ingredient, i) => (
<li key={i}>{ingredient.name}</li>
))}
</ul>
<section className="instructions">
<h2>Cooking Instructions</h2>
{steps.map((step, i) => (
<p key={i}>{step}</p>
))}
</section>
</section>
);
}
A more functional approach to the Recipe component would be to
break it down into smaller, more focused function components and
compose them together. We can start by pulling the instructions out
into their own component and creating a module in a separate file we
can use for any set of instructions.
In that new file called Instructions.js, create the following component:
// ./src/components/Instructions.js
import React from "react";
export default function Instructions({ title, steps }) {
return (
<section className="instructions">
<h2>{title}</h2>
{steps.map((s, i) => (
<p key={i}>{s}</p>
))}
</section>
);
}
Here, we’ve created a new component called Instructions. We’ll
pass the title of the instructions and the steps to this component. This
way, we can reuse this component for “Cooking Instructions,” “Baking
Instructions,” “Prep Instructions,” or a “Pre-cook Checklist”—anything
that has steps.
Now think about the ingredients. In the Recipe component, we’re only
displaying the ingredient names, but each ingredient in the data for the
recipe has an amount and measurement as well. We’ll create a
component called Ingredient for this:
// ./src/components/Ingredient.js
import React from "react";
export default function Ingredient({ amount, measurement, name }) {
return (
<li>
{amount} {measurement} {name}
</li>
);
}
Here, we assume each ingredient has an amount, a measurement, and a
name. We destructure those values from our props object and display
them each in independent classed span elements.
Using the Ingredient component, we can construct an
IngredientsList component that can be used any time we need to
display a list of ingredients:
// ./src/components/IngredientsList.js
import React from "react";
import Ingredient from "./Ingredient";
export default function IngredientsList({ list }) {
return (
<ul className="ingredients">
{list.map((ingredient, i) => (
<Ingredient key={i} {...ingredient} />
))}
</ul>
);
}
In this file, we first import the Ingredient component because we’re
going to use it for each ingredient. The ingredients are passed to this
component as an array in a property called list. Each ingredient in the
list array will be mapped to the Ingredient component. The JSX
spread operator is used to pass all the data to the Ingredient
component as props.
Using spread operator:
<Ingredient {...ingredient} />
is another way of expressing:
<Ingredient
amount={ingredient.amount}
measurement={ingredient.measurement}
name={ingredient.name}
/>
So, given an ingredient with these fields:
let ingredient = {
amount: 1,
measurement: "cup",
name: "sugar"
};
We get:
<Ingredient amount={1} measurement="cup" name="sugar" />
Now that we have components for ingredients and instructions, we can
compose recipes using these components:
// ./src/components/Recipe.js
import React from "react";
import IngredientsList from "./IngredientsList";
import Instructions from "./Instructions";
function Recipe({ name, ingredients, steps }) {
return (
<section id={name.toLowerCase().replace(/ /g, "-")}>
<h1>{name}</h1>
<IngredientsList list={ingredients} />
<Instructions title="Cooking Instructions" steps={steps} />
</section>
);
}
export default Recipe;
First, we import the components we’re going to use: IngredientsList
and Instructions. Now we can use them to create the Recipe
component. Instead of a bunch of complicated code building out the
entire recipe in one place, we’ve expressed our recipe more
declaratively by composing smaller components. Not only is the code
nice and simple, but it also reads well. This shows us that a recipe
should display the name of the recipe, a list of ingredients, and some
cooking instructions. We’ve abstracted away what it means to display
ingredients and instructions into smaller, simple components.
In a modular approach, the Menu component would look pretty similar.
The key difference is that it would live in its own file, import the
modules it needs to use, and export itself:
// ./src/components/Menu.js
import React from "react";
import Recipe from "./Recipe";
function Menu({ recipes }) {
return (
<article>
<header>
<h1>Delicious Recipes</h1>
</header>
<div className="recipes">
{recipes.map((recipe, i) => (
<Recipe key={i} {...recipe} />
))}
</div>
</article>
);
}
export default Menu;
We still need to use ReactDOM to render the Menu component. The
main file for the project is index.js. This will be responsible for
rendering the component to the DOM.
Let’s create this file:
// ./src/index.js
import React from "react";
import { render } from "react-dom";
import Menu from "./components/Menu";
import data from "./data/recipes.json";
render(<Menu recipes={data} />, document.getElementById("root"));
The first four statements import the necessary modules for our app to
work. Instead of loading react and react-dom via the script tag, we
import them so webpack can add them to our bundle. We also need the
Menu component and a sample data array that has been moved to a
separate module. It still contains two recipes: Baked Salmon and Fish
Tacos.
All of our imported variables are local to the index.js file. When we
render the Menu component, we pass the array of recipe data to this
component as a property.
The data is being pulled from the recipes.json file. This is the same
data we used earlier in the chapter, but now it’s following valid JSON
formatting rules:
// ./src/data/recipes.json
[
{
"name": "Baked Salmon",
"ingredients": [
{ "name": "Salmon", "amount": 1, "measurement": "lb" },
{ "name": "Pine Nuts", "amount": 1, "measurement": "cup" },
{ "name": "Butter Lettuce", "amount": 2, "measurement": "cups" },
{ "name": "Yellow Squash", "amount": 1, "measurement": "med" },
{ "name": "Olive Oil", "amount": 0.5, "measurement": "cup" },
{ "name": "Garlic", "amount": 3, "measurement": "cloves" }
],
"steps": [
"Preheat the oven to 350 degrees.",
"Spread the olive oil around a glass baking dish.",
"Add the yellow squash and place in the oven for 30 mins.",
"Add the salmon, garlic, and pine nuts to the dish.",
"Bake for 15 minutes.",
"Remove from oven. Add the lettuce and serve."
]
},
{
"name": "Fish Tacos",
"ingredients": [
{ "name": "Whitefish", "amount": 1, "measurement": "lb" },
{ "name": "Cheese", "amount": 1, "measurement": "cup" },
{ "name": "Iceberg Lettuce", "amount": 2, "measurement": "cups" },
{ "name": "Tomatoes", "amount": 2, "measurement": "large" },
{ "name": "Tortillas", "amount": 3, "measurement": "med" }
],
"steps": [
"Cook the fish on the grill until cooked through.",
"Place the fish on the 3 tortillas.",
"Top them with lettuce, tomatoes, and cheese."
]
}
]
Now that we’ve pulled our code apart into separate modules and files,
let’s create a build process with webpack that will put everything back
together into a single file. You may be thinking, “Wait, we just did all
of that work to break everything apart, and now we’re going to use a
tool to put it back together? Why on Earth…?” Splitting projects into
separate files typically makes larger projects easier to manage because
team members can work on separate components without overlap. It
also means that files can be easier to test.
3. CREATING THE WEBPACK BUILD
In order to create a static build process with webpack, we’ll need to
install a few things. Everything we need can be installed with npm:
npm install --save-dev webpack webpack-cli
Remember that we’ve already installed React and ReactDOM.
For this modular Recipes app to work, we’re going to need to tell
webpack how to bundle our source code into a single file. As of
version 4.0.0, webpack does not require a configuration file to bundle a
project. If we don’t include a config file, webpack will run the defaults
to package our code. Using a config file, though, means we’ll be able
to customize our setup. Plus, this shows us some of the magic of
webpack instead of hiding it away. The default webpack configuration
file is always webpack.config.js.
The starting file for our Recipes app is index.js. It imports React,
ReactDOM, and the Menu.js file. This is what we want to run in the
browser first. Wherever webpack finds an import statement, it will
find the associated module in the filesystem and include it in the
bundle. index.js imports Menu.js, Menu.js imports Recipe.js, Recipe.js
imports Instructions.js and IngredientsList.js, and IngredientsList.js
imports Ingredient.js. Webpack will follow this import tree and include
all of these necessary modules in our bundle. Traversal through all
these files creates what’s called a dependency graph. A dependency is
just something our app needs, like a component file, a library file like
React, or an image. Picture each file we need as a circle on the graph,
with webpack drawing all the lines between the circles to create the
graph. That graph is the bundle.
IMPORT STATEMENTS
We’re using import statements, which are not presently supported by most
browsers or by Node.js. The reason import statements work is that Babel will
convert them into require('module/path'); statements in our final code. The
require function is how CommonJS modules are typically loaded.
As webpack builds our bundle, we need to tell it to transform JSX to
React elements.
The webpack.config.js file is just another module that exports a
JavaScript literal object that describes the actions webpack should take.
The configuration file should be saved to the root folder of the project,
right next to the index.js file:
// ./webpack.config.js
var path = require("path");
module.exports = {
entry: "./src/index.js",
output: {
path: path.join(__dirname, "dist", "assets"),
filename: "bundle.js"
}
};
First, we tell webpack that our client entry file is ./src/index.js. It will
automatically build the dependency graph based on import statements
starting in that file. Next, we specify that we want to output a bundled
JavaScript file to ./dist/bundle.js. This is where webpack will place the
final packaged JavaScript.
Next, let’s install the necessary Babel dependencies. We’ll need
babel-loader and @babel/core:
npm install babel-loader @babel/core --save-dev
The next set of instructions for webpack consists of a list of loaders to
run on specified modules. This will be added to the config file under
the module field:
module.exports = {
entry: "./src/index.js",
output: {
path: path.join(__dirname, "dist", "assets"),
filename: "bundle.js"
},
module: {
rules: [{ test: /\.js$/, exclude: /node_modules/, loader: "babelloader" }]
}
};
The rules field is an array because there are many types of loaders
you can incorporate with webpack. In this example, we’re only
incorporating the babel-loader. Each loader is a JavaScript object.
The test field is a regular expression that matches the file path of each
module that the loader should operate on. In this case, we’re running
the babel-loader on all imported JavaScript files except those found
in the node_modules folder.
At this point, we need to specify presets for running Babel. When we
set a preset, we tell Babel which transforms to perform. In other words,
we can say, “Hey Babel. If you see some ESNext syntax here, go ahead
and transform that code into syntax we’re sure the browser
understands. If you see some JSX, transform that too.” Start by
installing the presets:
npm install @babel/preset-env @babel/preset-react --save-dev
Then create one more file at the root of the project: .babelrc:
{
"presets": ["@babel/preset-env", "@babel/preset-react"]
}
All right! We’ve created something pretty cool: a project that
resembles a real React app! Let’s go ahead and run webpack to make
sure this works.
Webpack is run statically. Typically, bundles are created before the app
is deployed to the server. You can run it from the command line using
npx:
npx webpack --mode development
Webpack will either succeed and create a bundle or fail and show you
an error. Most errors have to do with broken import references. When
debugging webpack errors, look closely at the filenames and file paths
used in import statements.
You can also add an npm script to your package.json file to create a
shortcut:
"scripts": {
"build": "webpack --mode production"
},
Then you can run the shortcut to generate the bundle:
npm run build
Loading the Bundle
We have a bundle, so now what? We exported the bundle to the dist
folder. This folder contains the files we want to run on the web server.
The dist folder is where the index.html file should be placed. This file
needs to include a target div element where the React Menu component
will be mounted. It also requires a single script tag that will load our
bundled JavaScript:
// ./dist/index.html
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>React Recipes App</title>
</head>
<body>
<div id="root"></div>
<script src="bundle.js"></script>
</body>
</html>
This is the home page for your app. It will load everything it needs
from one file, one HTTP request: bundle.js. You’ll need to deploy
these files to your web server or build a web server application that will
serve these files with something like Node.js or Ruby on Rails.
Source Mapping
Bundling our code into a single file can cause some setbacks when it
comes time to debug the application in the browser. We can eliminate
this problem by providing a source map. A source map is a file that
maps a bundle to the original source files. With webpack, all we have
to do is add a couple lines to our webpack.config.js file.
//webpack.config.js with source mapping
module.exports = {
...
devtool: "#source-map" // Add this option for source mapping
};
Setting the devtool property to '#source-map' tells webpack that you
want to use source mapping. The next time you run webpack, you’ll
see that two output files are generated and added to the dist folder: the
original bundle.js and bundle.js.map.
The source map is going to let you debug using your original source
files. In the Sources tab of your browser’s developer tools, you should
find a folder named webpack://. Inside of this folder, you’ll see all the
source files in your bundle, as shown in Figure 5-4.
Figure 5-4. Sources panel of Chrome Developer Tools
You can debug from these files using the browser step-through
debugger. Clicking on any line number adds a breakpoint. Refreshing
the browser will pause JavaScript processing when any breakpoints are
reached in your source file. You can inspect scoped variables in the
Scope panel or add variables to watch in the Watch panel.
Create React App
A pretty amazing tool to have at your disposal as a React developer is
Create React App, a command-line tool that autogenerates a React
project. Create React App was inspired by the Ember CLI project, and
it lets developers get started with React projects quickly without the
manual configuration of webpack, Babel, ESLint, and associated tools.
To get started with Create React App, install the package globally:
npm install -g create-react-app
Then, use the command and the name of the folder where you’d like
the app to be created:
create-react-app my-project
NPX
You can also use npx to run Create React App without the need for a global
install. Simply run npx create-react-app my-project.
This will create a React project in that directory with just three
dependencies: React, ReactDOM, and react-scripts. reactscripts was also created by Facebook and is where the real magic
happens. It installs Babel, ESLint, webpack, and more so that you don’t
have to configure them manually. Within the generated project folder,
you’ll also find a src folder containing an App.js file. Here, you can
edit the root component and import other component files.
From within the my-react-project folder, you can run npm start. If
you prefer, you can also run yarn start. This will start your
application on port 3000.
You can run tests with npm test or yarn test. This runs all of the
test files in the project in an interactive mode.
You can also run the npm run build command. Using yarn, run yarn
build.
This will create a production-ready bundle that has been transformed
and minified.
Create React App is a great tool for beginners and experienced React
developers alike. As the tool evolves, more functionality will likely be
added, so you can keep an eye on the changes on GitHub. Another way
to get started with React without having to worry about setting up your
own customized webpack build is to use CodeSandbox. CodeSandbox
is an IDE that runs online at https://codesandbox.io.
In this chapter, we leveled up our React skills by learning about JSX.
We created components. We broke those components into a project
structure, and we learned more about Babel and webpack. Now we’re
ready to take our knowledge of components to the next level. It’s time
to talk about Hooks.
Chapter 6. React State
Management
Data is what makes our React components come to life. The user
interface for recipes that we built in the last chapter is useless without
the array of recipes. It’s the recipes and the ingredients along with clear
instructions that makes such an app worthwhile. Our user interfaces are
tools that creators will use to generate content. In order to build the
best tools possible for our content creators, we’ll need to know how to
effectively manipulate and change data.
In the last chapter, we constructed a component tree: a hierarchy of
components that data was able to flow through as properties. Properties
are half of the picture. State is the other half. The state of a React
application is driven by data that has the ability to change. Introducing
state to the recipe application could make it possible for chefs to create
new recipes, modify existing recipes, and remove old ones.
State and properties have a relationship with each other. When we
work with React applications, we gracefully compose components that
are tied together based on this relationship. When the state of a
component tree changes, so do the properties. The new data flows
through the tree, causing specific leaves and branches to render to
reflect the new content.
In this chapter, we’re going to bring applications to life by introducing
state. We’ll learn to create stateful components and how state can be
sent down a component tree and user interactions back up the
component tree. We’ll learn techniques for collecting form data from
users. And we’ll take a look at the various ways in which we can
separate concerns within our applications by introducing stateful
context providers.
Building a Star Rating Component
We would all be eating terrible food and watching terrible movies
without the five-star rating system. If we plan on letting users drive the
content on our website, we’ll need a way to know if that content is any
good or not. That makes the StarRating component one of the most
important React components you’ll ever build (see Figure 6-1).
Figure 6-1. StarRating component
The StarRating component will allow users to rate content based on a
specific number of stars. Content that’s no good gets one star. Highly
recommended content gets five stars. Users can set the rating for
specific content by clicking on a specific star. First, we’ll need a star,
and we can get one from react-icons:
npm i react-icons
react-icons is an npm library that contains hundreds of SVG icons
that are distributed as React components. By installing it, we just
installed several popular icon libraries that contain hundreds of
common SVG icons. You can browse all the icons in the library. We’re
going to use the star icon from the Font Awesome collection:
import React from "react";
import { FaStar } from "react-icons/fa";
export default function StarRating() {
return [
<FaStar color="red" />,
<FaStar color="red" />,
<FaStar color="red" />,
<FaStar color="grey" />,
<FaStar color="grey" />
];
}
Here, we’ve created a StarRating component that renders five SVG
stars that we’ve imported from react-icons. The first three stars are
filled in with red, and the last two are grey. We render the stars first
because seeing them gives us a roadmap for what we’ll have to build.
A selected star should be filled in with red, and a star that’s not
selected should be greyed out. Let’s create a component that
automatically files the stars based upon the selected property:
const Star = ({ selected = false }) => (
<FaStar color={selected ? "red" : "grey"} />
);
The Star component renders an individual star and uses the selected
property to fill it with the appropriate color. If the selected property is
not passed to this component, we’ll assume that the star should not be
selected and by default will be filled in with grey.
The 5-star rating system is pretty popular, but a 10-star rating system is
far more detailed. We should allow developers to select the total
number of stars they wish to use when they add this component to their
app. This can be accomplished by adding a totalStars property to the
StarRating component:
const createArray = length => [...Array(length)];
export default function StarRating({ totalStars = 5 }) {
return createArray(totalStars).map((n, i) => <Star key={i} />);
}
Here, we added the createArray function from Chapter 2. All we
have to do is supply the length of the array that we want to create and
we get a new array at that length. We use this function with the
totalStars property to create an array of a specific length. Once we
have an array, we can map over it and render Star components. By
default, totalStars is equal to 5, which means this component will
render 5 grey stars, as shown in Figure 6-2.
Figure 6-2. Five stars are displayed
The useState Hook
It’s time to make the StarRating component clickable, which will
allow our users to change the rating. Since the rating is a value that
will change, we’ll store and change that value using React state. We
incorporate state into a function component using a React feature called
Hooks. Hooks contain reusable code logic that is separate from the
component tree. They allow us to hook up functionality to our
components. React ships with several built-in hooks we can use out of
the box. In this case, we want to add state to our React component, so
the first hook we’ll work with is React’s useState hook. This hook is
already available in the react package; we simply need to import it:
import React, { useState } from "react";
import { FaStar } from "react-icons/fa";
The stars the user has selected represents the rating. We’ll create a state
variable called selectedStars, which will hold the user’s rating.
We’ll create this variable by adding the useState hook directly to the
StarRating component:
export default function StarRating({ totalStars = 5 }) {
const [selectedStars] = useState(3);
return (
<>
{createArray(totalStars).map((n, i) => (
<Star key={i} selected={selectedStars > i} />
))}
<p>
{selectedStars} of {totalStars} stars
</p>
</>
);
}
We just hooked this component up with state. The useState hook is a
function that we can invoke to return an array. The first value of that
array is the state variable we want to use. In this case, that variable is
selectedStars, or the number of stars the StarRating will color red.
useState returns an array. We can take advantage of array
destructuring, which allows us to name our state variable whatever we
like. The value we send to the useState function is the default value
for the state variable. In this case, selectedStars will initially be set
to 3, as shown in Figure 6-3.
Figure 6-3. Three of five stars are selected
In order to collect a different rating from the user, we’ll need to allow
them to click on any of our stars. This means we’ll need to make the
stars clickable by adding an onClick handler to the FaStar
component:
const Star = ({ selected = false, onSelect = f => f }) => (
<FaStar color={selected ? "red" : "grey"} onClick={onSelect} />
);
Here, we modified the star to contain an onSelect property. Check it
out: this property is a function. When a user clicks on the FaStar
component, we’ll invoke this function, which can notify its parent that
a star has been clicked. The default value for this function is f => f.
This is simply a fake function that does nothing; it just returns
whatever argument was sent to it. However, if we do not set a default
function and the onSelect property is not defined, an error will occur
when we click the FaStar component because the value for onSelect
must be a function. Even though f => f does nothing, it is a function,
which means it can be invoked without causing errors. If an onSelect
property is not defined, no problem. React will simply invoke the fake
function and nothing will happen.
Now that our Star component is clickable, we’ll use it to change the
state of the StarRating:
export default function StarRating({ totalStars = 5 }) {
const [selectedStars, setSelectedStars] = useState(0);
return (
<>
{createArray(totalStars).map((n, i) => (
<Star
key={i}
selected={selectedStars > i}
onSelect={() => setSelectedStars(i + 1)}
/>
))}
<p>
{selectedStars} of {totalStars} stars
</p>
</>
);
}
In order to change the state of the StarRating component, we’ll need
a function that can modify the value of selectedStars. The second
item in the array that’s returned by the useState hook is a function
that can be used to change the state value. Again, by destructuring this
array, we can name that function whatever we like. In this case, we’re
calling it setSelectedStars, because that’s what it does: it sets the
value of selectedStars.
The most important thing to remember about Hooks is that they can
cause the component they’re hooked into to rerender. Every time we
invoke the setSelectedStars function to change the value of
selectedStars, the StarRating function component will be
reinvoked by the hook, and it will render again, this time with a new
value for selectedStars. This is why Hooks are such a killer feature.
When data within the hook changes, they have the power to rerender
the component they’re hooked into with new data.
The StarRating component will be rerendered every time a user
clicks a Star. When the user clicks the Star, the onSelect property of
that star is invoked. When the onSelect property is invoked, we’ll
invoke the setSelectedStars function and send it the number of the
star that was just selected. We can use the i variable from the map
function to help us calculate that number. When the map function
renders the first Star, the value for i is 0. This means that we need to
add 1 to this value to get the correct number of stars. When
setSelectedStars is invoked, the StarRating component is invoked
with a the value for selectedStars, as shown in Figure 6-4.

Figure 6-4. Hooks in React developer tools
The React developer tools will show you which Hooks are
incorporated with specific components. When we render the
StarRating component in the browser, we can view debugging
information about that component by selecting it in the developer tools.
In the column on the right, we can see that the StarRating component
incorporates a state Hook that has a value of 2. As we interact with the
app, we can watch the state value change and the component tree
rerender with the corresponding number of stars selected.
REACT STATE THE “OLD WAY”
In previous versions of React, before v16.8.0, the only way to add state to a component was to use a
class component. This required not only a lot of syntax, but it also made it more difficult to reuse
functionality across components. Hooks were designed to solve problems presented with class
components by providing a solution to incorporate functionality into function components.
The following code is a class component. This was the original StarRating component that was
printed in the first edition of this book:
import React, { Component } from "react";
export default class StarRating extends Component {
constructor(props) {
super(props);
this.state = {
starsSelected: 0
};
this.change = this.change.bind(this);
}
change(starsSelected) {
this.setState({ starsSelected });
}
render() {
const { totalStars } = this.props;
const { starsSelected } = this.state;
return (
<div>
{[...Array(totalStars)].map((n, i) => (
<Star
key={i}
selected={i < starsSelected}
onClick={() => this.change(i + 1)}
/>
))}
<p>
{starsSelected} of {totalStars} stars
</p>
</div>
);
}
}
This class component does the same thing as our function component with noticeably more code.
Additionally, it introduces more confusion thorough the use of the this keyword and function binding.
As of today, this code still works. We’re no longer covering class components in this book because
they’re no longer needed. Function components and Hooks are the future of React, and we’re not
looking back. There could come a day where class components are officially deprecated, and this
code will no longer be supported.
Refactoring for Advanced Reusability
Right now, the Star component is ready for production. You can use it
across several applications when you need to obtain a rating from a
user. However, if we were to ship this component to npm so that
anyone in the world could use it to obtain ratings from users, we may
want to consider handling a couple more use cases.
First, let’s consider the style property. This property allows you to
add CSS styles to elements. It is highly possible that a future
developer, even yourself, could come across the need to modify the
style of your entire container. They may attempt to do something like
this:
export default function App() {
return <StarRating style={{ backgroundColor: "lightblue" }} />;
}
All React elements have style properties. A lot of components also
have style properties. So attempting to modify the style for the entire
component seems sensible.
All we need to do is collect those styles and pass them down to the
StarRating container. Currently, the StarRating does not have a
single container because we are using a React fragment. To make this
work, we’ll have to upgrade from a fragment to a div element and pass
the styles to that div:
export default function StarRating({ style = {}, totalStars = 5 }) {
const [selectedStars, setSelectedStars] = useState(0);
return (
<div style={{ padding: "5px", ...style }}>
{createArray(totalStars).map((n, i) => (
<Star
key={i}
selected={selectedStars > i}
onSelect={() => setSelectedStars(i + 1)}
/>
))}
<p>
{selectedStars} of {totalStars} stars
</p>
</div>
);
}
In the code above, we replaced the fragment with a div element and
then applied styles to that div element. By default we assign that div a
padding of 5px, and then we use the spread operator to apply the rest of
the properties from the style object to the div style.
Additionally, we may find developers who attempt to implement other
common properties properties to the entire star rating:
export default function App() {
return (
<StarRating
style={{ backgroundColor: "lightblue" }}
onDoubleClick={e => alert("double click")}
/>
);
}
In this sample, the user is trying to add a double-click method to the
entire StarRating component. If we feel it is necessary, we can also
pass this method along with any other properties down to our
containing div:
export default function StarRating({ style = {}, totalStars = 5, ...props
}) {
const [selectedStars, setSelectedStars] = useState(0);
return (
<div style={{ padding: 5, ...style }} {...props}>
...
</div>
);
}
The first step is to collect any and all properties that the user may be
attempting to add to the StarRating. We gather these properties using
the spread operator: ...props. Next, we’ll pass all of these remaining
properties down to the div element: {...props}.
By doing this, we make two assumptions. First, we are assuming that
users will add only those properties that are supported by the div
element. Second, we are assuming that our user can’t add malicious
properties to the component.
This is not a blanket rule to apply to all of your components. In fact,
it’s only a good idea to add this level of support in certain situations.
The real point is that it’s important to think about how the consumers
of your component may try to use it in the future.
State in Component Trees
It’s not a great idea to use state in every single component. Having
state data distributed throughout too many of your components will
make it harder to track down bugs and make changes within your
application. This occurs because it’s hard to keep track of where the
state values live within your component tree. It’s easier to understand
your application’s state, or state for a specific feature, if you manage it
from one location. There are several approaches to this methodology,
and the first one we’ll analyze is storing state at the root of the
component tree and passing it down to child components via props.
Let’s build a small application that can be used to save a list of colors.
We’ll call the app the “Color Organizer”, and it will allow users to
associate a list of colors with a custom title and rating. To get started, a
sample dataset may look like the following:
[
{
"id": "0175d1f0-a8c6-41bf-8d02-df5734d829a4",
"title": "ocean at dusk",
"color": "#00c4e2",
"rating": 5
},
{
"id": "83c7ba2f-7392-4d7d-9e23-35adbe186046",
"title": "lawn",
"color": "#26ac56",
"rating": 3
},
{
"id": "a11e3995-b0bd-4d58-8c48-5e49ae7f7f23",
"title": "bright red",
"color": "#ff0000",
"rating": 0
}
]
The color-data.json file contains an array of three colors. Each color
has an id, title, color, and rating. First, we’ll create a UI
consisting of React components that will be used to display this data in
a browser. Then we’ll allow the users to add new colors as well as rate
and remove colors from the list.
Sending State Down a Component Tree
In this iteration, we’ll store state in the root of the Color Organizer, the
App component, and pass the colors down to child components to
handle the rendering. The App component will be the only component
within our application that holds state. We’ll add the list of colors to
the App with the useState hook:
import React, { useState } from "react";
import colorData from "./color-data.json";
import ColorList from "./ColorList.js";
export default function App() {
const [colors] = useState(colorData);
return <ColorList colors={colors} />;
}
The App component sits at the root of our tree. Adding useState to
this component hooks it up with state management for colors. In this
example, the colorData is the array of sample colors from above. The
App component uses the colorData as the initial state for colors.
From there, the colors are passed down to a component called the
ColorList:
import React from "react";
import Color from "./Color";
export default function ColorList({ colors = [] }) {
if(!colors.length) return <div>No Colors Listed.</div>;
return (
<div>
{
colors.map(color => <Color key={color.id} {...color} />)
}
</div>
);
}
The ColorList receives the colors from the App component as props.
If the list is empty, this component will display a message to our users.
When we have a color array, we can map over it and pass the details
about each color farther down the tree to the Color component:
export default function Color({ title, color, rating }) {
return (
<section>
<h1>{title}</h1>
<div style={{ height: 50, backgroundColor: color }} />
<StarRating selectedStars={rating} />
</section>
);
}
The Color component expects three properties: title, color, and
rating. These values are found in each color object and were passed
to this component using the spread operator <Color {...color} />.
This takes each field from the color object and passes it to the Color
component as a property with the same name as the object key. The
Color component displays these values. The title is rendered inside
of an h1 element. The color value is displayed as the
backgroundColor for a div element. The rating is passed farther
down the tree to the StarRating component, which will display the
rating visually as selected stars:
export default function StarRating({ totalStars = 5, selectedStars = 0 })
{
return (
<>
{createArray(totalStars).map((n, i) => (
<Star
key={i}
selected={selectedStars > i}
/>
))}
<p>
{selectedStars} of {totalStars} stars
</p>
</>
);
}
This StarRating component has been modified. We’ve turned it into a
pure component. A pure component is a function component that does
not contain state and will render the same user interface given the same
props. We made this component a pure component because the state
for color ratings are stored in the colors array at the root of the
component tree. Remember that the goal of this iteration is to store
state in a single location and not have it distributed through many
different components within the tree.
NOTE
It is possible for the StarRating component to hold its own state and receive
state from a parent component via props. This is typically necessary when
distributing components for wider use by the community. We demonstrate this
technique in the next chapter when we cover the useEffect hook.
At this point, we’ve finished passing state down the component tree
from the App component all the way to each Star component that’s
filled red to visually represent the rating for each color. If we render
the app based on the color-data.json file that was listed previously, we
should see our colors in the browser, as shown in Figure 6-5.

Figure 6-5. Color Organizer rendered in the browser
Sending Interactions Back up a Component Tree
So far, we’ve rendered a representation of the colors array as UI by
composing React components and passing data down the tree from
parent component to child component via props. What happens if we
want to remove a color from the list or change the rating of a color in
our list? The colors are stored in state at the root of our tree. We’ll
need to collect interactions from child components and send them back
up the tree to the root component where we can change the state.
For instance, let’s say we wanted to add a Remove button next to each
color’s title that would allow users to remove colors from state. We
would add that button to the Color component:
import { FaTrash } from "react-icons/fa";
export default function Color({ id, title, color, rating, onRemove = f =>
f }) {
return (
<section>
<h1>{title}</h1>
<button onClick={() => onRemove(id)}>
<FaTrash />
</button>
<div style={{ height: 50, backgroundColor: color }} />
<StarRating selectedStars={rating} />
</section>
);
}
Here, we’ve modified the color by adding a button that will allow users
to remove colors. First, we imported a trash can icon from react-
icons. Next, we wrapped the FaTrash icon in a button. Adding an
onClick handler to this button allows us to invoke the onRemove
function property, which has been added to our list of properties along
with the id. When a user clicks the Remove button, we’ll invoke
removeColor and pass it the id of the color that we want to remove.
That is why the id value has also been gathered from the Color
component’s properties.
This solution is great because we keep the Color component pure. It
doesn’t have state and can easily be reused in a different part of the app
or another application altogether. The Color component is not
concerned with what happens when a user clicks the Remove button.
All it cares about is notifying the parent that this event has occurred
and passing the information about which color the user wishes to
remove. It’s now the parent’s responsibility to handle this event:
export default function ColorList({ colors = [], onRemoveColor = f => f
}) {
if (!colors.length) return <div>No Colors Listed. (Add a Color)</div>;
return (
colors.map(color => (
<Color key={color.id} {...color} onRemove={onRemoveColor} />
)
}
</div>
);
}
The Color component’s parent is the ColorList. This component also
doesn’t have access to state. Instead of removing the color, it simply
passes the event up to its parent. It accomplishes this by adding an
onRemoveColor function property. If a Color component invokes the
onRemove property, the ColorList will in turn invoke its
onRemoveColor property and send the responsibility for removing the
color up to its parent. The color’s id is still being passed to the
onRemoveColor function.
The parent of the ColorList is the App. This component is the
component that has been hooked up with state. This is where we can
capture the color id and remove the color in state:
export default function App() {
const [colors, setColors] = useState(colorData);
return (
<ColorList
colors={colors}
onRemoveColor={id => {
const newColors = colors.filter(color => color.id !== id);
setColors(newColors);
}}
/>
);
}
First, we add a variable for setColors. Remember that the second
argument in the array returned by useState is a function we can use to
modify the state. When the ColorList raises an onRemoveColor event,
we capture the id of the color to remove from the arguments and use it
to filter the list of colors to exclude the color the user wants to remove.
Next, we change the state. We use the setColors function to change
change the array of colors to the newly filtered array.
Changing the state of the colors array causes the App component to be
rerendered with the new list of colors. Those new colors are passed to
the ColorList component, which is also rerendered. It will render
Color components for the remaining colors and our UI will reflect the
changes we’ve made by rendering one less color.
If we want to rate the colors that are stored in the App components
state, we’ll have to repeat the process with an onRate event. First,
we’ll collect the new rating from the individual star that was clicked
and pass that value to the parent of the StarRating:
export default function StarRating({
totalStars = 5,
selectedStars = 0,
onRate = f => f
}) {
return (
<>
{createArray(totalStars).map((n, i) => (
<Star
key={i}
selected={selectedStars > i}
onSelect={() => onRate(i + 1)}
/>
))}
</>
);
}
Then, we’ll grab the rating from the onRate handler we added to the
StarRating component. We’ll then pass the new rating along with the
id of the color to be rated up to the Color component’s parent via
another onRate function property:
export default function Color({
id,
title,
color,
rating,
onRemove = f => f,
onRate = f => f
}) {
return (
<section>
<h1>{title}</h1>
<button onClick={() => onRemove(id)}>
<FaTrash />
</button>
<div style={{ height: 50, backgroundColor: color }} />
<StarRating
selectedStars={rating}
onRate={rating => onRate(id, rating)}
/>
</section>
);
}
In the ColorList component, we’ll have to capture the onRate event
from individual color components and pass them up to its parent via
the onRateColor function property:
export default function ColorList({
colors = [],
onRemoveColor = f => f,
onRateColor = f => f
}) {
if (!colors.length) return <div>No Colors Listed. (Add a Color)</div>;
return (
<div className="color-list">
{
colors.map(color => (
<Color
key={color.id}
{...color}
onRemove={onRemoveColor}
onRate={onRateColor}
/>
)
}
</div>
);
}
Finally, after passing the event up through all of these components,
we’ll arrive at the App, where state is stored and the new rating can be
saved:
export default function App() {
const [colors, setColors] = useState(colorData);
return (
<ColorList
colors={colors}
onRateColor={(id, rating) => {
const newColors = colors.map(color =>
color.id === id ? { ...color, rating } : color
);
setColors(newColors);
}}
onRemoveColor={id => {
const newColors = colors.filter(color => color.id !== id);
setColors(newColors);
}}
/>
);
}
The App component will change color ratings when the ColorList
invokes the onRateColor property with the id of the color to rate and
the new rating. We’ll use those values to construct an array of new
colors by mapping over the existing colors and changing the rating for
the color that matches the id property. Once we send the newColors to
the setColors function, the state value for colors will change and the
App component will be invoked with a new value for the colors array.
Once the state of our colors array changes, the UI tree is rendered
with the new data. The new rating is reflected back to the user via red
stars. Just as we passed data down a component tree via props,
interactions can be passed back up the tree along with data via function
properties.
Building Forms
For a lot of us, being a web developer means collecting large amounts
of information from users with forms. If this sounds like your job, then
you’ll be building a lot of form components with React. All of the
HTML form elements that are available to the DOM are also available
as React elements, which means that you may already know how to
render a form with JSX:
<form>
<input type="text" placeholder="color title..." required />
<input type="color" required />
<button>ADD</button>
</form>
This form element has three child elements: two input elements and a
button. The first input element is a text input that will be used to
collect the title value for new colors. The second input element is an
HTML color input that will allow users to pick a color from a color
wheel. We’ll be using basic HTML form validation, so we’ve marked
both inputs as required. The ADD button will be used to add a new
color.
Using Refs
When it’s time to build a form component in React, there are several
patterns available to you. One of these patterns involves accessing the
DOM node directly using a React feature called refs. In React, a ref is
an object that stores values for the lifetime of a component. There are
several use cases that involve using refs. In this section, we’ll look at
how we can access a DOM node directly with a ref.
React provides us with a useRef hook that we can use to create a ref.
We’ll use this hook when building the AddColorForm component:
import React, { useRef } from "react";
export default function AddColorForm({ onNewColor = f => f }) {
const txtTitle = useRef();
const hexColor = useRef();
const submit = e => { ... }
return (...)
}
First, when creating this component, we’ll also create two refs using
the useRef hook. The txtTitle ref will be used to reference the text
input we’ve added to the form to collect the color title. The hexColor
ref will be used to access hexadecimal color values from the HTML
color input. We can set the values for these refs directly in JSX using
the ref property:
return (
<form onSubmit={submit}>
<input ref={txtTitle} type="text" placeholder="color title..."
required />
<input ref={hexColor} type="color" required />
<button>ADD</button>
</form>
);
}
Here, we set the value for the txtTitle and hexColor refs by adding
the ref attribute to these input elements in JSX. This creates a current
field on our ref object that references the DOM element directly. This
provides us access to the DOM element, which means we can capture
its value. When the user submits this form by clicking the ADD button,
we’ll invoke the submit function:
const submit = e => {
e.preventDefault();
const title = txtTitle.current.value;
const color = hexColor.current.value;
onNewColor(title, color);
txtTitle.current.value = "";
hexColor.current.value = "";
};
When we submit HTML forms, by default, they send a POST request
to the current URL with the values of the form elements stored in the
body. We don’t want to do that. This is why the first line of code in the
submit function is e.preventDefault(), which prevents the browser
from trying to submit the form with a POST request.
Next, we capture the current values for each of our form elements
using their refs. These values are then passed up to this component’s
parent via the onNewColor function property. Both the title and the
hexadecimal value for the new color are passed as function arguments.
Finally, we reset the value attribute for both inputs to clear the data
and prepare the form to collect another color.
Did you notice the subtle paradigm shift that has occurred by using
refs? We’re mutating the value attribute of DOM nodes directly by
setting them equal to "" empty strings. This is imperative code. The
AddColorForm is now what we call an uncontrolled component
because it uses the DOM to save the form values. Sometimes using
uncontrolled component can get you out of problems. For instance, you
may want to share access to a form and its values with code outside of
React. However, a controlled component is a better approach.
Controlled Components
In a controlled component, the from values are managed by React and
not the DOM. They do not require us to use refs. They do not require
us to write imperative code. Adding features like robust form
validation is much easier when working with a controlled component.
Let’s modify the AddColorForm by giving it control over the form’s
state:
import React, { useState } from "react";
export default function AddColorForm({ onNewColor = f => f }) {
const [title, setTitle] = useState("");
const [color, setColor] = useState("#000000");
const submit = e => { ... };
return ( ... );
}
First, instead of using refs, we’re going to save the values for the title
and color using React state. We’ll create variables for title and
color. Additionally, we’ll define the functions that can be used to
change state: setTitle and setColor.
Now that the component controls the values for title and color, we
can display them inside of the form input elements by setting the value
attribute. Once we set the value attribute of an input element, we’ll no
longer be able to change with the form. The only way to change the
value at this point would be to change the state variable every time the
user types a new character in the input element. That’s exactly what
we’ll do:
<form onSubmit={submit}>
<input
value={title}
onChange={event => setTitle(event.target.value)}
type="text"
placeholder="color title..."
required
/>
<input
value={color}
onChange={event => setColor(event.target.value)}
type="color"
required
/>
<button>ADD</button>
</form>
}
This controlled component now sets the value of both input elements
using the title and color from state. Whenever these elements raise
an onChange event, we can access the new value using the event
argument. The event.target is a reference to the DOM element, so
we can obtain the current value of that element with
event.target.value. When the title changes, we’ll invoke
setTitle to change the title value in state. Changing that value will
cause this component to rerender, and we can now display the new
value for title inside the input element. Changing the color works
exactly the same way.
When it’s time to submit the form, we can simply pass the state values
for title and color to the onNewColor function property as
arguments when we invoke it. The setTitle and setColor functions
can be used to reset the values after the new color has been passed to
the parent component:
const submit = e => {
e.preventDefault();
onNewColor(title, color);
setTitle("");
setColor("");
};
It’s called a controlled component because React controls the state of
the form. It’s worth pointing out that controlled form components are
rerendered, a lot. Think about it: every new character typed in the
title field causes the AddColorForm to rerender. Using the color
wheel in the color picker causes this component to rerender way more
than the title field because the color value repeatedly changes as the
user drags the mouse around the color wheel. This is OK—React is
designed to handle this type of workload. Hopefully, knowing that
controlled components are rerendered frequently will prevent you from
adding some long and expensive process to this component. At the
very least, this knowledge will come in handy when you’re trying to
optimize your React components.
Creating Custom Hooks
When you have a large form with a lot of input elements, you may be
tempted to copy and paste these two lines of code:
value={title}
onChange={event => setTitle(event.target.value)}
It might seem like you’re working faster by simply copying and pasting
these properties into every form element while tweaking the variable
names along the way. However, whenever you copy and paste code,
you should hear a tiny little alarm sound in your head. Copying and
pasting code suggests that there’s something redundant enough to
abstract away in a function.
We can package the details necessary to create controlled form
components into a custom hook. We could create our own useInput
hook where we can abstract away the redundancy involved with
creating controlled form inputs:
import { useState } from "react";
export const useInput = initialValue => {
const [value, setValue] = useState(initialValue);
return [
{ value, onChange: e => setValue(e.target.value) },
() => setValue(initialValue)
];
};
This is a custom hook. It doesn’t take a lot of code. Inside of this hook,
we’re still using the useState hook to create a state value. Next, we
return an array. The first value of the array is the object that contains
the same properties we were tempted to copy and paste: the value
from state along with an onChange function property that changes that
value in state. The second value in the array is a function that can be
reused to reset the value back to its initial value. We can use our hook
inside of the AddColorForm:
import React from "react";
import { useInput } from "./hooks";
export default function AddColorForm({ onNewColor = f => f }) {
const [titleProps, resetTitle] = useInput("");
const [colorProps, resetColor] = useInput("#000000");
const submit = event => { ... }
return ( ... )
}
The useState hook is encapsulated within our useInput hook. We
can obtain the properties for both the title and the color by
destructuring them from the first value of the returned array. The
second value of this array contains a function we can use to reset the
value property back to its initial value, an empty string. The
titleProps and colorProps are ready to be spread into their
corresponding input elements:
return (
<form onSubmit={submit}>
<input
{...titleProps}
type="text"
placeholder="color title..."
required
/>
<input {...colorProps} type="color" required />
<button>ADD</button>
</form>
);
}
Spreading these properties from our custom hook is much more fun
than pasting them. Now both the title and the color inputs are receiving
properties for their value and onChange events. We’ve used our hook
to create controlled form inputs without worrying about the underlying
implementation details. The only other change we need to make is
when this form is submitted:
const submit = event => {
event.preventDefault();
onNewColor(titleProps.value, colorProps.value);
resetTitle();
resetColor();
};
Within the submit function, we need to be sure to grab the value for
both the title and the color from their properties. Finally, we can use
the custom reset functions that were returned from the useInput hook.
Hooks are designed to be used inside of React components. We can
compose hooks within other hooks because eventually the customized
hook will be used inside of a component. Changing the state within this
hook still causes the AddColorForm to rerender with new values for
titleProps or colorProps.
Adding Colors to State
Both the controlled form component and the uncontrolled from
component pass the values for title and color to the parent
component via the onNewColor function. The parent doesn’t care
whether we used a controlled component or an uncontrolled
component; it only wants the values for the new color.
Let’s add the AddColorForm, whichever one you choose, to the the App
component. When the onNewColor property is invoked, we’ll save the
new color in state:
import React, { useState } from "react";
import colorData from "./color-data.json";
import ColorList from "./ColorList.js";
import AddColorForm from "./AddColorForm";
import { v4 } from "uuid";
export default function App() {
const [colors, setColors] = useState(colorData);
return (
<>
<AddColorForm
onNewColor={(title, color) => {
const newColors = [
...colors,
{
id: v4(),
rating: 0,
title,
color
}
];
setColors(newColors);
}}
/>
<ColorList .../>
</>
);
}
When a new color is added, the onNewColor property is invoked. The
title and hexadecimal value for the new color are passed to this
function as arguments. We use these arguments to create a new array of
colors. First, we spread the current colors from state into the new
array. Then we add an entirely new color object using the title and
color values. Additionally, we set the rating of the new color to 0
because it has not yet been rated. We also use the v4 function found in
the uuid package to generate a new unique id for the color. Once we
have an array of colors that contains our new color, we save it to state
by invoking setColors. This causes the App component to rerender
with a new array of colors. That new array will be used to update the
UI. We’ll see the new color at bottom of the list.
With this change, we’ve completed the first iteration of the Color
Organizer. Users can now add new colors to the list, remove colors
from the list, and rate any existing color on that list.
React Context
Storing state in one location at the root of our tree was an important
pattern that helped us all be more successful with early versions of
React. Learning to pass state both down and up a component tree via
properties is a necessary right of passage for any React developer—it’s
something we should all know how to do. However, as React evolved
and our component trees got larger, following this principle slowly
became more unrealistic. It’s hard for many developers to maintain
state in a single location at the root of a component tree for a complex
application. Passing state down and up the tree through dozens of
components is tedious and bug ridden.
The UI elements that most of us work on are complex. The root of the
tree is often very far from the leaves. This puts data the application
depends on many layers away from the components that use the data.
Every component must receive props that they only pass to their
children. This will bloat our code and make our UI harder to scale.
Passing state data through every component as props until it reaches
the component that needs to use it is like taking the train from San
Francisco to DC. On the train, you’ll pass through every state, but you
won’t get off until you reach your destination (see Figure 6-6).
Figure 6-6. Train from San Francisco to DC
It’s obviously more efficient to fly from San Francisco to DC. This
way, you don’t have to pass through every state—you simply fly over
them (Figure 6-7).
Figure 6-7. Flight from San Francisco to DC
In React, context is like jet-setting for your data. You can place data in
React context by creating a context provider. A context provider is a
React component you can wrap around your entire component tree or
specific sections of your component tree. The context provider is the
departing airport where your data boards the plane. It’s also the airline
hub. All flights depart from that airport to different destinations. Each
destination is a context consumer. The context consumer is the React
component that retrieves the data from context. This is the destination
airport where your data lands, deplanes, and goes to work.
Using context still allows to us store state data in a single location, but
it doesn’t require us to pass that data through a bunch of components
that don’t need it.
Placing Colors in Context
In order to use context in React, we must first place some data in a
context provider and add that provider to our component tree. React
comes with a function called createContext that we can use to create
a new context object. This object contains two components: a context
Provider and a Consumer.
Let’s place the default colors found in the color-data.json file into
context. We’ll add context to the index.js file, the entry point of our
application:
import React, { createContext } from "react";
import colors from "./color-data";
import { render } from "react-dom";
import App from "./App";
export const ColorContext = createContext();
render(
<ColorContext.Provider value={{ colors }}>
<App />
</ColorContext.Provider>,
document.getElementById("root")
);
Using createContext, we created a new instance of React context that
we named ColorContext. The color context contains two components:
ColorContext.Provider and ColorContext.Consumer. We need to
use the provider to place the colors in state. We add data to context by
setting the value property of the Provider. In this scenario, we added
an object containing the colors to context. Since we wrapped the
entire App component with the provider, the array of colors will made
available to any context consumers found in our entire component tree.
It’s important to notice that we’ve also exported the ColorContext
from this location. This is necessary because we will need to access the
ColorContext.Consumer when we want to obtain the colors from
context.
NOTE
A context Provider doesn’t always have to wrap an entire application. It’s not
only OK to wrap specific sections components with a context Provider, it can
make your application more efficient. The Provider will only provide context
values to its children.
It’s OK to use multiple context providers. In fact, you may be using context
providers in your React app already without even knowing it. Many npm packages
designed to work with React use context behind the scenes.
Now that we’re providing the colors value in context, the App
component no longer needs to hold state and pass it down to its
children as props. We’ve made the App component a “flyover”
component. The Provider is the App component’s parent, and it’s
providing the colors in context. The ColorList is the App
component’s child, and it can obtain the colors directly on its own. So
the app doesn’t need to touch the colors at all, which is great because
the App component itself has nothing to do with colors. That
responsibility has been delegated farther down the tree.
We can remove a lot of lines of code from the App component. It only
needs to render the AddColorForm and the ColorList. It no longer has
to worry about the data:
import React from "react";
import ColorList from "./ColorList.js";
import AddColorForm from "./AddColorForm";
export default function App() {
return (
<>
<AddColorForm />
<ColorList />
</>
);
}
Retrieving Colors with useContext
The addition of Hooks makes working with context a joy. The
useContext hook is used to obtain values from context, and it obtains
those values we need from the context Consumer. The ColorList
component no longer needs to obtain the array of colors from its
properties. It can access them directly via the useContext hook:
import React, { useContext } from "react";
import { ColorContext } from "./";
import Color from "./Color";
export default function ColorList() {
const { colors } = useContext(ColorContext);
if (!colors.length) return <div>No Colors Listed. (Add a Color)</div>;
return (
<div className="color-list">
{
colors.map(color => <Color key={color.id} {...color} />)
}
</div>
);
}
Here, we’ve modified the ColorList component and removed the
colors=[] property because the colors are being retrieved from
context. The useContext hook requires the context instance to obtain
values from it. The ColorContext instance is being imported from the
index.js file where we create the context and add the provider to our
component tree. The ColorList can now construct a user interface
based on the data that has been provided in context.
USING CONTEXT CONSUMER
The Consumer is accessed within the useContext hook, which means that we no
longer have to work directly with the consumer component. Before Hooks, we
would have to obtain the colors from context using a pattern called render props
within the context consumer. Render props are passed as arguments to a child
function. The following example is how you would use the consumer to obtain the
colors from context:
export default function ColorList() {
return (
<ColorContext.Consumer>
{context => {
if (!context.colors.length)
return <div>No Colors Listed. (Add a Color)</div>;
return (
<div className="color-list">
{
context.colors.map(color =>
<Color key={color.id} {...color} />)
}
</div>
)
}}
</ColorContext.Consumer>
)
}
Stateful Context Providers
The context provider can place an object into context, but it can’t
mutate the values in context on its own. It needs some help from a
parent component. The trick is to create a stateful component that
renders a context provider. When the state of the stateful component
changes, it will rerender the context provider with new context data.
Any of the context providers’ children will also be rerendered with the
new context data.
The stateful component that renders the context provider is our custom
provider. That is: that’s the component that will be used when it’s time
to wrap our App with the provider. In a brand-new file, let’s create a
ColorProvider:
import React, { createContext, useState } from "react";
import colorData from "./color-data.json";
const ColorContext = createContext();
export default function ColorProvider ({ children }) {
const [colors, setColors] = useState(colorData);
return (
<ColorContext.Provider value={{ colors, setColors }}>
{children}
</ColorContext.Provider>
);
};
The ColorProvider is a component that renders the
ColorContext.Provider. Within this component, we’ve created a
state variable for colors using the useState hook. The initial data for
colors is still being populated from color-data.json. Next, the
ColorProvider adds the colors from state to context using the value
property of the ColorContext.Provider. Any children rendered
within the ColorProvider will be wrapped by the
ColorContext.Provider and will have access to the colors array
from context.
You may have noticed that the setColors function is also being added
to context. This gives context consumers the ability to change the value
for colors. Whenever setColors is invoked, the colors array will
change. This will cause the ColorProvider to rerender, and our UI
will update itself to display the new colors array.
Adding setColors to context may not be the best idea. It invites other
developers and you to make mistakes later on down the road when
using it. There are only three options when it comes to changing the
value of the colors array: users can add colors, remove colors, or rate
colors. It’s a better idea to add functions for each of these operations to
context. This way, you don’t expose the setColors function to
consumers; you only expose functions for the changes they’re allowed
to make:
export default function ColorProvider ({ children }) {
const [colors, setColors] = useState(colorData);
const addColor = (title, color) =>
setColors([
...colors,
{
id: v4(),
rating: 0,
title,
color
}
]);
const rateColor = (id, rating) =>
setColors(
colors.map(color => (color.id === id ? { ...color, rating } :
color))
);
const removeColor = id => setColors(colors.filter(color => color.id !==
id));
return (
<ColorContext.Provider value={{ colors, addColor, removeColor,
rateColor }}>
{children}
</ColorContext.Provider>
);
};
That looks better. We added functions to context for all of the
operations that can be made on the colors array. Now, any component
within our tree can consume these operations and make changes to
colors using simple functions that we can document.
Custom Hooks with Context
There’s one more killer change we can make. The introduction of
Hooks has made it so that we don’t have to expose context to consumer
components at all. Let’s face it: context can be confusing for team
members who aren’t reading this book. We can make everything much
easier for them by wrapping context in a custom hook. Instead of
exposing the ColorContext instance, we can create a hook called
useColors that returns the colors from context:
import React, { createContext, useState, useContext } from "react";
import colorData from "./color-data.json";
import { v4 } from "uuid";
const ColorContext = createContext();
export const useColors = () => useContext(ColorContext);
This one simple change has a huge impact on architecture. We’ve
wrapped all of the functionality necessary to render and work with
stateful colors in a single JavaScript module. Context is contained to
this module yet exposed through a hook. This works because we return
context using the useContext hook, which has access to the
ColorContext locally in this file. It’s now appropriate to rename this
module color-hooks.js and distribute this functionality for wider use
by the community.
Consuming colors using the ColorProvider and the useColors hook
is a joyous event. This is why we program. Let’s take this hook out for
a spin in the current Color Organizer app. First, we need to wrap our
App component with the custom ColorProvider. We can do this in the
index.js file:
import React from "react";
import { ColorProvider } from "./color-hooks.js";
import { render } from "react-dom";
import App from "./App";
render(
<ColorProvider>
<App />
</ColorProvider>,
document.getElementById("root")
);
Now, any component that’s a child of the App can obtain the colors
from the useColors hook. The ColorList component needs to access
the colors array to render the colors on the screen:
import React from "react";
import Color from "./Color";
import { useColors } from "./color-hooks";
export default function ColorList() {
const { colors } = useColors();
return ( ... );
}
We’ve removed any references to context from this component.
Everything it needs is now being provided from our hook. The Color
component could use our hook to obtain the functions for rating and
removing colors directly:
import React from "react";
import StarRating from "./StarRating";
import { useColors } from "./color-hooks";
export default function Color({ id, title, color, rating }) {
const { rateColor, removeColor } = useColors();
return (
<section>
<h1>{title}</h1>
<button onClick={() => removeColor(id)}>X</button>
<div style={{ height: 50, backgroundColor: color }} />
<StarRating
selectedStars={rating}
onRate={rating => rateColor(id, rating)}
/>
</section>
);
}
Now, the Color component no longer needs to pass events to the
parent via function props. It has access to the rateColor and
removeColor functions in context. They’re easily obtained through the
useColors hook. This is a lot of fun, but we’re not finished yet. The
AddColorForm can also benefit from the useColors hook:
import React from "react";
import { useInput } from "./hooks";
import { useColors } from "./color-hooks";
export default function AddColorForm() {
const [titleProps, resetTitle] = useInput("");
const [colorProps, resetColor] = useInput("#000000");
const { addColor } = useColors();
const submit = e => {
e.preventDefault();
addColor(titleProps.value, colorProps.value);
resetTitle();
resetColor();
};
return ( ... );
}
The AddColorForm component can add colors directly with the
addColor function. When colors are added, rated, or removed, the state
of the colors value in context will change. When this change happens,
the children of the ColorProvider are rerendered with new context
data. All of this is happening through a simple hook.
Hooks provide software developers with the stimulation they need to
stay motivated and enjoy frontend programming. This is primarily
because they’re an awesome tool for separating concerns. Now, React
components only need to concern themselves with rendering other
React components and keeping the user interface up to date. React
Hooks can concern themselves with the logic required to make the app
work. Both the UI and Hooks can be developed separately, tested
separately, and even deployed separately. This is all very good news
for React.
We’ve only scratched the surface of what can be accomplished with
Hooks. In the next chapter, we’ll dive a little deeper.
Chapter 7. Enhancing
Components with Hooks
Rendering is the heartbeat of a React application. When something
changes (props, state), the component tree rerenders, reflecting the
latest data as a user interface. So far, useState has been our workhorse
for describing how our components should be rendering. But we can do
more. There are more Hooks that define rules about why and when
rendering should happen. There are more Hooks that enhance
rendering performance. There are always more Hooks to help us out.
In the last chapter, we introduced useState, useRef, and useContext,
and we saw that we could compose these Hooks into our own custom
Hooks: useInput and useColors. There’s more where that came from,
though. React comes with more Hooks out of the box. In this chapter,
we’re going to take a closer look at useEffect, useLayoutEffect,
and useReducer. All of these are vital when building applications.
We’ll also look at useCallback and useMemo, which can help optimize
our components for performance.
Introducing useEffect
We now have a good sense of what happens when we render a
component. A component is simply a function that renders a user
interface. Renders occur when the app first loads and when props and
state values change. But what happens when we need to do something
after a render? Let’s take a closer look.
Consider a simple component, the Checkbox. We’re using useState to
set a checked value and a function to change the value of checked:
setChecked. A user can check and uncheck the box, but how might we
alert the user that the box has been checked? Let’s try this with an
alert, as it’s a great way to block the thread:
import React, { useState } from "react";
function Checkbox() {
const [checked, setChecked] = useState(false);
alert(`checked: ${checked.toString()}`);
return (
<>
<input
type="checkbox"
value={checked}
onChange={() => setChecked(checked => !checked)}
/>
{checked ? "checked" : "not checked"}
</>
);
};
We’ve added the alert before the render to block the render. The
component will not render until the user clicks the OK button on the
alert box. Because the alert is blocking, we don’t see the next state of
the checkbox rendered until clicking OK.
That isn’t the goal, so maybe we should place the alert after the return?
function Checkbox {
const [checked, setChecked] = useState(false);
return (
<>
<input
type="checkbox"
value={checked}
onChange={() => setChecked(checked => !checked)}
/>
{checked ? "checked" : "not checked"}
</>
);
alert(`checked: ${checked.toString()}`);
};
Scratch that. We can’t call alert after the render because the code will
never be reached. To ensure that we see the alert as expected, we can
use useEffect. Placing the alert inside of the useEffect function
means that the function will be called after the render, as a side effect:
function Checkbox {
const [checked, setChecked] = useState(false);
useEffect(() => {
alert(`checked: ${checked.toString()}`);
});
return (
<>
<input
type="checkbox"
value={checked}
onChange={() => setChecked(checked => !checked)}
/>
{checked ? "checked" : "not checked"}
</>
);
};
We use useEffect when a render needs to cause side effects. Think of
a side effect as something that a function does that isn’t part of the
return. The function is the Checkbox. The Checkbox function renders
UI. But we might want the component to do more than that. Those
things we want the component to do other than return UI are called
effects.
An alert, a console.log, or an interaction with a browser or native
API is not part of the render. It’s not part of the return. In a React app,
though, the render affects the results of one of these events. We can use
useEffect to wait for the render, then provide the values to an alert
or a console.log:
useEffect(() => {
console.log(checked ? "Yes, checked" : "No, not checked");
});
Similarly, we could check in with the value of checked on render and
then set that to a value in localStorage:
useEffect(() => {
localStorage.setItem("checkbox-value", checked);
});
We might also use useEffect to focus on a specific text input that has
been added to the DOM. React will render the output, then call
useEffect to focus the element:
useEffect(() => {
txtInputRef.current.focus();
});
On render, the txtInputRef will have a value. We can access that
value in the effect to apply the focus. Every time we render,
useEffect has access to the latest values from that render: props, state,
refs, etc.
Think of useEffect as being a function that happens after a render.
When a render fires, we can access the current state values within our
component and use them to do something else. Then, once we render
again, the whole thing starts over. New values, new renders, new
effects.
The Dependency Array
useEffect is designed to work in conjunction with other stateful
Hooks like useState and the heretofore unmentioned useReducer,
which we promise to discuss later in the chapter. React will rerender
the component tree when the state changes. As we’ve learned,
useEffect will be called after these renders.
Consider the following, where the App component has two separate
state values:
import React, { useState, useEffect } from "react";
import "./App.css";
function App() {
const [val, set] = useState("");
const [phrase, setPhrase] = useState("example phrase");
const createPhrase = () => {
setPhrase(val);
set("");
};
useEffect(() => {
console.log(`typing "${val}"`);
});
useEffect(() => {
console.log(`saved phrase: "${phrase}"`);
});
return (
<>
<label>Favorite phrase:</label>
<input
value={val}
placeholder={phrase}
onChange={e => set(e.target.value)}
/>
<button onClick={createPhrase}>send</button>
</>
);
}
val is a state variable that represents the value of the input field. The
val changes every time the value of the input field changes. It causes
the component to render every time the user types a new character.
When the user clicks the Send button, the val of the text area is saved
as the phrase, and the val is reset to "", which empties the text field.
This works as expected, but the useEffect hook is invoked more
times than it should be. After every render, both useEffect Hooks are
called:
typing "" // First Render
saved phrase: "example phrase" // First Render
typing "S" // Second Render
saved phrase: "example phrase" // Second Render
typing "Sh" // Third Render
saved phrase: "example phrase" // Third Render
typing "Shr" // Fourth Render
saved phrase: "example phrase" // Fourth Render
typing "Shre" // Fifth Render
saved phrase: "example phrase" // Fifth Render
typing "Shred" // Sixth Render
saved phrase: "example phrase" // Sixth Render
We don’t want every effect to be invoked on every render. We need to
associate useEffect hooks with specific data changes. To solve this
problem, we can incorporate the dependency array. The dependency
array can be used to control when an effect is invoked:
useEffect(() => {
console.log(`typing "${val}"`);
}, [val]);
useEffect(() => {
console.log(`saved phrase: "${phrase}"`);
}, [phrase]);
We’ve added the dependency array to both effects to control when
they’re invoked. The first effect is only invoked when the val value
has changed. The second effect is only invoked when the phrase value
has changed. Now, when we run the app and take a look at the console,
we’ll see more efficient updates occurring:
typing "" // First Render
saved phrase: "example phrase" // First Render
typing "S" // Second Render
typing "Sh" // Third Render
typing "Shr" // Fourth Render
typing "Shre" // Fifth Render
typing "Shred" // Sixth Render
typing "" // Seventh Render
saved phrase: "Shred" // Seventh Render
Changing the val value by typing into the input only causes the first
effect to fire. When we click the button, the phrase is saved and the
val is reset to "".
It’s an array after all, so it’s possible to check multiple values in the
dependency array. Let’s say we wanted to run a specific effect any time
either the val or phrase has changed:
useEffect(() => {
console.log("either val or phrase has changed");
}, [val, phrase]);
If either of those values changes, the effect will be called again. It’s
also possible to supply an empty array as the second argument to a
useEffect function. An empty dependency array causes the effect to
be invoked only once after the initial render:
useEffect(() => {
console.log("only once after initial render");
}, []);
Since there are no dependencies in the array, the effect is invoked for
the initial render. No dependencies means no changes, so the effect will
never be invoked again. Effects that are only invoked on the first
render are extremely useful for initialization:
useEffect(() => {
welcomeChime.play();
}, []);
If you return a function from the effect, the function will be invoked
when the component is removed from the tree:
useEffect(() => {
welcomeChime.play();
return () => goodbyeChime.play();
}, []);
This means that you can use useEffect for setup and teardown. The
empty array means that the welcome chime will play once on first
render. Then, we’ll return a function as a cleanup function to play a
goodbye chime when the component is removed from the tree.
This pattern is useful in many situations. Perhaps we’ll subscribe to a
news feed on first render. Then we’ll unsubscribe from the news feed
with the cleanup function. More specifically, we’ll start by creating a
state value for posts and a function to change that value, called
setPosts. Then we’ll create a function, addPosts, that will take in the
newest post and add it to the array. Then we can use useEffect to
subscribe to the news feed and play the chime. Plus, we can return the
cleanup functions, unsubscribing and playing the goodbye chime:
const [posts, setPosts] = useState([]);
const addPost = post => setPosts(allPosts => [post, ...allPosts]);
useEffect(() => {
newsFeed.subscribe(addPost);
welcomeChime.play();
return () => {
newsFeed.unsubscribe(addPost);
goodbyeChime.play();
};
}, []);
This is a lot going on in useEffect, though. We might want to use a
separate useEffect for the news feed events and another useEffect
for the chime events:
useEffect(() => {
newsFeed.subscribe(addPost);
return () => newsFeed.unsubscribe(addPost);
}, []);
useEffect(() => {
welcomeChime.play();
return () => goodbyeChime.play();
}, []);
Splitting functionality into multiple useEffect calls is typically a good
idea. But let’s enhance this even further. What we’re trying to create
here is functionality for subscribing to a news feed that plays different
jazzy sounds for subscribing, unsubscribing, and whenever there’s a
new post. Everyone loves lots of loud sounds right? This is a case for a
custom hook. Maybe we should call it useJazzyNews:
const useJazzyNews = () => {
const [posts, setPosts] = useState([]);
const addPost = post => setPosts(allPosts => [post, ...allPosts]);
useEffect(() => {
newsFeed.subscribe(addPost);
return () => newsFeed.unsubscribe(addPost);
}, []);
useEffect(() => {
welcomeChime.play();
return () => goodbyeChime.play();
}, []);
return posts;
};
Our custom hook contains all of the functionality to handle a jazzy
news feed, which means that we can easily share this functionality with
our components. In a new component called NewsFeed, we’ll use the
custom hook:
function NewsFeed({ url }) {
const posts = useJazzyNews();
return (
<>
<h1>{posts.length} articles</h1>
{posts.map(post => (
<Post key={post.id} {...post} />
))}
</>
);
}
Deep Checking Dependencies
So far, the dependencies we’ve added to the array have been strings.
JavaScript primitives like strings, booleans, numbers, etc., are
comparable. A string would equal a string as expected:
if ("gnar" === "gnar") {
console.log("gnarly!!");
}
However, when we start to compare objects, arrays, and functions, the
comparison is different. For example, if we compared two arrays:
if ([1, 2, 3] !== [1, 2, 3]) {
console.log("but they are the same");
}
These arrays [1,2,3] and [1,2,3] are not equal, even though they
look identical in length and in entries. This is because they are two
different instances of a similar-looking array. If we create a variable to
hold this array value and then compare, we’ll see the expected output:
const array = [1, 2, 3];
if (array === array) {
console.log("because it's the exact same instance");
}
In JavaScript, arrays, objects, and functions are the same only when
they’re the exact same instance. So how does this relate to the
useEffect dependency array? To demonstrate this, we’re going to
need a component we can force to render as much as we want. Let’s
build a hook that causes a component to render whenever a key is
pressed:
const useAnyKeyToRender = () => {
const [, forceRender] = useState();
useEffect(() => {
window.addEventListener("keydown", forceRender);
return () => window.removeEventListener("keydown", forceRender);
}, []);
};
At minimum, all we need to do to force a render is invoke a state
change function. We don’t care about the state value. We only want the
state function: forceRender. (That’s why we added the comma using
array destructuring. Remember, from Chapter 2?) When the component
first renders, we’ll listen for keydown events. When a key is pressed,
we’ll force the component to render by invoking forceRender. As
we’ve done before, we’ll return a cleanup function where we stop
listening to keydown events. By adding this hook to a component, we
can force it to rerender simply by pressing a key.
With the custom hook built, we can use it in the App component (and
any other component for that matter! Hooks are cool.):
function App() {
useAnyKeyToRender();
useEffect(() => {
console.log("fresh render");
});
return <h1>Open the console</h1>;
}
Every time we press a key, the App component is rendered. useEffect
demonstrates this by logging “fresh render” to the console every time
the App is rendered. Let’s adjust useEffect in the App component to
reference the word value. If word changes, we’ll rerender:
const word = "gnar";
useEffect(() => {
console.log("fresh render");
}, [word]);
Instead of calling useEffect on every keydown event, we would only
call this after first render and any time the word value changes. It
doesn’t change, so subsequent rerenders don’t occur. Adding a
primitive or a number to the dependency array works as expected. The
effect is invoked once.
What happens if instead of a single word, we use an array of words?
const words = ["sick", "powder", "day"];
useEffect(() => {
console.log("fresh render");
}, [words]);
The variable words is an array. Because a new array is declared with
each render, JavaScript assumes that words has changed, thus invoking
the “fresh render” effect every time. The array is a new instance each
time, and this registers as an update that should trigger a rerender.
Declaring words outside of the scope of the App would solve the
problem:
const words = ["sick", "powder", "day"];
function App() {
useAnyKeyToRender();
useEffect(() => {
console.log("fresh render");
}, [words]);
return <h1>component</h1>;
}
The dependency array in this case refers to one instance of words that’s
declared outside of the function. The “fresh render” effect does not get
called again after the first render because words is the same instance as
the last render. This is a good solution for this example, but it’s not
always possible (or advisable) to have a variable defined outside of the
scope of the function. Sometimes the value passed to the dependency
array requires variables in scope. For example, we might need to create
the words array from a React property like children:
function WordCount({ children = "" }) {
useAnyKeyToRender();
const words = children.split(" ");
useEffect(() => {
console.log("fresh render");
}, [words]);
return (
<>
<p>{children}</p>
<p>
<strong>{words.length} - words</strong>
</p>
</>
);
}
function App() {
return <WordCount>You are not going to believe this but...</WordCount>;
}
The App component contains some words that are children of the
WordCount component. The WordCount component takes in children
as a property. Then we set words in the component equal to an array of
those words that we’ve called .split on. We would hope that the
component will rerender only if words changes, but as soon as we
press a key, we see the dreaded “fresh render” words appearing in the
console.
Let’s replace that feeling of dread with one of calm, because the React
team has provided us a way to avoid these extra renders. They
wouldn’t hang us out to dry like that. The solution to this problem is, as
you might expect, another hook: useMemo.
useMemo invokes a function to calculate a memoized value. In
computer science in general, memoization is a technique that’s used to
improve performance. In a memoized function, the result of a function
call is saved and cached. Then, when the function is called again with
the same inputs, the cached value is returned. In React, useMemo allows
us to compare the cached value against itself to see if it has actually
changed.
The way useMemo works is that we pass it a function that’s used to
calculate and create a memoized value. useMemo will only recalculate
that value when one of the dependencies has changed. First, let’s
import the useMemo hook:
import React, { useEffect, useMemo } from "react";
Then we’ll use the function to set words:
const words = useMemo(() => {
const words = children.split(" ");
return words;
}, []);
useEffect(() => {
console.log("fresh render");
}, [words]);
useMemo invokes the function sent to it and sets words to the return
value of that function. Like useEffect, useMemo relies on a
dependency array:
const words = useMemo(() => children.split(" "));
When we don’t include the dependency array with useMemo, the words
are calculated with every render. The dependency array controls when
the callback function should be invoked. The second argument sent to
the useMemo function is the dependency array and should contain the
children value:
function WordCount({ children = "" }) {
useAnyKeyToRender();
const words = useMemo(() => children.split(" "), [children]);
useEffect(() => {
console.log("fresh render");
}, [words]);
return (...);
}
The words array depends on the children property. If children
changes, we should calculate a new value for words that reflects that
change. At that point, useMemo will calculate a new value for words
when the component initially renders and if the children property
changes.
The useMemo hook is a great function to understand when you’re
creating React applications.
useCallback can be used like useMemo, but it memoizes functions
instead of values. For example:
const fn = () => {
console.log("hello");
console.log("world");
};
useEffect(() => {
console.log("fresh render");
fn();
}, [fn]);
fn is a function that logs “Hello” then “World.” It is a dependency of
useEffect, but just like words, JavaScript assumes fn is different
every render. Therefore, it triggers the effect every render. This yields a
“fresh render” for every key press. It’s not ideal.
Start by wrapping the function with useCallback:
const fn = useCallback(() => {
console.log("hello");
console.log("world");
}, []);
useEffect(() => {
console.log("fresh render");
fn();
}, [fn]);
useCallback memoizes the function value for fn. Just like useMemo
and useEffect, it also expects a dependency array as the second
argument. In this case, we create the memoized callback once because
the dependency array is empty.
Now that we have an understanding of the uses and differences
between useMemo and useCallback, let’s improve our useJazzyNews
hook. Every time there’s a new post, we’ll call newPostChime.play().
In this hook, posts are an array, so we’ll need to use useMemo to
memoize the value:
const useJazzyNews = () => {
const [_posts, setPosts] = useState([]);
const addPost = post => setPosts(allPosts => [post, ...allPosts]);
const posts = useMemo(() => _posts, [_posts]);
useEffect(() => {
newPostChime.play();
}, [posts]);
useEffect(() => {
newsFeed.subscribe(addPost);
return () => newsFeed.unsubscribe(addPost);
}, []);
useEffect(() => {
welcomeChime.play();
return () => goodbyeChime.play();
}, []);
return posts;
};
Now, the useJazzyNews hook plays a chime every time there’s a new
post. We made this happen with a few changes to the hook. First,
const [posts, setPosts] was renamed to const [_posts,
setPosts]. We’ll calculate a new value for posts every time _posts
change.
Next, we added the effect that plays the chime every time the post
array changes. We’re listening to the news feed for new posts. When a
new post is added, this hook is reinvoked with _posts reflecting that
new post. Then, a new value for post is memoized because _posts
have changed. Then the chime plays because this effect is dependent
on posts. It only plays when the posts change, and the list of posts
only changes when a new one is added.
Later in the chapter, we’ll discuss the React Profiler, a browser
extension for testing performance and rendering of React components.
There, we’ll dig into more detail about when to use useMemo and
useCallback. (Spoiler alert: sparingly!)
When to useLayoutEffect
We understand that the render always comes before useEffect. The
render happens first, then all effects run in order with full access to all
of the values from the render. A quick look at the React docs will point
out that there’s another type of effect hook: useLayoutEffect.
useLayoutEffect is called at a specific moment in the render cycle. The
series of events is as follows:
1. Render
2. useLayoutEffect is called
3. Browser paint: the time when the component’s elements are
actually added to the DOM
4. useEffect is called
This can be observed by adding some simple console messages:
import React, { useEffect, useLayoutEffect } from "react";
function App() {
useEffect(() => console.log("useEffect"));
useLayoutEffect(() => console.log("useLayoutEffect"));
return <div>ready</div>;
}
In the App component, useEffect is the first hook, followed by
useLayoutEffect. We see that useLayoutEffect is invoked before
useEffect:
useLayoutEffect
useEffect
useLayoutEffect is invoked after the render but before the browser
paints the change. In most circumstances, useEffect is the right tool
for the job, but if your effect is essential to the browser paint (the
appearance or placement of the UI elements on the screen), you may
want to use useLayoutEffect. For instance, you may want to obtain
the width and height of an element when the window is resized:
function useWindowSize {
const [width, setWidth] = useState(0);
const [height, setHeight] = useState(0);
const resize = () => {
setWidth(window.innerWidth);
setHeight(window.innerHeight);
};
useLayoutEffect(() => {
window.addEventListener("resize", resize);
resize();
return () => window.removeEventListener("resize", resize);
}, []);
return [width, height];
};
The width and height of the window is information that your
component may need before the browser paints. useLayoutEffect is
used to calculate the window’s width and height before the paint.
Another example of when to use useLayoutEffect is when tracking
the position of the mouse:
function useMousePosition {
const [x, setX] = useState(0);
const [y, setY] = useState(0);
const setPosition = ({ x, y }) => {
setX(x);
setY(y);
};
useLayoutEffect(() => {
window.addEventListener("mousemove", setPosition);
return () => window.removeEventListener("mousemove", setPosition);
}, []);
return [x, y];
};
It’s highly likely that the x and y position of the mouse will be used
when painting the screen. useLayoutEffect is available to help
calculate those positions accurately before the paint.
Rules to Follow with Hooks
As you’re working with Hooks, there are a few guidelines to keep in
mind that can help avoid bugs and unusual behavior:
Hooks only run in the scope of a component
Hooks should only be called from React components. They can
also be added to custom Hooks, which are eventually added to
components. Hooks are not regular JavaScript—they’re a React
pattern, but they’re starting to be modeled and incorporated in other
libraries.
It’s a good idea to break functionality out into multiple Hooks
In our earlier example with the Jazzy News component, we split
everything related to subscriptions into one effect and everything
related to sound effects into another effect. This immediately made
the code easier to read, but there was another benefit to doing this.
Since Hooks are invoked in order, it’s a good idea to keep them
small. Once invoked, React saves the values of Hooks in an array
so the values can be tracked. Consider the following component:
function Counter() {
const [count, setCount] = useState(0);
const [checked, toggle] = useState(false);
useEffect(() => {
...
}, [checked]);
useEffect(() => {
...
}, []);
useEffect(() => {
...
}, [count]);
return ( ... )
}
The order of Hook calls is the same for each and every render:
[count, checked, DependencyArray, DependencyArray, DependencyArray]
Hooks should only be called at the top level
Hooks should be used at the top level of a React function. They
cannot be placed into conditional statements, loops, or nested
functions. Let’s adjust the counter:
function Counter() {
const [count, setCount] = useState(0);
if (count > 5) {
const [checked, toggle] = useState(false);
}
useEffect(() => {
...
});
if (count > 5) {
useEffect(() => {
...
});
}
useEffect(() => {
...
});
return ( ... )
}
When we use useState within the if statement, we’re saying that
the hook should only be called when the count value is greater
than 5. That will throw off the array values. Sometimes the array
will be: [count, checked, DependencyArray, 0,
DependencyArray]. Other times: [count, DependencyArray,
1]. The index of the effect in that array matters to React. It’s how
values are saved.
Wait, so are we saying that we can never use conditional logic in
React applications anymore? Of course not! We just have to
organize these conditionals differently. We can nest if statements,
loops, and other conditionals within the hook:
function Counter() {
const [count, setCount] = useState(0);
const [checked, toggle] =
useState(
count => (count < 5)
? undefined
: !c,
(count < 5) ? undefined
);
useEffect(() => {
...
});
useEffect(() => {
if (count < 5) return;
...
});
useEffect(() => {
...
});
return ( ... )
}
Here, the value for checked is based on the condition that the
count is greater than 5. When count is less than 5, the value for
checked is undefined. Nesting this conditional inside the hook
means that the hook remains on the top level, but the result is
similar. The second effect enforces the same rules. If the count is
less than 5, the return statement will prevent the effect from
continuing to execute. This keeps the hook values array intact:
[countValue, checkedValue, DependencyArray,
DependencyArray, DependencyArray].
Like conditional logic, you need to nest asynchronous behavior
inside of a hook. useEffect takes a function as the first argument,
not a promise. So you can’t use an async function as the first
argument: useEffect(async () => {}). You can, however,
create an async function inside of the nested function like this:
useEffect(() => {
const fn = async () => {
await SomePromise();
};
fn();
});
We created a variable, fn, to handle the async/await, then we called
the function as the return. You can give this function a name, or
you can use async effects as an anonymous function:
useEffect(() => {
(async () => {
await SomePromise();
})();
});
If you follow these rules, you can avoid some common gotchas with
React Hooks. If you’re using Create React App, there’s an ESLint
plug-in included called eslint-plugin-react-hooks that provides warning
hints if you’re in violation of these rules.
Improving Code with useReducer
Consider the Checkbox component. This component is a perfect
example of a component that holds simple state. The box is either
checked or not checked. checked is the state value, and setChecked is
a function that will be used to change the state. When the component
first renders, the value of checked will be false:
function Checkbox() {
const [checked, setChecked] = useState(false);
return (
<>
<input
type="checkbox"
value={checked}
onChange={() => setChecked(checked => !checked)}
/>
{checked ? "checked" : "not checked"}
</>
);
}
This works well, but one area of this function could be cause for alarm:
onChange={() => setChecked(checked => !checked)}
Look at it closely. It feels OK at first glance, but are we stirring up
trouble here? We’re sending a function that takes in the current value
of checked and returns the opposite, !checked. This is probably more
complex than it needs to be. Developers could easily send the wrong
information and break the whole thing. Instead of handling it this way,
why not provide a function as a toggle?
Let’s add a function called toggle that will do the same thing: call
setChecked and return the opposite of the current value of checked:
function Checkbox() {
const [checked, setChecked] = useState(false);
function toggle() {
setChecked(checked => !checked);
}
return (
<>
<input type="checkbox" value={checked} onChange={toggle} />
{checked ? "checked" : "not checked"}
</>
);
}
This is better. onChange is set to a predictable value: the toggle
function. We know what that function is going to do every time,
everywhere it’s used. We can still take this one step farther to yield
even more predictable results each time we use the checkbox
component. Remember the function we sent to setChecked in the
toggle function?
setChecked(checked => !checked);
We’re going to refer to this function, checked => !checked, by a
different name now: a reducer. A reducer function’s most simple
definition is that it takes in the current state and returns a new state. If
checked is false, it should return the opposite, true. Instead of
hardcoding this behavior into onChange events, we can abstract the
logic into a reducer function that will always produce the same results.
Instead of useState in the component, we’ll use useReducer:
function Checkbox() {
const [checked, toggle] = useReducer(checked => !checked, false);
return (
<>
<input type="checkbox" value={checked} onChange={toggle} />
{checked ? "checked" : "not checked"}
</>
);
}
useReducer takes in the reducer function and the initial state, false.
Then, we’ll set the onChange function to setChecked, which will call
the reducer function.
Our earlier reducer, checked => !checked, is a prime example of
this. If the same input is provided to a function, the same output should
be expected. This concept originates with Array.reduce in JavaScript.
reduce fundamentally does the same thing as a reducer: it takes in a
function (to reduce all of the values into a single value) and an initial
value and returns one value.
Array.reduce takes in a reducer function and an initial value. For
each value in the numbers array, the reducer is called until one value is
returned:
const numbers = [28, 34, 67, 68];
numbers.reduce((number, nextNumber) => number + nextNumber, 0); // 197
The reducer sent to Array.reduce takes in two arguments. You can
also send multiple arguments to a reducer function:
function Numbers() {
const [number, setNumber] = useReducer(
(number, newNumber) => number + newNumber,
0
);
return <h1 onClick={() => setNumber(30)}>{number}</h1>;
}
Every time we click on the h1, we’ll add 30 to the total.
useReducer to Handle Complex State
useReducer can help us handle state updates more predictably as state
becomes more complex. Consider an object that contains user data:
const firstUser = {
id: "0391-3233-3201",
firstName: "Bill",
lastName: "Wilson",
city: "Missoula",
state: "Montana",
email: "bwilson@mtnwilsons.com",
admin: false
};
Then we have a component called User that sets the firstUser as the
initial state, and the component displays the appropriate data:
function User() {
const [user, setUser] = useState(firstUser);
return (
<div>
<h1>
{user.firstName} {user.lastName} - {user.admin ? "Admin" :
"User"}
</h1>
<p>Email: {user.email}</p>
<p>
Location: {user.city}, {user.state}
</p>
<button>Make Admin</button>
</div>
);
}
A common error when managing state is to overwrite the state:
<button
onClick={() => {
setUser({ admin: true });
}}
>
Make Admin
</button>
Doing this would overwrite state from firstUser and replace it with
just what we sent to the setUser function: {admin: true}. This can
be fixed by spreading the current values from user, then overwriting
the admin value:
<button
onClick={() => {
setUser({ ...user, admin: true });
}}
>
Make Admin
</button>
This will take the initial state and push in the new key/values: {admin:
true}. We need to rewrite this logic in every onClick, making it prone
to error (we might forget to do this when we come back to the app
tomorrow):
function User() {
const [user, setUser] = useReducer(
(user, newDetails) => ({ ...user, ...newDetails }),
firstUser
);
...
}
Then we’ll send the new state value, newDetails, to the reducer, and it
will be pushed into the object:
<button
onClick={() => {
setUser({ admin: true });
}}
>
Make Admin
</button>
This pattern is useful when state has multiple subvalues or when the
next state depends on a previous state. Teach everyone to spread,
they’ll spread for a day. Teach everyone to useReducer and they’ll
spread for life.
LEGACY SETSTATE AND USEREDUCER
In previous versions of React, we used a function called setState to update state. Initial state would
be assigned in the constructor as an object:
class User extends React.Component {
constructor(props) {
super(props);
this.state = {
id: "0391-3233-3201",
firstName: "Bill",
lastName: "Wilson",
city: "Missoula",
state: "Montana",
email: "bwilson@mtnwilsons.com",
admin: false
};
}
}
<button onSubmit={() =>
{this.setState({admin: true });}}
Make Admin
</button>
The older incarnation of setState merged state values. The same is true of useReducer:
const [state, setState] = useReducer(
(state, newState) =>
({...state, ...newState}),
initialState);
<button onSubmit={() =>
{setState({admin: true });}}
Make Admin
</button>
</div>);
If you like this pattern, you can use legacy-set-state npm or useReducer.
The past few examples are simple applications for a reducer. In the next chapter, we’ll dig deeper into
reducer design patterns that can be used to simplify state management in your apps.
Improving Component Performance
In a React application, components are rendered…usually a lot.
Improving performance includes preventing unnecessary renders and
reducing the time a render takes to propagate. React comes with tools
to help us prevent unnecessary renders: memo, useMemo, and
useCallback. We looked at useMemo and useCallback earlier in the
chapter, but in this section, we’ll go into more detail about how to use
these Hooks to make your websites perform better.
The memo function is used to create pure components. As discussed in
Chapter 3, we know that, given the same parameters, a pure function
will always return the same result. A pure component works the same
way. In React, a pure component is a component that always renders
the same output, given the same properties.
Let’s create a component called Cat:
const Cat = ({ name }) => {
console.log(`rendering ${name}`);
return <p>{name}</p>;
};
Cat is a pure component. The output is always a paragraph that
displays the name property. If the name provided as a property is the
same, the output will be the same:
function App() {
const [cats, setCats] = useState(["Biscuit", "Jungle", "Outlaw"]);
return (
<>
{cats.map((name, i) => (
<Cat key={i} name={name} />
))}
<button onClick={() => setCats([...cats, prompt("Name a cat")])}>
Add a Cat
</button>
</>
);
}
This app uses the Cat component. After the initial render, the console
reads:
rendering Biscuit
rendering Jungle
rendering Outlaw
When the “Add a Cat” button is clicked, the user is prompted to add a
cat.
If we add a cat named “Ripple,” we see that all Cat components are
rerendered:
rendering Biscuit
rendering Jungle
rendering Outlaw
rendering Ripple
WARNING
This code works because prompt is blocking. This is just an example. Don’t use
prompt in a real app.
Every time we add a cat, every Cat component is rendered, but the Cat
component is a pure component. Nothing changes about the output
given the same prop, so there shouldn’t be a render for each of these.
We don’t want to rerender a pure component if the properties haven’t
changed. The memo function can be used to create a component that
will only render when its properties change. Start by importing it from
the React library and use it to wrap the current Cat component:
import React, { useState, memo } from "react";
const Cat = ({ name }) => {
console.log(`rendering ${name}`);
return <p>{name}</p>;
};
const PureCat = memo(Cat);
Here, we’ve created a new component called PureCat. PureCat will
only cause the Cat to render when the properties change. Then we can
replace the Cat component with PureCat in the App component:
cats.map((name, i) => <PureCat key={i} name={name} />);
Now, every time we add a new cat name, like “Pancake,” we see only
one render in the console:
rendering Pancake
Because the names of the other cats have not changed, we don’t render
those Cat components. This is working well for a name property, but
what if we introduce a function property to the Cat component?
const Cat = memo(({ name, meow = f => f }) => {
console.log(`rendering ${name}`);
return <p onClick={() => meow(name)}>{name}</p>;
});
Every time a cat is clicked on, we can use this property to log a meow to
the console:
<PureCat key={i} name={name} meow={name => console.log(`${name} has
meowed`)} />
When we add this change, PureCat no longer works as expected. It’s
always rendering every Cat component even though the name property
remains the same. This is because of the added meow property.
Unfortunately, every time we define the meow property as a function,
it’s always new function. To React, the meow property has changed, and
the component is rerendered.
The memo function will allow us to define more specific rules around
when this component should rerender:
const RenderCatOnce = memo(Cat, () => true);
const AlwaysRenderCat = memo(Cat, () => false);
The second argument sent to the memo function is a predicate. A
predicate is a function that only returns true or false. This function
decides whether to rerender a cat or not. When it returns false, the
Cat is rerendered. When this function returns true, the Cat will not be
rerendered. No matter what, the Cat is always rendered at least once.
This is why, with RenderCatOnce, it will render once and then never
again. Typically, this function is used to check actual values:
const PureCat = memo(
Cat,
(prevProps, nextProps) => prevProps.name === nextProps.name
);
We can use the second argument to compare properties and decide if
Cat should be rerendered. The predicate receives the previous
properties and the next properties. These objects are used to compare
the name property. If the name changes, the component will be rerendered. If the name is the same, it will be rerendered regardless of
what React thinks about the meow property.
shouldComponentUpdate and PureComponent
The concepts we’re discussing are not new to React. The memo function
is a new solution to a common problem. In previous versions of React,
there was a method called shouldComponentUpdate. If present in the
component, it was used to let React know under which circumstances
the component should update. shouldComponentUpdate described
which props or state would need to change for the component to
rerender. Once shouldComponentUpdate was part of the React library,
it was embraced as a useful feature by many. So useful that the React
team decided to create an alternate way of creating a component as a
class. A class component would look like this:
class Cat extends React.Component {
render() {
return (
{name} is a good cat!
)
}
}
A PureComponent would look like this:
class Cat extends React.PureComponent {
render() {
return (
{name} is a good cat!
)
}
}
PureComponent is the same as React.memo, but PureComponent is
only for class components; React.memo is only for function
components.
useCallback and useMemo can be used to memoize object and
function properties. Let’s use useCallback in the Cat component:
const PureCat = memo(Cat);
function App() {
const meow = useCallback(name => console.log(`${name} has meowed`, []);
return <PureCat name="Biscuit" meow={meow} />
}
In this case, we did not provide a property-checking predicate to
memo(Cat). Instead, we used useCallback to ensure that the meow
function had not changed. Using these functions can be helpful when
dealing with too many rerenders in your component tree.
When to Refactor
The last Hooks we discussed, useMemo and useCallback, along with
the memo function, are commonly overused. React is designed to be
fast. It’s designed to have components render a lot. The process of
optimizing for performance began when you decided to use React in
the first place. It’s fast. Any further refactoring should be a last step.
There are trade-offs to refactoring. Using useCallback and useMemo
everywhere because it seems like a good idea might actually make your
app less performant. You’re adding more lines of code and developer
hours to your application. When you refactor for performance, it’s
important to have a goal. Perhaps you want to stop the screen from
freezing or flickering. Maybe you know there are some costly functions
that are slowing the speed of your app unreasonably.
The React Profiler can be used to measure the performance of each of
your components. The profiler ships with the React Developer Tools
that you’ve likely installed already (available for Chrome and Firefox).
Always make sure your app works and you’re satisfied with the
codebase before refactoring. Over-refactoring, or refactoring before
your app works, can introduce weird bugs that are hard to spot, and it
might not be worth your time and focus to introduce these
optimizations.
In the last two chapters, we’ve introduced many of the Hooks that ship
with React. You’ve seen use cases for each hook, and you’ve created
your own custom Hooks by composing other Hooks. Next, we’ll build
on these foundational skills by incorporating additional libraries and
advanced patterns.
Chapter 8. Incorporating Data
Data is the lifeblood of our applications. It flows like water, and it
nourishes our components with value. The user interface components
we’ve composed are vessels for data. We fill our applications with data
from the internet. We collect, create, and send new data to the internet.
The value of our applications is not the components themselves—it’s
the data that flows through those components.
When we talk about data, it may sound a little like we’re talking about
water or food. The cloud is the abundantly endless source from which
we send and receive data. It’s the internet. It’s the networks, services,
systems, and databases where we manipulate and store zettabytes of
data. The cloud hydrates our clients with the latest and freshest data
from the source. We work with this data locally and even store it
locally. But when our local data becomes out of sync with the source, it
loses its freshness and is said to be stale.
These are the challenges we face as developers working with data. We
need to keep our applications hydrated with fresh data from the cloud.
In this chapter, we’re going to take a look at various techniques for
loading and working with data from the source.
Requesting Data
In the movie Star Wars, the droid C-3P0 is a protocol droid. His
specialty, of course, is communication. He speaks over six million
languages. Surely, C-3P0 knows how to send an HTTP request,
because the Hyper Text Transfer Protocol is one of the most popular
ways to transmit data to and from the internet.
HTTP provides the backbone for our internet communication. Every
time we load http://www.google.com into our browser, we’re asking
Google to send us a search form. The files necessary for us to search
are transmitted to the browser over HTTP. When we interact with
Google by searching for “cat photos,” we’re asking Google to find us
cat photos. Google responds with data, and images are transferred to
our browser over HTTP.
In JavaScript, the most popular way to make an HTTP request is to use
fetch. If we wanted to ask GitHub for information about Moon
Highway, we could do so by sending a fetch request:
fetch(`https://api.github.com/users/moonhighway`)
.then(response => response.json())
.then(console.log)
.catch(console.error);
The fetch function returns a promise. Here, we’re making an
asynchronous request to a specific URL:
https://api.github.com/users/moonhighway. It takes time for that
request to traverse the internet and respond with information. When it
does, that information is passed to a callback using the
.then(callback) method. The GitHub API will respond with JSON
data, but that data is contained in the body of the HTTP response, so
we call response.json() to obtain that data and parse it as JSON.
Once obtained, we log that data to the console. If anything goes wrong,
we’ll pass the error to the console.error method.
GitHub will respond to this request with a JSON object:
{
"login": "MoonHighway",
"id": 5952087,
"node_id": "MDEyOk9yZ2FuaXphdGlvbjU5NTIwODc=",
"avatar_url": "https://avatars0.githubusercontent.com/u/5952087?v=4",
"bio": "Web Development classroom training materials.",
...
}
On GitHub, basic information about user accounts is made available by
their API. Go ahead, try searching for yourself:
https://api.github.com/users/<YOUR_GITHUB_USER_NAME>.
Another way of working with promises is to use async/await. Since
fetch returns a promise, we can await a fetch request inside of an
async function:
async function requestGithubUser(githubLogin) {
try {
const response = await fetch(
`https://api.github.com/users/${githubLogin}`
);
const userData = await response.json();
console.log(userData);
} catch (error) {
console.error(error);
}
}
This code achieves the exact same results as the previous fetch request
that was made by chaining .then functions on to the request. When we
await a promise, the next line of code will not be executed until the
promise has resolved. This format gives us a nice way to work with
promises in code. We’ll be using both approaches for the remainder of
this chapter.
Sending Data with a Request
A lot of requests require us to upload data with the request. For
instance, we need to collect information about a user in order to create
an account, or we may need new information about a user to update
their account.
Typically, we use a POST request when we’re creating data and a PUT
request when we’re modifying it. The second argument of the fetch
function allows us to pass an object of options that fetch can use when
creating our HTTP request:
fetch("/create/user", {
method: "POST",
body: JSON.stringify({ username, password, bio })
});
This fetch is using the POST method to create a new user. The
username, password, and user’s bio are being passed as string content
in the body of the request.
Uploading Files with fetch
Uploading files requires a different type of HTTP request: a
multipart-formdata request. This type of request tells the server that
a file or multiple files are located in the body of the request. To make
this request in JavaScript, all we have to do is pass a FormData object
in the body of our request:
const formData = new FormData();
formData.append("username", "moontahoe");
formData.append("fullname", "Alex Banks");
forData.append("avatar", imgFile);
fetch("/create/user", {
method: "POST",
body: formData
});
This time, when we create a user, we’re passing the username,
fullname, and avatar image along with the request as a formData
object. Although these values are hardcoded here, we could easily
collect them from a form.
Authorized Requests
Sometimes, we need to be authorized to make requests. Authorization
is typically required to obtain personal or sensitive data. Additionally,
authorization is almost always required for users to take action on the
server with POST, PUT, or DELETE requests.
Users typically identify themselves with each request by adding a
unique token to the request that a service can use to identify the user.
This token is usually added as the Authorization header. On GitHub,
you can see your personal account information if you send a token
along with your request:
fetch(`https://api.github.com/users/${login}`, {
method: "GET",
headers: {
Authorization: `Bearer ${token}`
}
});
Tokens are typically obtained when a user signs into a service by
providing their username and password. Tokens can also be obtained
from third parties like GitHub or Facebook using with an open standard
protocol called OAuth.
GitHub allows you to generate a Personal User token. You can
generate one by logging in to GitHub and navigating to: Settings >
Developer Settings > Personal Access Tokens. From here, you can
create tokens with specific read/write rules and then use those tokens to
obtain personal information from the GitHub API. If you generate a
Personal Access Token and send it along with the fetch request,
GitHub will provide additional private information about your account.
Fetching data from within a React component requires us to orchestrate
the useState and useEffect hooks. The useState hook is used to
store the response in state, and the useEffect hook is used to make the
fetch request. For example, if we wanted to display information about a
GitHub user in a component, we could use the following code:
import React, { useState, useEffect } from "react";
function GitHubUser({ login }) {
const [data, setData] = useState();
useEffect(() => {
if (!login) return;
fetch(`https://api.github.com/users/${login}`)
.then(response => response.json())
.then(setData)
.catch(console.error);
}, [login]);
if (data)
return <pre>{JSON.stringify(data, null, 2)}</pre>;
return null;
}
export default function App() {
return <GitHubUser login="moonhighway" />;
}
In this code, our App renders a GitHubUser component and displays
JSON data about moonhighway. On the first render, GitHubUser sets
up a state variable for data using the useState hook. Then, because
data is initially null, the component returns null. Returning null
from a component tells React to render nothing. It doesn’t cause an
error; we’ll just see a black screen.
After the component is rendered, the useEffect hook is invoked. This
is where we make the fetch request. When we get a response, we obtain
and parse the data in that response as JSON. Now we can pass that
JSON object to the setData function, which causes our component to
render once again, but this time it will have data. This useEffect hook
will not be invoked again unless the value for login changes. When it
does, we’ll need to request more information about a different user
from GitHub.
When there is data, we’re rendering it as a JSON string in a pre
element. The JSON.stringify method takes three arguments: the
JSON data to convert to a string, a replacer function that can be used to
replace properties of the JSON object, and the number of spaces to use
when formatting the data. In this case, we sent null as the replacer
because we don’t want to replace anything. The 2 represents the
number of spaces to be used when formatting the code. This will indent
the JSON string two spaces. Using the pre element honors whitespace,
so readable JSON is what is finally rendered.
Saving Data Locally
We can save data locally to the browser using the Web Storage API.
Data can be saved by either using the window.localStorage or
window.sessionStorage objects. The sessionStorage API only
saves data for the user’s session. Closing the tabs or restarting the
browser will clear any data saved to sessionStorage. On the other
hand, localStorage will save data indefinitely until you remove it.
JSON data should be saved in browser storage as a string. This means
converting an object into a JSON string before saving it and parsing
that string into JSON while loading it. Some function to handle saving
and loading JSON data to the browser could look like:
const loadJSON = key =>
key && JSON.parse(localStorage.getItem(key));
const saveJSON = (key, data) =>
localStorage.setItem(key, JSON.stringify(data));
The loadJSON function loads an item from localStorage using the
key. The localStorage.getItem function is used to load the data. If
the item is there, it’s then parsed into JSON before being returned. If
it’s not there, the loadJSON function will return null.
The saveJSON function will save some data to localStorage using a
unique key identifier. The localStorage.setItem function can be
used to save data to the browser. Before saving the data, we’ll need to
convert it to a JSON string.
Loading data from web storage, saving data to web storage,
stringifying data, and parsing JSON strings are all synchronous tasks.
Both the loadJSON and saveJSON functions are synchronous. So be
careful—calling these functions too often with too much data can lead
to performance issues. It’s typically a good idea to throttle or debounce
these functions for the sake of performance.
We could save the user’s data that we received from our GitHub
request. Then the next time that same user is requested, we could use
the data saved to localStorage instead of sending another request to
GitHub. We’ll add the following code to the GitHubUser component:
const [data, setData] = useState(loadJSON(`user:${login}`));
useEffect(() => {
if (!data) return;
if (data.login === login) return;
const { name, avatar_url, location } = data;
saveJSON(`user:${login}`, {
name,
login,
avatar_url,
location
});
}, [data]);
The loadJSON function is synchronous, so we can use it when we
invoke useState to set the initial value for data. If there was user data
saved to the browser under user:moonhighway, we’ll initially set the
data using that value. Otherwise, data will initially be null.
When data changes here after it has been loaded from GitHub, we’ll
invoke saveJSON to save only those user details that we need: name,
login, avatar_url, and location. No need to save the rest of the
user object when we’re not using it. We also skip saving the data
when that object is empty, !data. Also, if the current login and
data.login are equal to each other, then we already have saved data
for that user. We’ll skip the step of saving that data again.
Here’s a look at the entire GitHubUser component that uses
localStorage to save data in the browser:
import React, { useState, useEffect } from "react";
const loadJSON = key =>
key && JSON.parse(localStorage.getItem(key));
const saveJSON = (key, data) =>
localStorage.setItem(key, JSON.stringify(data));
function GitHubUser({ login }) {
const [data, setData] = useState(
loadJSON(`user:${login}`)
);
useEffect(() => {
if (!data) return;
if (data.login === login) return;
const { name, avatar_url, location } = data;
saveJSON(`user:${login}`, {
name,
login,
avatar_url,
location
});
}, [data]);
useEffect(() => {
if (!login) return;
if (data && data.login === login) return;
fetch(`https://api.github.com/users/${login}`)
.then(response => response.json())
.then(setData)
.catch(console.error);
}, [login]);
if (data)
return <pre>{JSON.stringify(data, null, 2)}</pre>;
return null;
}
Notice the GitHubUser component now has two useEffect hooks.
The first hook is used to save the data to the browser. It’s invoked
whenever the value for data changes. The second hook is used to
request more data from GitHub. The fetch request is not sent when
there’s already data saved locally for that user. This is handled by the
second if statement in the second useEffect hook: if (data &&
data.login === login) return;. If there is data and the login for
that data matches the login property, then there’s no need to send an
additional request to GitHub. We’ll just use the local data.
The first time we run the application, if the login is set to
moonhighway, the following object will be rendered to the page:
{
"login": "MoonHighway",
"id": 5952087,
"node_id": "MDEyOk9yZ2FuaXphdGlvbjU5NTIwODc=",
"avatar_url": "https://avatars0.githubusercontent.com/u/5952087?v=4",
"gravatar_id": "",
"url": "https://api.github.com/users/MoonHighway",
"html_url": "https://github.com/MoonHighway",
...
}
This is the response from GitHub. We can tell because this object
contains a lot of extra information about the user that we don’t need.
The first time we run this page we’ll see this lengthy response. But the
second time we run the page, the response is much shorter:
{
"name": "Moon Highway",
"login": "moonhighway",
"avatar_url": "https://avatars0.githubusercontent.com/u/5952087?v=4",
"location": "Tahoe City, CA"
}
This time, the data we saved locally for moonhighway is being rendered
to the browser. Since we only needed four fields of data, we only saved
four fields of data. We’ll always see this smaller offline object until we
clear the storage:
localStorage.clear();
Both sessionStorage and localStorage are essential weapons for
web developers. We can work with this local data when we’re offline,
and they allow us to increase the performance of our applications by
sending fewer network requests. However, we must know when to use
them. Implementing offline storage adds complexity to our
applications, and it can make them tough to work with in development.
Additionally, we don’t need to work with web storage to cache data. If
we’re simply looking for a performance bump, we could try letting
HTTP handle caching. Our browser will automatically cache content if
we add Cache-Control: max-age=<EXP_DATE> to our headers. The
EXP_DATE defines the expiration date for the content.
Handling Promise States
HTTP requests and promises both have three states: pending, success
(fulfilled), and fail (rejected). A request is pending when we make the
request and are waiting for a response. That response can only go one
of two ways: success or fail. If a response is successful, it means we’ve
successfully connected to the server and have received data. In the
world of promises, a successful response means that the promise has
been resolved. If something goes wrong during this process, we can say
the HTTP request has failed or the promise has been rejected. In both
cases, we’ll receive an error explaining what happened.
We really need to handle all three of these states when we make HTTP
requests. We can modify the GitHub user component to render more
than just a successful response. We can add a “loading…” message
when the request is pending, or we can render the error details if
something goes wrong:
function GitHubUser({ login }) {
const [data, setData] = useState();
const [error, setError] = useState();
const [loading, setLoading] = useState(false);
useEffect(() => {
if (!login) return;
setLoading(true);
fetch(`https://api.github.com/users/${login}`)
.then(data => data.json())
.then(setData)
.then(() => setLoading(false))
.catch(setError);
}, [login]);
if (loading) return <h1>loading...</h1>;
if (error)
return <pre>{JSON.stringify(error, null, 2)}</pre>;
if (!data) return null;
return (
<div className="githubUser">
<img
src={data.avatar_url}
alt={data.login}
style={{ width: 200 }}
/>
<div>
<h1>{data.login}</h1>
{data.name && <p>{data.name}</p>}
{data.location && <p>{data.location}</p>}
</div>
</div>
);
}
When this request is successful, Moon Highway’s information is
rendered for the user to see on the screen, as shown in Figure 8-1.
Figure 8-1. Sample output
If something goes wrong, we’re simply displaying the error object as
a JSON string. In production, we would do more with the error. Maybe
we would track it, log it, or try to make another request. While in
development, it’s OK to render error details, which gives the developer
instant feedback.
Finally, while the request is pending, we simply display a “loading…”
message using an h1.
Sometimes an HTTP request can succeed with an error. This happens
when the request was successful—successfully connected to a server
and received a response—but the response body contains an error.
Sometimes servers pass additional errors as successful responses.
Handling all three of these states bloats our code a little bit, but it’s
essential to do so on every request. Requests take time and a lot could
go wrong. Because all requests—and promises—have these three
states, it makes it possible to handle all HTTP requests with a reusable
hook, or a component, or even a React feature called Suspense. We’ll
cover each of these approaches, but first, we must introduce the
concept of render props.
Render Props
Render props are exactly what they sound like: properties that are
rendered. This can mean components that are sent as properties that are
rendered when specific conditions are met, or it can mean function
properties that return components that will be rendered. In the second
case, when they’re functions, data can be passed as arguments and used
when rendering the returned component.
Render props are useful when maximizing reusability in asynchronous
components. With this pattern, we can create components that abstract
away complex mechanics or monotonous boilerplate that’s necessary
for application development.
Consider the task of displaying a list:
import React from "react";
const tahoe_peaks = [
{ name: "Freel Peak", elevation: 10891 },
{ name: "Monument Peak", elevation: 10067 },
{ name: "Pyramid Peak", elevation: 9983 },
{ name: "Mt. Tallac", elevation: 9735 }
];
export default function App() {
return (
<ul>
{tahoe_peaks.map((peak, i) => (
<li key={i}>
{peak.name} - {peak.elevation.toLocaleString()}ft
</li>
))}
</ul>
);
}
In this example, the four tallest peaks in Tahoe are rendered into an
unordered list. This code makes sense, but mapping over an array to
render each item individually does introduce some code complexity.
Mapping over an array of items is also a pretty common task. We may
find ourselves frequently repeating this pattern. We could create a List
component that we can reuse as a solution whenever we need to render
an unordered list.
In JavaScript, arrays either contain values or they’re empty. When a list
is empty, we need to display a message to our users. However, that
message may change upon implementation. No worries—we can pass a
component to render when the list is empty:
function List({ data = [], renderEmpty }) {
if (!data.length) return renderEmpty;
return <p>{data.length} items</p>;
}
export default function App() {
return <List renderEmpty={<p>This list is empty</p>} />;
}
The List component expects two properties: data and renderEmpty.
The first argument, data, represents the array of items that are to be
mapped over. Its default value is an empty array. The second argument,
renderEmpty, is a component that will be rendered if the list is empty.
So when data.length is 0, the List component renders whatever was
passed as the renderEmpty property by returning that property.
In this case, users would see the following message: This list is
empty.
renderEmpty is a render prop because it contains a component to
render when a particular condition has been met—in this case, when
the list is empty or the data property has not been provided.
We can send this component an actual array of data:
export default function App() {
return (
<List
data={tahoe_peaks}
renderEmpty={<p>This list is empty</p>}
/>
);
}
Doing so at this point only renders the number of items found within
the array: 4 items.
We can also tell our List component what to render for each item
found within the array. For example, we can send a renderItem
property:
export default function App() {
return (
<List
data={tahoe_peaks}
renderEmpty={<p>This list is empty</p>}
renderItem={item => (
<>
{item.name} - {item.elevation.toLocaleString()}ft
</>
)}
/>
);
}
This time, the render prop is a function. The data (the item itself) is
passed to this function as an argument so that it can be used when what
to render for each Tahoe Peak is decided. In this case, we render a
React fragment that displays the item’s name and elevation. If the
array is tahoe_peaks, we expect the renderItem property to be
invoked four times: once for each of the peaks in the array.
This approach allows us to abstract away the mechanics of mapping
over arrays. Now the List component will handle the mapping; we just
have to tell it what to render:
function List({ data = [], renderItem, renderEmpty }) {
return !data.length ? (
renderEmpty
) : (
<ul>
{data.map((item, i) => (
<li key={i}>{renderItem(item)}</li>
))}
</ul>
);
}
When the data array is not empty, the List component renders an
unordered list, <ul>. It maps over each item within the array using the
.map method and renders a list item, <li>, for every value within the
array. The List component makes sure each list item receives a unique
key. Within each <li> element, the renderItem property is invoked
and the item itself is passed to that function property as an argument.
The result is an unordered list that displays the name and elevation of
each of Tahoe’s tallest peaks.
The good news is we have a reusable List component that we can use
whenever we need to render an unordered list. The bad news is our
component is a bit bare bones. There are better components we can use
to handle this task.
Virtualized Lists
If it’s our job to develop a reusable component for rendering lists, there
are many different use cases to consider and solutions to implement.
One of the most important things to consider is what happens when the
list is very large. Many of the data points we work with in production
can feel infinite. A Google search yields pages and pages of results.
Searching for a place to stay in Tahoe on Airbnb results in a list of
houses and apartments that seems to never end. Production applications
typically have a lot of data that needs to be rendered, but we can’t
render it all at once.
There’s a limit to what the browser can render. Rendering takes time,
processing power, and memory, all three of which have eventual
limitations. This should be taken into consideration when developing a
reusable list component. When the data array is very large, what
should we do?
Even though our search for a place to stay may have yielded one
thousand results, we cannot possibly look at all those results at the
same time—there’s not enough screen space for all the images, names,
and prices. We might only be able to see about five results at a time.
When scrolling, we can see more results, but we have to scroll down
pretty far to see a thousand results. Rendering a thousand results in a
scrollable layer is asking a lot of the phone.
Instead of rendering 1,000 results at a time, what if we only rendered
11? Remember that the user can only see about five results on one
screen. So we render the five items the user can see and render six
items off screen both above and below the visible window of items.
Rendering items above and below the visible window will allow the
user to scroll in both directions. We can see that in Figure 8-2.

Figure 8-2. Windowing with off-screen content
As the user scrolls, we can unmount the results that have already been
viewed as well as render new results off screen, ready for the user to
reveal via the scroll. This resulting solution means that the browser will
only render 11 elements at a time while the data for the rest of the
elements is there waiting to be rendered. This technique is called
windowing or virtualization. It allows us to scroll very large,
sometimes infinite lists of data without crashing our browser.
There’s a lot to consider when building a virtualized list component.
Thankfully, we don’t have to start from scratch; the community has
already developed many virtualized list components for us to use. The
most popular of these for the browser are react-window and reactvirtualized. Virtualized lists are so important that React Native even
ships with one: the FlatList. Most of us will not have to build
virtualized list components, but we do need to know how to use them.
To implement a virtualized list, we’re going to need a lot of data—in
this case, fake data:
npm i faker
Installing faker will allow us to create a large array of fake data. For
this example, we’ll use fake users. We’ll create five thousand fake
users at random:
import faker from "faker";
const bigList = [...Array(5000)].map(() => ({
name: faker.name.findName(),
email: faker.internet.email(),
avatar: faker.internet.avatar()
}));
The bigList variable was created by mapping over an array of five
thousand empty values and replacing those empty values with
information about a fake user. The name, email, and avatar for each
user are generated at random using functions supplied by faker.
If we use the List component we created in the last section, it will
render all five thousand users at the same time:
export default function App() {
const renderItem = item => (
<div style={{ display: "flex" }}>
<img src={item.avatar} alt={item.name} width={50} />
<p>
{item.name} - {item.email}
</p>
</div>
);
return <List data={bigList} renderItem={renderItem} />;
}
This code creates a div element for each user. Within that div, an img
element is rendered for that user’s photo, and the user name and email
are rendered with a paragraph element, as shown in Figure 8-3.
Figure 8-3. Performance results
The combination of React and modern browsers is already pretty
amazing. We’re most likely able to render all five thousand users, but it
takes a while. In this example, it took 52ms to be exact. As the number
of users in our list goes up, so does this time, until we eventually reach
a tipping point.
Let’s render the same fake user list using react-window:
npm i react-window
react-window is a library that has several components we can use to
render virtualized lists. In this example, we’ll use the FixSizeList
component from react-window:
import React from "react";
import { FixedSizeList } from "react-window";
import faker from "faker";
const bigList = [...Array(5000)].map(() => ({
name: faker.name.findName(),
email: faker.internet.email(),
avatar: faker.internet.avatar()
}));
export default function App() {
const renderRow = ({ index, style }) => (
<div style={{ ...style, ...{ display: "flex" } }}>
<img
src={bigList[index].avatar}
alt={bigList[index].name}
width={50}
/>
<p>
{bigList[index].name} - {bigList[index].email}
</p>
</div>
);
return (
<FixedSizeList
height={window.innerHeight}
width={window.innerWidth - 20}
itemCount={bigList.length}
itemSize={50}
>
{renderRow}
</FixedSizeList>
);
}
FixedSizeList is slightly different from our List component. It
requires the total number of items in the list along with the number of
pixels each row requires as the itemSize property. Another big
difference in this syntax is that the render prop is being passed to
FixedSizeList as the children property. This render props pattern is
used quite frequently.
So, let’s see what happens when five thousand fake users are rendered
with the FixSizeList component (see Figure 8-4).
This time, not all of the users are being rendered at once. Only those
rows that the user can see or easily scroll to are being rendered. Notice
that it only takes 2.6ms for this initial render.
As you scroll down to reveal more users, the FixedSizeList is hard at
work rendering more users off screen as well as removing users that
have scrolled off screen. This component automatically handles
scrolling in both directions. This component may render quite
frequently, but the renders are fast. It also doesn’t matter how many
users are in our array: the FixedSizeList can handle it.
Figure 8-4. 2.6ms for this render
Creating a Fetch Hook
We know that a request is either pending, successful, or failed. We can
reuse the logic that’s necessary for making a fetch request by creating a
custom hook. We’ll call this hook useFetch, and we can use it in
components across our application whenever we need to make a fetch
request:
import React, { useState, useEffect } from "react";
export function useFetch(uri) {
const [data, setData] = useState();
const [error, setError] = useState();
const [loading, setLoading] = useState(true);
useEffect(() => {
if (!uri) return;
fetch(uri)
.then(data => data.json())
.then(setData)
.then(() => setLoading(false))
.catch(setError);
}, [uri]);
return {
loading,
data,
error
};
}
This custom hook was created by composing the useState and
useEffect hooks. The three states of a fetch request are represented in
this hook: pending, success, and error. When the request is pending, the
hook will return true for loading. When the request is successful and
data is retrieved, it will be passed to the component from this hook. If
something goes wrong, then this hook will return the error.
All three of these states are managed inside of the useEffect hook.
This hook is invoked every time the value for uri changes. If there’s
no uri, the fetch request is not made. When there’s a uri, the fetch
request begins. If the request is successful, we pass the resulting JSON
to the setData function, changing the state value for data. After that,
we then change the state value for loading to false because the request
was successful (i.e., it’s no longer pending). Finally, if anything goes
wrong, we catch it and pass it to setError, which changes the state
value for error.
Now we can use this hook to make fetch requests within our
components. Anytime the values for loading, data, or error change,
this hook causes the GitHubUser component to rerender with those
new values:
function GitHubUser({ login }) {
const { loading, data, error } = useFetch(
`https://api.github.com/users/${login}`
);
if (loading) return <h1>loading...</h1>;
if (error)
return <pre>{JSON.stringify(error, null, 2)}</pre>;
return (
<div className="githubUser">
<img
src={data.avatar_url}
alt={data.login}
style={{ width: 200 }}
/>
<div>
<h1>{data.login}</h1>
{data.name && <p>{data.name}</p>}
{data.location && <p>{data.location}</p>}
</div>
</div>
);
}
Although the component now has less logic, it still handles all three
states. Assuming we have a SearchForm component ready to collect
search strings from the user, we can add the GitHubUser component to
our main App component:
import React, { useState } from "react";
import GitHubUser from "./GitHubUser";
import SearchForm from "./SearchForm";
export default function App() {
const [login, setLogin] = useState("moontahoe");
return (
<>
<SearchForm value={login} onSearch={setLogin} />
<GitHubUser login={login} />
</>
);
}
The main App component stores the username of the GitHub user in
state. The only way to change this value is to use the search form to
search for a new user. Whenever the value of login changes, the value
sent to useFetch changes because it depends on the login property:
https://api.github.com/users/${login}. This changes the uri within our
hook and triggers a fetch request for the new user login. We’ve created
a custom hook and used it to successfully create a small application
that can be used to look up and display GitHub user details. We’ll
continue to use this hook as we iterate on this application.
Creating a Fetch Component
Hooks typically allow us to reuse functionality across components.
There are times when we find ourselves repeating the exact same
pattern when it comes to rendering within our components. For
example, the loading spinner we choose to render may be the exact
same spinner we want to render across our entire application whenever
a fetch request is pending. The way we handle errors with our fetch
requests may also be consistent across our application.
Instead of replicating the exact same code in multiple components
across our application, we can create one component to render
consistent loading spinners and consistently handle all of our errors
across our entire domain. Let’s create a Fetch component:
function Fetch({
uri,
renderSuccess,
loadingFallback = <p>loading...</p>,
renderError = error => (
<pre>{JSON.stringify(error, null, 2)}</pre>
)
}) {
const { loading, data, error } = useFetch(uri);
if (loading) return loadingFallback;
if (error) return renderError(error);
if (data) return renderSuccess({ data });
}
The custom hook, useFetch, is one layer of abstraction: it abstracts
away the mechanics of making a fetch request. The Fetch component
is an additional layer of abstraction: it abstracts away the mechanics of
handling what to render. When the request is loading, the Fetch
component will render whatever was passed to the optional
loadingFallback property. When it’s successful, the JSON response
data is passed to the renderSuccess property. If there’s an error, it’s
rendered using the optional renderError property. The
loadingFallback and renderError properties provide an optional
layer of customization. However, when they’re not supplied, they fall
back to their default values.
With the Fetch component in our arsenal, we can really simplify the
logic in our GitHubUser component:
import React from "react";
import Fetch from "./Fetch";
export default function GitHubUser({ login }) {
return (
<Fetch
uri={`https://api.github.com/users/${login}`}
renderSuccess={UserDetails}
/>
);
}
function UserDetails({ data }) {
return (
<div className="githubUser">
<img
src={data.avatar_url}
alt={data.login}
style={{ width: 200 }}
/>
<div>
<h1>{data.login}</h1>
{data.name && <p>{data.name}</p>}
{data.location && <p>{data.location}</p>}
</div>
</div>
);
}
The GitHubUser component receives a login for a user to look up on
GitHub. We use that login to construct the uri property we send to the
fetch component. If successful, the UserDetails component is
rendered. When the Fetch component is loading, the default
“loading…” message will be displayed. If something goes wrong, the
error details are automatically displayed.
We can provide custom values for these properties. Here’s an example
of how we can alternatively use our flexible component:
<Fetch
uri={`https://api.github.com/users/${login}`}
loadingFallback={<LoadingSpinner />}
renderError={error => {
// handle error
return <p>Something went wrong... {error.message}</p>;
}}
renderSuccess={({ data }) => (
<>
<h1>Todo: Render UI for data</h1>
<pre>{JSON.stringify(data, null, 2)}</pre>
</>
)}
/>
This time, the Fetch component will render our custom loading
spinner. If something goes wrong, we hide the error details. When the
request is successful, we’ve chosen to alternatively render the raw data
along with a TODO message for ourselves.
Be careful: extra layers of abstraction, whether through hooks or
components, can add complexity to our code. It’s our job to reduce
complexity wherever we can. However, in this case, we’ve reduced
complexity by abstracting away reusable logic into a component and a
hook.
Handling Multiple Requests
Once we start making requests for data from the internet, we won’t be
able to stop. More often than not, we need to make several HTTP
requests to obtain all the data required to hydrate our application. For
example, we’re currently asking GitHub to provide information about a
user’s account. We’ll also need to obtain information about that user’s
repositories. Both of these data points are obtained by making separate
HTTP requests.
GitHub users typically have many repositories. Information about a
user’s repositories is passed as an array of objects. We’re going to
create a special custom hook called useIterator that will allow us to
iterate through any array of objects:
export const useIterator = (
items = [],
initialIndex = 0
) => {
const [i, setIndex] = useState(initialIndex);
const prev = () => {
if (i === 0) return setIndex(items.length - 1);
setIndex(i - 1);
};
const next = () => {
if (i === items.length - 1) return setIndex(0);
setIndex(i + 1);
};
return [items[i], prev, next];
};
This hook will allow us to cycle through any array. Because it returns
items inside of an array, we can take advantage of array destructuring
to give these values names that make sense:
const [letter, previous, next] = useIterator([
"a",
"b",
"c"
]);
In this case, the initial letter is “b.” If the user invokes next, the
component will rerender, but this time, the value for letter will be
“b.” Invoke next two more times, and the value for letter will once
again be “a” because this iterator circles back around to the first item in
the array instead of letting the index go out of bounds.
The useIterator hook takes in an array of items and an initial index.
The key value to this iterator hook is the index, i, which was created
with the useState hook. i is used to identify the current item in the
array. This hook returns the current item, item[i], as well as functions
for iterating through that array: prev and next. Both the prev and
next functions either decrement or increment the value of i by
invoking setIndex. This action causes the hook to rerender with a new
index.
Memozing Values
The useIterator hook is pretty cool. But we can do even better by
memoizing the value for item as well as the function for prev and
next:
import React, { useCallback, useMemo } from "react";
export const useIterator = (
items = [],
initialValue = 0
) => {
const [i, setIndex] = useState(initialValue);
const prev = useCallback(() => {
if (i === 0) return setIndex(items.length - 1);
setIndex(i - 1);
}, [i]);
const next = useCallback(() => {
if (i === items.length - 1) return setIndex(0);
setIndex(i + 1);
}, [i]);
const item = useMemo(() => items[i], [i]);
return [item || items[0], prev, next];
};
Here, both prev and next are created with the useCallback hook.
This ensures that the function for prev will always be the same until
the value for i changes. Likewise, the item value will always point to
the same item object unless the value for i changes.
Memoizing these values does not give us huge performance gains, or at
least not enough to justify the code complexity. However, when a
consumer uses the useIterator component, the memoized values will
always point to the exact same object and function. This makes it easier
on our consumers when they need to compare these values or use them
in their own dependency arrays.
Now, we’re going to create a repository menu component. Within this
component, we’ll use the useIterator hook to allow the users to
cycle through their list of repositories:
< learning-react >
If they click the Next button, they’ll see the name of the next
repository. Likewise, if they click the Previous button, they’ll see the
name of the previous repository. RepoMenu is the component we’ll
create to provide this feature:
import React from "react";
import { useIterator } from "../hooks";
export function RepoMenu({
repositories,
onSelect = f => f
}) {
const [{ name }, previous, next] = useIterator(
repositories
);
useEffect(() => {
if (!name) return;
onSelect(name);
}, [name]);
return (
<div style={{ display: "flex" }}>
<button onClick={previous}>&lt;</button>
<p>{name}</p>
<button onClick={next}>&gt;</button>
</div>
);
}
RepoMenu receives a list of repositories as a prop. It then
destructures the name from the current repository object and the
previous and next functions from useIterator. &lt; is an entity for
“Less Than,” and a less than sign, “<”, is displayed. The same is true
for &gt;, greater than. These are indicators for previous and next, and
when the user clicks on either of these indicators, the component is
rerendered with a new repository name. If the name changes, then the
user has selected a different repository, so we invoke the onSelect
function and pass the name of the new repository to that function as an
argument.
Remember, array destructuring allows us to name the items whatever
we want. Even though we named those functions prev and next within
the hook, here, when we use the hook, we can change their names to
previous and next.
Now we can create the UserRepositories component. This
component should request a list of a GitHub user’s repositories first,
and once received, pass that list to the RepoMenu component:
import React from "react";
import Fetch from "./Fetch";
import RepoMenu from "./RepoMenu";
export default function UserRepositories({
login,
selectedRepo,
onSelect = f => f
}) {
return (
<Fetch
uri={`https://api.github.com/users/${login}/repos`}
renderSuccess={({ data }) => (
<RepoMenu
repositories={data}
selectedRepo={selectedRepo}
onSelect={onSelect}
/>
)}
/>
);
}
The UserRepositories component requires a login to use in order to
make the fetch request for a list of repositories. That login is used to
create the URI and pass it to the Fetch component. Once the fetch has
successfully resolved, we’ll render the RepoMenu along with the list of
repositories that was returned from the Fetch component as data.
When the user selects a different repository, we simply pass the name
of that new repository along to the parent object:
function UserDetails({ data }) {
return (
<div className="githubUser">
<img src={data.avatar_url} alt={data.login} style={{ width: 200 }}
/>
<div>
<h1>{data.login}</h1>
{data.name && <p>{data.name}</p>}
{data.location && <p>{data.location}</p>}
</div>
<UserRepositories
login={data.login}
onSelect={repoName => console.log(`${repoName} selected`)}
/>
</div>
);
Now we need to add our new component to the UserDetails
component. When the UserDetails component is rendered, we’ll also
render that user’s repository list. Assuming the login value is
eveporcello, the rendered output for the above component would
look something like Figure 8-5.
Figure 8-5. Repository output
In order to get information about Eve’s account along with her list of
repositories, we need to send two separate HTTP requests. A majority
of our lives as React developers will be spent like this: making multiple
requests for information and composing all of the information received
into beautiful user interface applications. Making two requests for
information is just the beginning. In the next section, we’ll continue to
make more requests of GitHub so we can see the README.md for the
selected repository.
Waterfall Requests
In the last section, we made two HTTP requests. The first request was
for a user’s details, then once we had those details, we made a second
request for that user’s repositories. These requests happen one at a
time, one after the other.
The first request is made when we initially fetch the user’s details:
<Fetch
uri={`https://api.github.com/users/${login}`}
renderSuccess={UserDetails}
/>
Once we have that user’s details, the UserDetails component is
rendered. It in turn renders UserRepositories, which then sends a
fetch request for that user’s repositories:
<Fetch
uri={`https://api.github.com/users/${login}/repos`}
renderSuccess={({ data }) => (
<RepoMenu repositories={data} onSelect={onSelect} />
)}
/>
We call these requests waterfall requests because they happen one right
after the other—they’re dependent on each other. If something goes
wrong with the user details request, the request for that user’s
repositories is never made.
Let’s add some more layers (water?) to this waterfall. First, we request
the user’s info, then their repository list, then, once we have their
repository list, we make a request for the first repository’s
README.md file. As the user cycles through the list of repositories,
we’ll make additional requests for the associated README to each
repository.
Repository README files are written using Markdown, which is a
text format that can be easily rendered as HTML with the
ReactMarkdown component. First, let’s install react-markdown:
npm i react-markdown
Requesting the contents of a repository’s README file also requires a
waterfall of requests. First, we have to make a data request to the
repository’s README route:
https://api.github.com/repos/${login}/${repo}/readme. GitHub will
respond to this route with the details about a repository’s README
file but not the contents of that file. It does provide us with a
download_url that we can use to request the contents of the README
file. But to get the Markdown content, we’ll have to make an additional
request. Both of these requests can be made within a single async
function:
const loadReadme = async (login, repo) => {
const uri = `https://api.github.com/repos/${login}/${repo}/readme`;
const { download_url } = await fetch(uri).then(res =>
res.json()
);
const markdown = await fetch(download_url).then(res =>
res.text()
);
console.log(`Markdown for ${repo}\n\n${markdown}`);
};
In order to find a repository README, we need the repository owner’s
login and the name of the repository. Those values are used to
construct a unique URL:
https://api.github.com/repos/moonhighway/learning-react/readme.
When this request is successful, we destructure the download_url
from its response. Now we can use this value to download the contents
of the README; all we have to do is fetch the download_url. We’ll
parse this text as text—res.text()—rather than JSON because the
body of the response is Markdown text.
Once we have the Markdown, let’s render it by wrapping the
loadReadme function inside of a React component:
import React, {
useState,
useEffect,
useCallback
} from "react";
import ReactMarkdown from "react-markdown";
export default function RepositoryReadme({ repo, login }) {
const [loading, setLoading] = useState(false);
const [error, setError] = useState();
const [markdown, setMarkdown] = useState("");
const loadReadme = useCallback(async (login, repo) => {
setLoading(true);
const uri = `https://api.github.com/repos/${login}/${repo}/readme`;
const { download_url } = await fetch(uri).then(res =>
res.json()
);
const markdown = await fetch(download_url).then(res =>
res.text()
);
setMarkdown(markdown);
setLoading(false);
}, []);
useEffect(() => {
if (!repo || !login) return;
loadReadme(login, repo).catch(setError);
}, [repo]);
if (error)
return <pre>{JSON.stringify(error, null, 2)}</pre>;
if (loading) return <p>Loading...</p>;
return <ReactMarkdown source={markdown} />;
}
First, we add the loadReadme function to the component using the
useCallback hook to memoize the function when the component
initially renders. This function now changes the loading state to true
before the fetch request and changes it back to false after the request.
When the Markdown is received, it’s saved in state using the
setMarkdown function.
Next, we need to actually call loadReadme, so we add a useEffect
hook to load the README file after the component initially renders. If
for some reason the properties for repo and login are not present, the
README will not be loaded. The dependency array in this hook
contains [repo]. This is because we want to load another README if
the value for repo changes. If anything goes wrong while loading the
README, it will be caught and sent to the setError function.
Notice we have to handle the same three render states that we do for
every fetch request: pending, success, and fail. Finally, when we have a
successful response, the Markdown itself is rendered using the
ReactMarkdown component.
All there is left to do is render the RepositoryReadme component
inside of the RepoMenu component. As the user cycles through
repositories using the RepoMenu component, the README for each
repository will also be loaded and displayed:
export function RepoMenu({ repositories, login }) {
const [{ name }, previous, next] = useIterator(
repositories
);
return (
<>
<div style={{ display: "flex" }}>
<button onClick={previous}>&lt;</button>
<p>{name}</p>
<button onClick={next}>&gt;</button>
</div>
<RepositoryReadme login={login} repo={name} />
</>
);
}
Now our application is really making multiple requests; initially, it
makes four requests: one for the user’s details, then one for that user’s
repository list, then one for information about the selected repository’s
README, and finally one more request for the text contents of the
README. These are all waterfall requests because they happen one
after another.
Additionally, as the user interacts with the application, more requests
are made. Two waterfall requests are made to obtain the README file
every time the user changes the current repository. All four initial
waterfall requests are made every time the user searches for a different
GitHub account.
Throttling the Network Speed
All of these requests are visible from the Network tab under your
developer tools. From this tab, you can see every request, and you can
throttle your network speed to see how these requests unfold on slow
networks. If you want to see how the waterfall requests happen one
after another you can slow down your network speed and see the
loading messages as they’re rendered.
The Network tab is available under the developer tools of most major
browsers. To throttle the network speed in Google Chrome, select the
arrow next to the word “Online,” as demonstrated in Figure 8-6.
Figure 8-6. Changing the speed of the network request
This will open a menu where you can choose various speeds, as you
can see in Figure 8-7.
Figure 8-7. Selecting the speed of the network request
Selecting “Fast 3G” or “Slow 3G” will significantly throttle your
network requests.
Additionally, the Network tab displays a timeline for all of the HTTP
requests. You can filter this timeline to only view “XHR” requests.
This means it will only show the request made using fetch (Figure 8-
8).
Figure 8-8. The waterfall of a request
Here, we see that four requests were made one after the other. Notice
that the loading graphic is titled “Waterfall.” This shows that each
request is made after the other is complete.
Parallel Requests
Sometimes, it’s possible to make an application faster by sending all
requests at once. Instead of having each request occur one after another
in a waterfall, we can send our requests in parallel, or at the same time.
The reason our application is currently making a waterfall of request is
that the components are rendered inside of one another. GitHubUser
eventually renders UserRepositories, which eventually renders
RepositoryReadme. Requests are not made until each component has
been rendered.
Making these requests in parallel is going to require a different
approach. First, we’ll need to remove the <RepositoryReadme />
from the RepoMenu’s render function. This is a good move. The
RepoMenu should only focus on the logistics of creating a menu of
repositories that the user can cycle through. The RepositoryReadme
component should be handed in a different component.
Next, we’ll need to remove <RepoMenu /> from the renderSuccess
property of UserRepositories. Likewise, <UserRepositories />
needs to be removed from the UserDetails component.
Instead of nesting these components inside of one another, we’ll place
them all on the same level next to one another, all within the App
component:
import React, { useState } from "react";
import SearchForm from "./SearchForm";
import GitHubUser from "./GitHubUser";
import UserRepositories from "./UserRepositories";
import RepositoryReadme from "./RepositoryReadme";
export default function App() {
const [login, setLogin] = useState("moonhighway");
const [repo, setRepo] = useState("learning-react");
return (
<>
<SearchForm value={login} onSearch={setLogin} />
<GitHubUser login={login} />
<UserRepositories
login={login}
repo={repo}
onSelect={setRepo}
/>
<RepositoryReadme login={login} repo={repo} />
</>
);
}
The GitHubUser, UserRepositories, and RepositoryReadme
components all send HTTP requests to GitHub for data. Rending them
side-by-side on the same level will cause all of these requests to
happen at the same time, in parallel.
Each component requires specific information in order to make the
request. We need a login to obtain a GitHub user. We need a login to
obtain a list of user repositories. The RepositoryReadme requires both
a login and a repo to work properly. To make sure all of the
components have what they need to make their requests, we initialize
the app to display the details for the user “moonhighway” and the
repository “learning-react.”
If the user searches for another GitHubUser with the SearchForm, the
value for login will change, which will trigger the useEffect hooks
within our components, causing them to make additional requests for
data. If the user cycles through the list of repositories, then the
onSelect property for UserRepositories will be invoked, which
causes the repo value to change. Changing the repo value will trigger
the useEffect hook inside of the RepositoryReadme component, and
a new README will be requested.
The RepoMenu component always starts with the first repository, no
matter what. We have to see if there’s a selectedRepo property. If
there is, we need to use it to find the initial index for the repository to
be displayed:
export function RepoMenu({ repositories, selected, onSelect = f => f }) {
const [{ name }, previous, next] = useIterator(
repositories,
selected ? repositories.findIndex(repo => repo.name === selected) :
null
);
...
}
The second argument for the useIterator hook is the initial index to
start with. If there’s a selected property, then we’ll search for the
index of the selected repository by name. This is required to make sure
the repository menu displays the correct repository initially. We also
need to pass this selected property to this component from
UserRepositories:
<Fetch
uri={`https://api.github.com/users/${login}/repos`}
renderSuccess={({ data }) => (
<RepoMenu
repositories={data}
selected={repo}
onSelect={onSelect}
/>
)}
/>
Now that the repo property is being passed down to the RepoMenu, the
menu should select the initial repository, which in our case is
“learning-react.”
If you take a look at the Network tab, you’ll notice we’ve made three
requests in parallel, as shown in Figure 8-9.
Figure 8-9. Creating a parallel request
So each component made its request at the same time. The RepoReadme
component still has to make a waterfall request to obtain the contents
of the README file. This is OK. It’s hard to make every request right
when your app initially renders. Parallel and waterfall requests can
work in conjunction with each other.
Waiting for Values
We currently initialize the values for login and repo to
“moonhighway” and “learning-react.” We may not always be able to
guess which data to render first. When that’s the case, we simply don’t
render the component until the data it requires is present:
export default function App() {
const [login, setLogin] = useState();
const [repo, setRepo] = useState();
return (
<>
<SearchForm value={login} onSearch={setLogin} />
{login && <GitHubUser login={login} />}
{login && (
<UserRepositories
login={login}
repo={repo}
onSelect={setRepo}
/>
)}
{login && repo && (
<RepositoryReadme login={login} repo={repo} />
)}
</>
);
}
In this scenario, none of the components are rendered until their
required props have values. Initially, the only component rendered is
the SearchForm. Searching for a user will change the value for login,
causing the UserRepositories component to render. When this
component looks up the repositories, it will select the first repository in
the list, causing setRepo to be invoked. Finally, we have a login and a
repo, so the RepositoryReadme component will be rendered.
Canceling Requests
Thinking about our application a little bit more, we realize that the user
could empty the search field and search for no user at all. In this case,
we would also want to make sure that the value for repo is also empty.
Let’s add a handleSearch method that makes sure the repo value
changes when there’s no value for login:
export default function App() {
const [login, setLogin] = useState("moonhighway");
const [repo, setRepo] = useState("learning-react");
const handleSearch = login => {
if (login) return setLogin(login);
setLogin("");
setRepo("");
};
if (!login)
return (
<SearchForm value={login} onSearch={handleSearch} />
);
return (
<>
<SearchForm value={login} onSearch={handleSearch} />
<GitHubUser login={login} />
<UserRepositories
login={login}
repo={repo}
onSelect={setRepo}
/>
<RepositoryReadme login={login} repo={repo} />
</>
);
}
We’ve added a handleSearch method. Now, when the user clears the
search field and searches for an empty string, the repo value is also set
to an empty string. If for some reason there’s not a login, we only
render one component: the SearchForm. When we have a value for
login, we’ll render all four components.
Now, technically our app has two screens. One screen only displays a
search form. The other screen only shows when the search form
contains a value, in which case, it shows all four components. We’ve
set ourselves up to mount or unmount components based on user
interactivity. Let’s say we were looking at the details for
“moonhighway.” If the user empties the search field, then the
GitHubUser, UserRepositories, and RepositoryReadme
components are unmounted and will no longer be displayed. But what
if these components were in the middle of loading data when they were
unmounted?
You can try it out:
1. Throttle the network to “Slow 3G” to have enough time to
cause problems
2. Change the value of the search field from “moonhighway” to
“eveporcello”
3. While the data is loading, search for an empty string, “”
These steps will cause the GitHubUser, UserRepositories, and
RepositoryReadme to become unmounted while they’re in the middle
of making fetch requests. Eventually, when there’s a response to the
fetch request, these components are no longer mounted. Attempting to
change state values in an unmounted component will cause the error
shown in Figure 8-10.
Figure 8-10. Mounted error
Whenever our users load data over a slow network, these errors can
occur. But we can protect ourselves. First, we can create a hook that
will tell us whether or not the current component is mounted:
export function useMountedRef() {
const mounted = useRef(false);
useEffect(() => {
mounted.current = true;
return () => (mounted.current = false);
});
return mounted;
}
The useMountedRef hook uses a ref. When the component unmounts,
state is wiped clean, but refs are still available. The above useEffect
doesn’t have a dependency array; it’s invoked every time a component
renders and ensures that the value for the ref is true. Whenever the
component unmounts, the function returned from useEffect is
invoked, which changes the value of the ref to false.
Now we can use this hook inside of the RepoReadme component. This
will allow us to make sure the component is mounted before applying
any state updates:
const mounted = useMountedRef();
const loadReadme = useCallback(async (login, repo) => {
setLoading(true);
const uri = `https://api.github.com/repos/${login}/${repo}/readme`;
const { download_url } = await fetch(uri).then(res =>
res.json()
);
const markdown = await fetch(download_url).then(res =>
res.text()
);
if (mounted.current) {
setMarkdown(markdown);
setLoading(false);
}
}, []);
Now we have a ref that tells us whether or not the component is
mounted. It will take time for both of these requests to finish. When
they do, we check to make sure the component is still mounted before
calling setMarkdown or setLoading.
Let’s add the same logic to our useFetch hook:
const mounted = useMountedRef();
useEffect(() => {
if (!uri) return;
if (!mounted.current) return;
setLoading(true);
fetch(uri)
.then(data => {
if (!mounted.current) throw new Error("component is not mounted");
return data;
})
.then(data => data.json())
.then(setData)
.then(() => setLoading(false))
.catch(error => {
if (!mounted.current) return;
setError(error);
});
The useFetch hook is used to make the rest of the fetch requests in our
app. In this hook, we compose the fetch request using thenables,
chainable .then() functions, instead of async/await. When the fetch
is complete, we check to see if the component is mounted in the first
.then callback. If the component is mounted, the data is returned and
the rest of the .then functions are invoked. When the component is not
mounted, the first .then function throws an error, preventing the rest
of the .then functions from executing. Instead, the .catch function is
invoked and the new error is passed to that function. The .catch
function will check to see if the component is mounted before it tries to
invoke setError.
We’ve successfully canceled our requests. We didn’t stop the HTTP
request itself from occurring, but we did protect the state calls we make
after the request is resolved. It’s always a good idea to test your app
under slow network conditions. These bugs will be revealed and
eliminated.
Introducing GraphQL
Just like React, GraphQL was designed at Facebook. And, just like
React is a declarative solution for composing user interfaces, GraphQL
is a declarative solution for communicating with APIs. When we make
parallel data requests, we’re attempting to get all the data we need
immediately at the same time. GraphQL was designed to do just that.
In order to get data from a GraphQL API, we still need to make an
HTTP request to a specific URI. However, we also need to send a
query along with the request. A GraphQL query is a declarative
description of the data we’re requesting. The service will parse this
description and will package all the data we’re asking for into a single
response.
GitHub GraphQL API
In order to use GraphQL in your React application, the backend service
you’re communicating with needs to be built following GraphQL
specifications. Fortunately, GitHub also exposes a GraphQL API. Most
GraphQL services provide a way to explore the GraphQL API. At
GitHub, this is called the GraphQL Explorer. In order to use the
Explorer, you must sign in with your GitHub account.
The left panel of the Explorer is where we draft our GraphQL query.
Inside of this panel, we could add a query to obtain information about a
single GitHub user:
query {
user(login: "moontahoe") {
id
login
name
location
avatarUrl
}
}
This is a GraphQL query. We’re asking for information about the
GitHub user “moontahoe.” Instead of getting all of the public
information available about moontahoe, we only get the data we want:
id, login, avatarUrl, name, and location. When we press the Play
button on this page, we send this query as an HTTP POST request to
https://api.github.com/graphql. All GitHub GraphQL queries are sent
to this URI. GitHub will parse this query and return only the data we
asked for:
{
"data": {
"user": {
"id": "MDQ6VXNlcjU5NTIwODI=",
"login": "MoonTahoe",
"name": "Alex Banks",
"location": "Tahoe City, CA",
"avatarUrl": "https://github.com/moontahoe.png"
}
}
}
We can formalize this GraphQL query into a reusable operation named
findRepos. Every time we want to find information about a user and
their repositories, we could do so by sending a login variable to this
query:
query findRepos($login: String!) {
user(login: $login) {
login
name
location
avatar_url: avatarUrl
repositories(first: 100) {
totalCount
nodes {
name
}
}
}
}
Now we’ve created a formal findRepos query that we can reuse
simply by chaining the value of the $login variable. We set this
variable using the Query Variables panel shown in Figure 8-11.
Figure 8-11. GitHub GraphQL Explorer
In addition to obtaining details about a user, we’re also asking for that
user’s first hundred repositories. We’re asking for the number of
repositories returned by the query, the totalCount, along with the
name of each repository. GraphQL only returns the data we ask for. In
this case, we’ll only get the name for each repository, nothing else.
There’s one more change that we made to this query: we used an alias
for the avatarUrl. The GraphQL field to obtain a user’s avatar is
called avatarUrl, but we want that variable to be named avatar_url.
The alias tells GitHub to rename that field in the data response.
GraphQL is a huge topic. We wrote a whole book about it: Learning
GraphQL. We’re only scratching the surface here, but GraphQL is
increasingly becoming more of a requirement for any developer. In
order to be a successful developer in the 21st century, it’s important to
understand the fundamentals of GraphQL.
Making a GraphQL Request
A GraphQL request is an HTTP request that contains a query in the
body of the request. You can use fetch to make a GraphQL request.
There are also a number of libraries and frameworks that can handle
the details of making these types of requests for you. In this next
section, we’ll see how we can hydrate our applications with GraphQL
data using a library called graphql-request.
NOTE
GraphQL is not restricted to HTTP. It’s a specification of how data requests
should be made over a network. It can technically work with any network
protocol. Additionally, GraphQL is language-agnostic.
First, let’s install graphql-request:
npm i graphql-request
GitHub’s GraphQL API requires identification to send requests from
client applications. In order to complete this next sample, you must
obtain a personal access token from GitHub, and this token must be
sent with every request.
To obtain a personal access token for GraphQL requests, navigate to
Settings > Developer Settings > Personal Access Tokens. On this form,
you can create an access token that has specific rights. The token must
have the following read access in order to make GraphQL requests:
user
public_repo
repo
repo_deployment
repo:status
read:repo_hook
read:org
read:public_key
read:gpg_key
We can use graphql-request to make GraphQL requests from
JavaScript:
import { GraphQLClient } from "graphql-request";
const query = `
query findRepos($login:String!) {
user(login:$login) {
login
name
location
avatar_url: avatarUrl
repositories(first:100) {
totalCount
nodes {
name
}
}
}
}
`;
const client = new GraphQLClient(
"https://api.github.com/graphql",
{
headers: {
Authorization: `Bearer <PERSONAL_ACCESS_TOKEN>`
}
}
);
client
.request(query, { login: "moontahoe" })
.then(results => JSON.stringify(results, null, 2))
.then(console.log)
.catch(console.error);
We send this request using the GraphQLClient constructor from
graphql-request. When we create the client, we use the URI for
GitHub’s GraphQL API: https://api.github.com/graphql. We also send
some additional headers that contain our personal access token. This
token identifies us and is required by GitHub when using their
GraphQL API. We can now use the client to make our GraphQL
requests.
In order to make a GraphQL request, we’ll need a query. The query is
simply a string that contains the GraphQL query from above. We send
the query to the request function along with any variables that the
query may require. In this case, the query requires a variable named
$login, so we send an object that contains a value for $login in the
login field.
Here, we’re simply converting the resulting JSON to a string and
logging it to the console:
{
"user": {
"id": "MDQ6VXNlcjU5NTIwODI=",
"login": "MoonTahoe",
"name": "Alex Banks",
"location": "Tahoe City, CA",
"avatar_url": "https://avatars0.githubusercontent.com/u/5952082?v=4",
"repositories": {
"totalCount": 52,
"nodes": [
{
"name": "snowtooth"
},
{
"name": "Memory"
},
{
"name": "snowtooth-status"
},
...
]
}
}
}
Just like fetch, client.request returns a promise. Getting this data
inside of your React component will feel very similar to fetching data
from a route:
export default function App() {
const [login, setLogin] = useState("moontahoe");
const [userData, setUserData] = useState();
useEffect(() => {
client
.request(query, { login })
.then(({ user }) => user)
.then(setUserData)
.catch(console.error);
}, [client, query, login]);
if (!userData) return <p>loading...</p>;
return (
<>
<SearchForm value={login} onSearch={setLogin} />
<UserDetails {...userData} />
<p>{userData.repositories.totalCount} - repos</p>
<List
data={userData.repositories.nodes}
renderItem={repo => <span>{repo.name}</span>}
/>
</>
);
}
We make the client.request inside of a useEffect hook. If the
client, query, or login changes, the useEffect hook will make
another request. Then we’ll render the resulting JSON with React, as
shown in Figure 8-12.
Figure 8-12. GraphQL app
This example doesn’t put care into handling loading and error states,
but we can apply everything we learned in the rest of this chapter to
GraphQL. React doesn’t really care how we get the data. As long as we
understand how to work with asynchronous objects like promises
within our components, we’ll be ready for anything.
Loading data from the internet is an asynchronous task. When we
request data, it takes some time for it to be delivered, and stuff can go
wrong. Handling the pending, success, and fail states of a promise
within a React component is an orchestration of stateful hooks with the
useEffect hook.
We spent much of this chapter covering promises, fetch, and HTTP.
This is because HTTP is still the most popular way to request data from
the internet, and promises fit nicely with HTTP requests. Sometimes,
you may work with a different protocol like WebSockets. No worries:
this is accomplished by working with stateful hooks and useEffect.
Here’s a brief example of how we can incorporate socket.io into a
custom useChatRoom hook:
const reducer = (messages, incomingMessage) => [
messages,
...incomingMessage
];
export function useChatRoom(socket, messages = []) {
const [status, setStatus] = useState(null);
const [messages, appendMessage] = useReducer(
reducer,
messages
);
const send = message => socket.emit("message", message);
useEffect(() => {
socket.on("connection", () => setStatus("connected"));
socket.on("disconnecting", () =>
setStatus("disconnected")
);
socket.on("message", setStatus);
return () => {
socket.removeAllListeners("connect");
socket.removeAllListeners("disconnect");
socket.removeAllListeners("message");
};
}, []);
return {
status,
messages,
send
};
}
This hook provides an array of chat messages, the websocket
connection status, and a function that can be used to broadcast new
messages to the socket. All of these values are affected by listeners that
are defined in the useEffect hook. When the socket raises
connection or disconnecting events, the value for status changes.
When new messages are received, they’re appended to the array of
messages via the useReducer hook.
In this chapter, we’ve discussed some techniques for handling
asynchronous data in applications. This is a hugely important topic,
and in the next chapter, we’ll show how Suspense might lead to future
changes in this area.
Chapter 9. Suspense
This is the least important chapter in this book. At least, that’s what
we’ve been told by the React team. They didn’t specifically say, “this
is the least important chapter, don’t write it.” They’ve only issued a
series of tweets warning educators and evangelists that much of their
work in this area will very soon be outdated. All of this will change.
It could be said that the work the React team has done with Fiber,
Suspense, and concurrent mode represents the future of web
development. This work may change the way browsers interpret
JavaScript. That sounds pretty important. We’re saying that this is the
least important chapter in this book because the community hype for
Suspense is high; we need to say it to balance out your expectations.
The APIs and patterns that make up Suspense are not the single
overarching theory that defines how all things large and small should
operate.
Suspense is a just a feature. You may not ever need to use it. It’s being
designed to solve specific problems that Facebook experiences
working at scale. We don’t all have the same problems as Facebook, so
we may want to think twice before reaching for those tools as the
solution to all our problems. They may unnecessarily introduce
complexity where complexity is not needed. Plus, this is all going to
change. Concurrent mode is an experimental feature, and the React
team has issued stern warnings about trying to use it in production. In
fact, most of these concepts involve using hooks. If you don’t see
yourself developing custom hooks on a daily basis, you’ll probably
never need to know about these features. Much of the mechanics
involving Suspense can be abstracted away in hooks.
In light of these three paragraphs of downplay, the concepts covered in
this chapter are exciting. If used correctly, they could someday help us
create better user experiences. If you own or maintain a React library
of hooks and/or components, you may find these concepts valuable.
They’ll help you fine-tune your custom hooks to allow for better
feedback and prioritization.
In this chapter, we’ll build another small app to demonstrate some of
these features. We’ll essentially rebuild the app from Chapter 8, but
this time with a little more structure. For example, we’ll be using a
SiteLayout component:
export default function SiteLayout({
children,
menu = c => null
}) {
return (
<div className="site-container">
<div>{menu}</div>
<div>{children}</div>
</div>
);
}
SiteLayout will rendered within the App component to help us
compose our UI:
export default function App() {
return (
<SiteLayout menu={<p>Menu</p>}>
<>
<Callout>Callout</Callout>
<h1>Contents</h1>
<p>This is the main part of the example layout</p>
</>
</SiteLayout>
);
}
This component will be used to give our layout some style, as shown in
Figure 9-1.
Specifically, it will allow us to clearly see where and when specific
components are rendered.
Figure 9-1. Sample layout
Error Boundaries
Thus far, we haven’t done the best job with handling errors. An error
thrown anywhere in our component tree will take down the entire
application. Larger component trees only further complicate our project
and complicate debugging it. Sometimes, it can be hard to pinpoint
where an error has occurred, especially when they occur within
components that we didn’t write.
Error boundaries are components that can be used to prevent errors
from crashing the entire app. They also allow us to render sensible
error messages in production. Because errors can be handled by a
single component, they could potentially track errors within the
application and report them to an issue management system.
Currently, the only way to make an error boundary component is to use
a class component. Like most topics in this chapter, this too will
eventually change. In the future, creating error boundaries could be
possible with a hook or some other solution that doesn’t require
creating a class. For now, here’s an example of an ErrorBoundary
component:
import React, { Component } from "react";
export default class ErrorBoundary extends Component {
state = { error: null };
static getDerivedStateFromError(error) {
return { error };
}
render() {
const { error } = this.state;
const { children, fallback } = this.props;
if (error) return <fallback error={error} />;
return children;
}
}
This is a class component. It stores state differently, and it doesn’t use
hooks. Instead, it has access to specific methods that are invoked
during different times throughout the component life cycle.
getDerivedStateFromError is one of those methods. It is invoked
when an error occurs anywhere within the children during the render
process. When an error occurs, the value for state.error is set.
Where there’s an error, the fallback component is rendered, and that
error is passed to the component as a property.
Now we can use this component in our tree to capture errors and render
a fallback component if they occur. For example, we could wrap our
entire application with an error boundary:
function ErrorScreen({ error }) {
//
// Here you can handle or track the error before rendering the message
//
return (
<div className="error">
<h3>We are sorry... something went wrong</h3>
<p>We cannot process your request at this moment.</p>
<p>ERROR: {error.message}</p>
</div>
);
}
<ErrorBoundary fallback={ErrorScreen}>
<App />
</ErrorBoundary>;
The ErrorScreen provides a gentle message for our users that an error
has occurred. It renders some details about the error. It also gives us a
place to potentially track errors that occur anywhere within our app. If
an error does occur within the app, this component will be rendered
instead of a black screen. We can make this component look nice with
a little CSS:
.error {
background-color: #efacac;
border: double 4px darkred;
color: darkred;
padding: 1em;
}
To test this out we’re going to create a component we can use to
intentionally cause errors. BreakThings always throws an error:
const BreakThings = () => {
throw new Error("We intentionally broke something");
};
Error boundaries can be composed. Sure, we wrapped the App
component in an ErrorBoundary, but we can also wrap individual
components within the App with Error:
return (
<SiteLayout
menu={
<ErrorBoundary fallback={ErrorScreen}>
<p>Site Layout Menu</p>
<BreakThings />
</ErrorBoundary>
}
>
<ErrorBoundary fallback={ErrorScreen}>
<Callout>Callout<BreakThings /></Callout>
</ErrorBoundary>
<ErrorBoundary fallback={ErrorScreen}>
<h1>Contents</h1>
<p>this is the main part of the example layout</p>
</ErrorBoundary>
</SiteLayout>
Each ErrorBoundary will render a fallback if an error occurs
anywhere within their children. In this case, we used the BreakThings
component in the menu and within the Callout. This would result in
rendering the ErrorScreen twice, as we can see in Figure 9-2.
We can see that the ErrorBoundaries are rendered in place. Notice
that the two errors that have occurred have been contained to their
regions. The boundaries are like walls that prevent these errors from
attacking the rest of the application. Despite intentionally throwing two
errors, the contents are still rendered without issue.
Figure 9-2. ErrorBoundaries
In Figure 9-3, we can observe what happens when we move the
BreakThings component to only the contents.
Figure 9-3. Error
Now we see the menu and the callout being rendered without issue, but
the contents has rendered an error to notify the user that an error has
occurred.
Inside of the render method in the ErrorBoundary class component,
we can make the fallback property optional. When it’s not included,
we’ll simply use our ErrorScreen component:
render() {
const { error } = this.state;
const { children } = this.props;
if (error && !fallback) return <ErrorScreen error={error} />;
if (error) return <fallback error={error} />;
return children;
}
This is a good solution for handling errors consistently across an
application. Now, we just have to wrap specific parts of our component
tree with an ErrorBoundary and let the component handle the rest:
<ErrorBoundary>
<h1>&lt;Contents /&gt;</h1>
<p>this is the main part of the example layout</p>
<BreakThings />
</ErrorBoundary>
Error boundaries are not only a good idea—they’re essential for
retaining users in production, and they’ll prevent some small bug in a
relatively unimportant component from bringing down the entire
application.
Code Splitting
If the applications you’re working on are small now, chances are they
won’t stay that way. A lot of the applications you work on will
eventually contain massive codebases with hundreds, maybe even
thousands, of components. Most of your users could be accessing your
applications via their phones on potentially slow networks. They can’t
wait for the entire codebase of your application to successfully
download before React completes its first render.
Code splitting provides us with a way to split our codebase into
manageable chunks and then load those chunks as they’re needed. To
exemplify the power of code splitting, we’ll add a user agreement
screen to our application:
export default function Agreement({ onAgree = f => f }) {
return (
<div>
<p>Terms...</p>
<p>These are the terms and stuff. Do you agree?</p>
<button onClick={onAgree}>I agree</button>
</div>
);
}
Next, we’ll move the rest of our codebase from a component called App
to a component called Main, and we’ll place that component in its own
file:
import React from "react";
import ErrorBoundary from "./ErrorBoundary";
const SiteLayout = ({ children, menu = c => null }) => {
return (
<div className="site-container">
<div>{menu}</div>
<div>{children}</div>
</div>
);
};
const Menu = () => (
<ErrorBoundary>
<p style={{ color: "white" }}>TODO: Build Menu</p>
</ErrorBoundary>
);
const Callout = ({ children }) => (
<ErrorBoundary>
<div className="callout">{children}</div>
</ErrorBoundary>
);
export default function Main() {
return (
<SiteLayout menu={<Menu />}>
<Callout>Welcome to the site</Callout>
<ErrorBoundary>
<h1>TODO: Home Page</h1>
<p>Complete the main contents for this home page</p>
</ErrorBoundary>
</SiteLayout>
);
}
So Main is where the current site layout is rendered. Now we’ll modify
the App component to render the Agreement until the user agrees to it.
When they agree, we’ll unmount the Agreement component and render
the Main website component:
import React, { useState } from "react";
import Agreement from "./Agreement";
import Main from "./Main";
import "./SiteLayout.css";
export default function App() {
const [agree, setAgree] = useState(false);
if (!agree)
return <Agreement onAgree={() => setAgree(true)} />;
return <Main />;
}
Initially, the only component that’s rendered is the Agreement
component. Once the user agrees, the value for agree changes to true,
and the Main component is rendered. The issue is that all code for the
Main component and all of its children is packaged into a single
JavaScript file: the bundle. That means that users have to wait for this
codebase to download completely before the Agreement component is
initially rendered.
We can put off loading the main component until it has rendered by
declaring it using React.lazy instead of initially importing it:
const Main = React.lazy(() => import("./Main"));
We’re telling React to wait to load the codebase for the Main
component until it’s initially rendered. When it is rendered, it will be
imported at that time using the import function.
Importing code during runtime is just like loading anything else from
the internet. First, the request for the JavaScript code is pending. Then
it’s either successful, and a JavaScript file is returned, or it fails,
causing an error to occur. Just like we need to notify a user that we’re
in the process of loading data, we’ll need to let the user know that
we’re in the process of loading code.
Introducing: The Suspense Component
Once again, we find ourselves in a situation where we’re managing an
asynchronous request. This time, we have the Suspense component to
help us out. The Suspense component works much like the
ErrorBoundary component. We wrap it around specific components in
our tree. Instead of falling back to an error message when an error
occurs, the Suspense component renders a loading message when lazy
loading occurs.
We can modify the app to lazy load the Main component with the
following code:
import React, { useState, Suspense, lazy } from "react";
import Agreement from "./Agreement";
import ClimbingBoxLoader from "react-spinners/ClimbingBoxLoader";
const Main = lazy(() => import("./Main"));
export default function App() {
const [agree, setAgree] = useState(false);
if (!agree)
return <Agreement onAgree={() => setAgree(true)} />;
return (
<Suspense fallback={<ClimbingBoxLoader />}>
<Main />
</Suspense>
);
}
Now the app initially only loads the codebase for React, the
Agreement component, and the ClimbingBoxLoader. React will hold
off on loading the Main component until the user agrees to the
agreement.
The Main component has been wrapped in a Suspense component. As
soon as the user agrees to the agreement, we start loading the codebase
for the Main component. Because the request for this codebase is
pending, the Suspense component will render the
ClimbingBoxLoader in its place until the codebase has successfully
loaded. Once that happens, the Suspense component will unmount the
ClimbingBoxLoader and render the Main component.
NOTE
React Spinners is a library of animated loading spinners that indicate that
something is loading or that the app is working. For the remainder of this chapter,
we’ll be sampling different loader components from this library. Make sure you
install this library: npm i react-spinners.
What happens when the internet connection goes down before trying to
load the Main component? Well, we’ll have an error on our hands. We
can handle that by wrapping our Suspense component within an
ErrorBoundary:
<ErrorBoundary fallback={ErrorScreen}>
<Suspense fallback={<ClimbingBoxLoader />}>
<Main />
</Suspense>
</ErrorBoundary>
The composition of these three components gives us a way to handle
most asynchronous requests. We have a solution for pending: the
Suspense component will render a loader animation while the request
for the source code is pending. We have a solution for the failed state:
if an error occurs while loading the Main component, it will be caught
and handled by the ErrorBoundary. We even have a solution for
success: if the request is successful, we’ll render the Main component.
Using Suspense with Data
In the last chapter, we built a useFetch hook and a Fetch component
to help us handle the three states involved with making a GitHub
request: pending, success, and fail. That was our solution. We think it
was pretty cool. However, in the last section, we handled these three
states by elegantly composing the ErrorBoundary and Suspense
components. That was for lazy loading JavaScript source code, but we
can use the same pattern to help us load data.
Let’s say we have a Status component that’s capable of rendering
some sort of status message:
import React from "react";
const loadStatus = () => "success - ready";
function Status() {
const status = loadStatus();
return <h1>status: {status}</h1>;
}
This component invokes the loadStatus function to retrieve the
current status message. We can render the Status component in our
App component:
export default function App() {
return (
<ErrorBoundary>
<Status />
</ErrorBoundary>
);
}
If we were to run this code as-is, we would see our successful status
message, as shown in Figure 9-4.
Figure 9-4. Success: everything works
When we rendered the Status component within the App component,
we were good React developers because we wrapped the Status
component inside of an error boundary. Now if something goes wrong
while loading the status, the ErrorBoundary will fall back to the
default error screen. To demonstrate this, let’s cause an error inside of
the loadStatus function:
const loadStatus = () => {
throw new Error("something went wrong");
};
Now when we run our application, we see the expected output. The
ErrorBoundary caught our error and rendered a message to the user
instead (Figure 9-5).
Figure 9-5. Fail: error boundary triggered
So far, everything is working as suspected. We’ve composed the
Status component inside of an ErrorBoundary, and the combination
of these two components is handling two of the three promise states:
success or rejected. “Rejected” is the official promise term for a failed
or error state.
We have two of the three states covered. What about the third state?
Pending? That state can be triggered by throwing a promise:
const loadStatus = () => {
throw new Promise(resolves => null);
};
If we throw a promise from the loadStatus function, we’ll see a
special type of error in the browser (Figure 9-6).
This error is telling us that a pending state was triggered, but there is no
Suspense component configured somewhere higher in the tree.
Whenever we throw a promise from a React app, we need a Suspense
component to handle rendering a fallback:
export default function App() {
return (
<Suspense fallback={<GridLoader />}>
<ErrorBoundary>
<Status />
</ErrorBoundary>
</Suspense>
);
}
Figure 9-6. Throw promise
Now we have the right component composition to handle all three
states. The loadStatus function is still throwing a promise, but there’s
now a Suspense component configured somewhere higher in the tree
to handle it. When we throw the promise, we’re telling React that we’re
waiting on a pending promise. React responds by rendering the
fallback GridLoader component (Figure 9-7).
Figure 9-7. GridLoader
When loadStatus successfully returns a result, we’ll render the
Status component as planned. If something goes wrong (if
loadStatus throws an error), we have it covered with an
ErrorBoundary. When loadStatus throws a promise, we trigger the
pending state, which is handled by the Suspense component.
This is a pretty cool pattern, but wait…what do you mean, “throw a
promise”?
Throwing Promises
In JavaScript, the throw keyword is technically for errors. You’ve
probably used it many times in your own code:
throw new Error("inspecting errors");
This line of code causes an error. When this error goes unhandled, it
crashes the whole app, as demonstrated in Figure 9-8.
Figure 9-8. Throwing an error
The error screen you see rendered in the browser is a developmentmode feature of Create React App. Whenever you’re in development
mode, unhandled errors are caught and displayed directly on the
screen. If you close this screen by clicking on the “X” in the upper
right-hand corner, you’ll see what your production users see when
there’s an error: nothing, a blank, white screen.
Unhandled errors are always visible in the console. All the red text we
see in the console is information about the error we’ve thrown.
JavaScript is a pretty free-loving language. It lets us get away with a lot
of stuff that we can’t get away with when using traditional typed
languages. For example, in JavaScript, we can throw any type:
throw "inspecting errors";
Here, we’ve thrown a string. The browser will tell us that something
has gone uncaught, but it’s not an error (Figure 9-9).
Figure 9-9. GridLoader
This time, when we threw a string, the Create React App error screen
wasn’t rendered inside the browser. React knows the difference
between an error and a string.
JavaScript lets us throw any type, which means we can throw a
promise:
throw new Promise(resolves => null);
Now the browser is telling us that something has gone uncaught. It’s
not an error, it’s a promise, as shown in Figure 9-10.
Figure 9-10. Throwing a promise
To throw a promise within the React component tree, we’ll do so first
in a loadStatus function:
const loadStatus = () => {
console.log("load status");
throw new Promise(resolves => setTimeout(resolves, 3000));
};
If we use this loadStatus function inside a React component, a
promise is thrown, then somewhere farther up the tree is caught by the
Suspense component. That’s right: JavaScript allows us to throw any
type, which also means that we can catch any type.
Consider the following example:
safe(loadStatus);
function safe(fn) {
try {
fn();
} catch (error) {
if (error instanceof Promise) {
error.then(() => safe(fn));
} else {
throw error;
}
}
}
We’re sending the loadStatus function a safe function, which makes
safe a higher-order function. loadStatus becomes fn within the
scope of the safe function. The safe function tries to invoke the fn
that’s passed as the argument. In this case, safe tries to invoke
loadStatus. When it does, loadStatus throws a promise, an
intentional delay of three seconds. That promise is immediately caught
and becomes error within the scope of the catch block. We can check
to see if the error is a promise, and in this case, it is. Now we can wait
for that promise to resolve and then attempt to call safe again with the
same loadStatus function.
What do we expect to happen when we invoke the safe function
recursively with a function that creates a promise that causes a threesecond delay? We get a delayed loop, as shown in Figure 9-11.
Figure 9-11. An unfortunate loop
The safe function is invoked, the promise is caught, we wait three
seconds for the promise to resolve, then we call safe again with the
same function, and the cycle starts all over again. Every three seconds,
the string “load status” is printed to the console. How many times you
watch that happen depends upon how patient you are.
We didn’t make this endless recursive loop to test your patience; we
made it to demonstrate a point. Watch what happens when we use this
new loadStatus function in conjunction with our Status component
from earlier:
const loadStatus = () => {
console.log("load status");
throw new Promise(resolves => setTimeout(resolves, 3000));
};
function Status() {
const status = loadStatus();
return <h1>status: {status}</h1>;
}
export default function App() {
return (
<Suspense fallback={<GridLoader />}>
<ErrorBoundary>
<Status />
</ErrorBoundary>
</Suspense>
);
}
Because loadStatus is throwing a promise, the GridLoader
animation renders on the screen. When you take a look at the console,
the results are once again testing your patience (Figure 9-12).
Figure 9-12. Suspense recursion
We see the same pattern as we did with the safe function. The
Suspense component knows that a promise was thrown. It will render
the fallback component. Then the Suspense component waits for the
thrown promise to be resolved, just like the safe function did. Once
resolved, the Suspense component rerenders the Status component.
When Status renders again, it calls loadStatus and the whole
process repeats itself. We see “load status” printed to the console,
every three seconds, endlessly, forever.
An endless loop is typically not the desired output. It isn’t for React,
either. It’s important to know that, when we throw a promise, it’s
caught by the Suspense component, and we enter into a pending state
until the promise has been resolved.
Building Suspenseful Data Sources
A Suspenseful data source needs to provide a function that handles all
the states associated with loading data: pending, success, and error. The
loadStatus function can only return or throw one type at a time. We
need the loadStatus function to throw a promise when the data is
loading, return a response when the data is successful, or throw an
error if something goes wrong:
function loadStatus() {
if (error) throw error;
if (response) return response;
throw promise;
}
We’ll need a place to declare error, response, and promise. We also
need to make sure that these variables are scoped appropriately and do
not collide with other requests. The solution is to define loadStatus
using a closure:
const loadStatus = (function() {
let error, promise, response;
return function() {
if (error) throw error;
if (response) return response;
throw promise;
};
})();
This is a closure. The scope of the error, promise, and response are
closed off from any code outside of the function where they’re defined.
When we declare loadStatus, an anonymous function is declared and
immediately invoked: fn() is the same as (fn)(). The value of
loadStatus becomes the inner function that’s returned. The
loadStatus function now has access to error, promise, and
response, but the rest of our JavaScript world does not.
Now all we need to do is handle the values for error, response, and
promise. The promise will be pending for three seconds before it’s
successfully resolved. When the promise resolves, the value for
response will be set to “success.” We’ll catch any errors or promise
rejections and use them to set the error value:
const loadStatus = (function() {
let error, response;
const promise = new Promise(resolves =>
setTimeout(resolves, 3000)
)
.then(() => (response = "success"))
.catch(e => (error = e));
return function() {
if (error) throw error;
if (response) return response;
throw pending;
};
})();
We created a promise that’s pending for three seconds. If the
loadStatus function is invoked at any point during that time, the
promise itself will be thrown. After the three seconds, the promise is
successfully resolved and response is assigned a value. If you invoke
loadStatus now, it will return the response: “success.” If something
went wrong, then the loadStatus function would return the error.
The loadStatus function is our Suspenseful data source. It is capable
of communicating its state with the Suspense architecture. The inner
workings of loadStatus are hardcoded. It always resolves the same
three-second delay promise. However, the mechanics of handling
error, response, and promise are repeatable. We can wrap any
promise with this technique to produce suspenseful data sources.
All we need to create a Suspenseful data source is a promise, so we can
create a function that takes a promise as an argument and returns a
Suspenseful data source. In this example, we call that function
createResource:
const resource = createResource(promise);
const result = resource.read();
This code assumes that createResource(promise) will successfully
create a resource object. This object has a read function, and we can
invoke read as many times as we like. When the promise is resolved,
read will return the resulting data. When the promise is pending, read
will throw the promise. And if anything goes wrong, read will throw
an error. This data source is ready to work with Suspense.
The createResource function looks a lot like our anonymous function
from before:
function createResource(pending) {
let error, response;
pending.then(r => (response = r)).catch(e => (error = e));
return {
read() {
if (error) throw error;
if (response) return response;
throw pending;
}
};
}
This function still closes off the values for error and response, but it
allows consumers to pass in a promise as an argument called pending.
When the pending promise is resolved, we capture the results with a
.then function. If the promise is rejected, we’ll catch the error and use
it to assign a value to the error variable.
The createResource function returns a resource object. This object
contains a function called read. If the promise is still pending, then
error and response will be undefined. So read throws the promise.
Invoking read when there’s a value for error will cause that error to
be thrown. Finally, invoking read when there’s a response will yield
whatever data was resolved by the promise. It doesn’t matter how
many times we call read—it will always accurately report on the state
of our promise.
In order to test it out in a component, we’ll need a promise, ideally one
that sounds like the name of an ’80s ski movie:
const threeSecondsToGnar = new Promise(resolves =>
setTimeout(() => resolves({ gnar: "gnarly!" }), 3000)
);
The threeSecondsToGnar promise waits three seconds before
resolving to an object that has a field and value for gnar. Let’s use this
promise to create a Suspenseful data resource and use that data
resource in a small React application:
const resource = createResource(threeSecondsToGnar);
function Gnar() {
const result = resource.read();
return <h1>Gnar: {result.gnar}</h1>;
}
export default function App() {
return (
<Suspense fallback={<GridLoader />}>
<ErrorBoundary>
<Gnar />
</ErrorBoundary>
</Suspense>
);
}
React components can render a lot. The Gnar component will be
rendered several times before it actually returns a response. Each time
Gnar is rendered, resource.read() is invoked. The first time Gnar is
rendered, a promise is thrown. That promise is handled by the
Suspense component and a fallback component will be rendered.
When the promise has resolved, the Suspense component will attempt
to render Gnar again. Gnar will invoke resource.read() again, but
this time, assuming everything went OK, resource.read() will
successfully return Gnar, which is used to render the state of Gnar in an
h1 element. If something went wrong, resource.read() would have
thrown an error, which would be handed by the ErrorBoundary.
As you can imagine, the createResource function can become quite
robust. Our resource can attempt to handle errors. Maybe when there’s
a network error, the resource can wait a few seconds and automatically
attempt to load the data again. Our resource could communicate with
other resources. Maybe we can log the performance statistics behind all
of our resources. The sky’s the limit. As long as we have a function
that we can use to read the current state of that resource, we can do
whatever we like with the resource itself.
At present, this is how Suspense works. This is how we can use the
Suspense component with any type of asynchronous resource. This
could all change, and we expect it to change. However, whatever the
finalized API for Suspense ends up being, it will be sure to handle
three states: pending, success, and fail.
The look at these Suspense APIs has been kind of high-level, and this
was intentional because this stuff is experimental. It’s going to change.
What’s important to take away from this chapter is that React is always
tinkering with ways to make React apps faster.
Behind the scenes of a lot of this work is the way that React itself
works—specifically, its reconciliation algorithm called Fiber.
Fiber
Throughout this book, we’ve talked about React components as being
functions that return data as a UI. Every time this data changes (props,
state, remote data, etc), we rely on React to rerender the component. If
we click a star to rate a color, we assume that our UI will change, and
we assume that it’ll happen fast. We assume this because we trust
React to make it happen. How exactly does this work though? To
understand how React efficiently updates the DOM, let’s take a closer
look at how React works.
Consider that you’re writing an article for your company blog. You
want feedback, so you send the article to your coworker before you
publish. They recommend a few quick changes, and now you need to
incorporate those changes. You create a brand-new document, type out
the entire article from scratch, and then add in the edits.
You’re probably groaning at this unnecessary extra effort, but this is
how a lot of libraries previously worked. To make an update, we’d get
rid of everything, then start from scratch and rebuild the DOM during
the update.
Now, you’re writing another blog post and you send it to your
coworker again. This time, you’ve modernized your article-writing
process to use GitHub. Your coworker checks out a GitHub branch,
makes the changes, and merges in the branch when they’re finished.
Faster and more efficient.
This process is similar to how React works. When a change occurs,
React makes a copy of the component tree as a JavaScript object. It
looks for the parts of the tree that need to change and changes only
those parts. Once complete, the copy of the tree (known as the work-inprogress tree) replaces the existing tree. It’s important to reiterate that it
uses the parts of the tree that are already there. For example, if we had
to update an item in the list from red to green:
<ul>
<li>blue</li>
<li>purple</li>
<li>red</li>
</ul>
React would not get rid of the third li. Instead it would replace its
children (red text) with green text. This is an efficient approach to
updating and is the way that React has updated the DOM since its
inception. There is a potential problem here, though. Updating the
DOM is an expensive task because it’s synchronous. We have to wait
for all of the updates to be reconciled and then rendered before we can
do other tasks on the main thread. In other words, we’d have to wait for
React to recursively move through all of the updates, which could
make the user experience seem unresponsive.
The React team’s solution to this was a full rewrite of React’s
reconciliation algorithm, called Fiber. Fiber, released in version 16.0,
rewrote the way that DOM updates worked by taking a more
asynchronous approach. The first change with 16.0 was the separation
of the renderer and the reconciler. A renderer is the part of the library
that handles rendering, and the reconciler is the part of the library that
manages updates when they occur.
Separating the renderer from the reconciler was a big deal. The
reconciliation algorithm was kept in React Core (the package you
install to use React), and each rendering target was made responsible
for rendering. In other words, ReactDOM, React Native, React 360,
and more would be responsible for the logic of rendering and could be
plugged into React’s core reconciliation algorithm.
Another huge shift with React Fiber was its changes to the
reconciliation algorithm. Remember our expensive DOM updates that
blocked the main thread? This lengthy block of updates is called work
—with Fiber, React split the work into smaller units of work called
fibers. A fiber is a JavaScript object that keeps track of what it’s
reconciling and where it is in the updating cycle.
Once a fiber (unit of work) is complete, React checks in with the main
thread to make sure there’s not anything important to do. If there is
important work to do, React will give control to the main thread. When
it’s done with that important work, React will continue its update. If
there’s nothing critical to jump to on the main thread, React moves on
to the next unit of work and renders those changes to the DOM.
To use the GitHub example from earlier, each fiber represents a
commit on a branch, and when we check the branch back into the main
branch, that represents the updated DOM tree. By breaking up the work
of an update into chunks, Fiber allows priority tasks to jump the line
for immediate handling by the main thread. The result is a user
experience that feels more responsive.
If this was all Fiber did, it would be a success, but there’s even more to
it than that! In addition to the performance benefits of breaking work
into smaller units, the rewrite also sets up exciting possibilities for the
future. Fiber provides the infrastructure for prioritizing updates. In the
longer term, the developer may even be able to tweak the defaults and
decide which types of tasks should be given the highest priority. The
process of prioritizing units of work is called scheduling; this concept
underlies the experimental concurrent mode, which will eventually
allow these units of work to be performed in parallel.
An understanding of Fiber is not vital to working with React in
production, but the rewrite of its reconciliation algorithm provides
interesting insight into how React works and how its contributors are
thinking about the future.
Chapter 10. React Testing
In order to keep up with our competitors, we must move quickly while
ensuring quality. One vital tool that allows us to do this is unit testing.
Unit testing makes it possible to verify that every piece, or unit, of our
application functions as intended.
One benefit of practicing functional techniques is that they lend
themselves to writing testable code. Pure functions are naturally
testable. Immutability is easily testable. Composing applications out of
small functions designed for specific tasks produces testable functions
or units of code.
In this section, we’ll demonstrate techniques that can be used to unit
test React applications. This chapter will not only cover testing, but
also tools that can be used to help evaluate and improve your code and
your tests.
ESLint
In most programming languages, code needs to be compiled before you
can run anything. Programming languages have pretty strict rules about
coding style and will not compile until the code is formatted
appropriately. JavaScript does not have those rules and does not come
with a compiler. We write code, cross our fingers, and run it in the
browser to see if it works or not. The good news is that there are tools
1
we can use to analyze our code and make us stick to specific formatting
guidelines.
The process of analyzing JavaScript code is called hinting or linting.
JSHint and JSLint are the original tools used to analyze JavaScript and
provide feedback about formatting. ESLint is the latest code linter that
supports emerging JavaScript syntax. Additionally, ESLint is
pluggable. This means we can create and share plug-ins that can be
added to ESLint configurations to extend its capabilities.
ESLint is supported out of the box with Create React App, and we’ve
already seen lint warnings and errors appear in the console.
We’ll be working with a plug-in called eslint-plugin-react. This
plug-in will analyze our JSX and React syntax in addition to our
JavaScript.
Let’s install eslint as a dev dependency. We can install eslint with
npm:
npm install eslint --save-dev
# or
yarn add eslint --dev
Before we use ESLint, we’ll need to define some configuration rules
that we can agree to follow. We’ll define these in a configuration file
that’s located in our project root. This file can be formatted as JSON or
YAML. YAML is a data serialization formation like JSON but with
less syntax, making it a little easier for humans to read.
ESLint comes with a tool that helps us set up configuration. There are
several companies that have created ESLint config files that we can use
as a starting point, or we can create our own.
We can create an ESLint configuration by running eslint --init and
answering some questions about our coding style:
npx eslint --init
How would you like to configure ESLint?
To check syntax and find problems
What type of modules does your project use?
JavaScript modules (import/export)
Which framework does your project use?
React
Does your project use TypeScript?
N
Where does your code run? (Press space to select, a to toggle all,
i to invert selection)
Browser
What format do you want your config file to be in?
JSON
Would you like to install them now with npm?
Y
After npx eslint --init runs, three things happen:
1. eslint-plugin-react is installed locally to the
./node_modules folder.
2. These dependencies are automatically added to the
package.json file.
3. A configuration file, .eslintrc.json, is created and added to the
root of our project.
If we open .eslintrc.json, we’ll see an object of settings:
{
"env": {
"browser": true,
"es6": true
},
"extends": [
"eslint:recommended",
"plugin:react/recommended"
],
"globals": {
"Atomics": "readonly",
"SharedArrayBuffer": "readonly"
},
"parserOptions": {
"ecmaFeatures": {
"jsx": true
},
"ecmaVersion": 2018,
"sourceType": "module"
},
"plugins": ["react"],
"rules": {}
}
Importantly, if we look at the extends key, we’ll see that our --init
command initalized defaults for eslint and react. This means that we
don’t have to manually configure all of the rules. Instead, those rules
are provided to us.
Let’s test our ESLint configuration and these rules by creating a
sample.js file:
const gnar = "gnarly";
const info = ({
file = __filename,
dir = __dirname
}) => (
<p>
{dir}: {file}
</p>
);
switch (gnar) {
default:
console.log("gnarly");
break;
}
This file has some issues, but nothing that would cause errors in the
browser. Technically, this code works just fine. Let’s run ESLint on
this file and see what feedback we get based on our customized rules:
npx eslint sample.js
3:7 error 'info' is assigned a value but never used no-unused-vars
4:3 error 'file' is missing in props validation react/prop-types
4:10 error 'filename' is not defined no-undef
5:3 error 'dir' is missing in props validation react/prop-types
5:9 error 'dirname' is not defined no-undef
7:3 error 'React' must be in scope when using JSX react/react-in-jsxscope
✖ 6 problems (6 errors, 0 warnings)
ESLint has performed a static analysis of our code and is reporting
some issues based on our configuration choices. There are errors about
property validation, and ESLint also complains about __filename and
__dirname because it does not automatically include Node.js globals.
And finally, ESLint’s default React warnings let us know that React
must be in scope when using JSX.
The command eslint . will lint our entire directory. To do this, we’ll
most likely require that ESLint ignore some JavaScript files. The
.eslintignore file is where we can add files or directories for ESLint to
ignore:
dist/assets/
sample.js
This .eslintignore file tells ESLint to ignore our new sample.js file as
well as anything in the dist/assets folder. If we don’t ignore the assets
folder, ESLint will analyze the client bundle.js file, and it will probably
find a lot to complain about in that file.
Let’s add a script to our package.json file for running ESLint:
{
"scripts": {
"lint": "eslint ."
}
}
Now ESLint can be run any time we want with npm run lint, and it
will analyze all of the files in our project except the ones we’ve
ignored.
ESLint Plug-Ins
There are a multitude of plug-ins that can be added to your ESLint
configuration to help you as you’re writing code. For a React project,
you’ll definitely want to install eslint-plugin-react-hooks, a plug-
in to enforce the rules of React Hooks. This package was released by
the React team to help fix bugs related to Hooks usage.
Start by installing it:
npm install eslint-plugin-react-hooks --save-dev
# OR
yarn add eslint-plugin-react-hooks --dev
Then, open the .eslintrc.json file and add the following:
{
"plugins": [
// ...
"react-hooks"
],
"rules": {
"react-hooks/rules-of-hooks": "error",
"react-hooks/exhaustive-deps": "warn"
}
}
This plug-in will check to ensure that functions that start with the word
“use” (assumed to be a hook) are following the rules of Hooks.
Once this has been added, we’ll write some sample code to test the
plug-in. Adjust the code in sample.js. Even though this code won’t run,
we’re testing to see if the plug-in is working appropriately:
function gnar() {
const [nickname, setNickname] = useState(
"dude"
);
return <h1>gnarly</h1>;
}
Several errors will pop up from this code, but most importantly, there’s
the error that lets us know we’re trying to call useState in a function
that isn’t a component or a hook:
4:35 error React Hook "useState" is called in function "gnar" that is
neither
a React function component nor a custom React Hook function
react-hooks/rules-of-hooks
These shoutouts will help us along the way as we learn the ins and outs
of working with Hooks.
Another useful ESLint plug-in to incorporate into your projects is
eslint-plugin-jsx-a11y. A11y is a numeronym, which means that
there are 11 letters between the “a” and the “y” in accessibility. When
we consider accessibility, we build tools, websites, and technologies
that can be used by people with disabilities.
This plug-in will analyze your code and ensure that it’s not breaking
any accessibility rules. Accessibility should be an area of focus for all
of us, and working with this plug-in will promote good practices when
writing accessible React applications.
To install, we’ll use npm or yarn again:
npm install eslint-plugin-jsx-a11y
// or
yarn add eslint-plugin-jsx-a11y
Then we’ll add to our config, .eslintrc.json:
{
"extends": [
// ...
"plugin:jsx-a11y/recommended"
],
"plugins": [
// ...
"jsx-a11y"
]
}
Now let’s test it. We’ll adjust our sample.js file to include an image tag
that has no alt property. In order for an image to pass a lint check, it
must have an alt prop or an empty string if the image doesn’t affect the
user’s understanding of the content:
function Image() {
return <img src="/img.png" />;
}
If we run lint again with npm run lint, we’ll see that there’s a new
error that’s called by the jsx/a11y plug-in:
5:10 error img elements must have an alt prop, either with meaningful
text,
or an empty string for decorative images
There are many other ESLint plug-ins you can use to statically analyze
your code, and you could spend weeks tuning your ESLint config to
perfection. If you’re looking to take yours to the next level, there are
many useful resources in the Awesome ESLint repository.
Prettier
Prettier is an opinionated code formatter you can use on a range of
projects. The effect Prettier has had on the day-to-day work of web
developers since its release has been pretty incredible. Based on
historical records, arguing over syntax filled 87% of an average
JavaScript developer’s day, but now Prettier handles code formatting
and defining the rules around what code syntax should be used per
project. The time savings are significant. Also, if you’ve ever
unleashed Prettier on a Markdown table, the quick, crisp formatting
that occurs is a pretty incredible sight to behold.
ESLint used to be in charge of code formatting for many projects, but
now there’s a clear delineation of responsibilities. ESLint handles
code-quality concerns. Prettier handles code formatting.
To make Prettier work with ESLint, we’ll tinker with the configuration
of our project a bit more. You can install Prettier globally to get
started:
sudo npm install -g prettier
Now you can use Prettier anywhere on any project.
Configuring Prettier by Project
To add a Prettier configuration file to your project, you can create a
.prettierrc file. This file will describe the project defaults:
{
"semi": true,
"trailingComma": none,
"singleQuote": false,
"printWidth": 80
}
These are our preferred defaults, but of course, choose what makes
most sense to you. For more Prettier formatting options, check out
Prettier’s documentation.
Let’s replace what currently lives in our sample.js file with some code
to format:
console.log("Prettier Test")
Now let’s try running the Prettier CLI from the Terminal or Command
Prompt:
prettier --check "sample.js"
Prettier runs the test and shows us the following message: Code style
issues found in the above file(s). Forgot to run
Prettier? To run it from the CLI, we can pass the write flag:
prettier --write "sample.js"
Once we do this, we’ll see an output of a certain number of
milliseconds that it took Prettier to format the file. If we open the file,
we’ll see that the content has changed based on the defaults supplied in
the .prettierrc file. If you’re thinking that this process seems laborious
and could be sped up, you’re right. Let’s start automating!
First, we’ll integrate ESLint and Prettier by installing a config tool and
a plug-in:
npm install eslint-config-prettier eslint-plugin-prettier --save-dev
The config (eslint-config-prettier) turns off any ESLint rules that
could conflict with Prettier. The plug-in (eslint-plugin-prettier)
integrates Prettier rules into ESLint rules. In other words, when we run
our lint script, Prettier will run, too.
We’ll incorporate these tools into .eslintrc.json:
{
"extends": [
// ...
"plugin:prettier/recommended"
],
"plugins": [
//,
"prettier"],
"rules": {
// ...
"prettier/prettier": "error"
}
}
Make sure to break some formatting rules in your code to ensure that
Prettier is working. For example, in sample.js:
console.log("Prettier Test");
Running the lint command npm run lint will yield the following
output:
1:13 error Replace `'Prettier·Test')` with `"Prettier·Test");`
prettier/prettier
All of the errors were found. Now you can run the Prettier write
command and sweep the formatting for one file:
prettier --write "sample.js"
Or for all of the JavaScript files in certain folders:
prettier --write "src/*.js"
Prettier in VSCode
If you’re using VSCode, it’s highly recommended that you set up
Prettier in your editor. Configuration is fairly quick and will save you a
lot of time as you’re writing code.
You’ll first want to install the VSCode extension for Prettier. Just
follow this link and click Install. Once installed, you can run Prettier
with Control + Command + P on a Mac or Ctrl + Shift + P on a PC to
manually format a file or highlighted bit of code. For even better
results, you can format your code on Save. This involves adding some
settings to VSCode.
To access these settings, select the Code menu, then Preferences, then
Settings. (Or Command + comma on a Mac or Ctrl + comma on a PC,
if you’re in a hurry.) Then you can click on the small paper icon in the
upper right-hand corner to open the VSCode settings as JSON. You’ll
want to add a few helpful keys here:
{
"editor.formatOnSave": true
}
Now when you save any file, Prettier will format it based on the
.prettierrc defaults! Pretty killer. You can also search Settings for
Prettier options to set up defaults in your editor if you want to enforce
formatting, even if your project doesn’t contain a .prettierrc config file.
If you’re using a different editor, Prettier likely supports that, too. For
instructions specific to other code editors, check out the Editor
Integration section of the docs.
Typechecking for React Applications
When you’re working with a larger application, you may want to
incorporate typechecking to help pinpoint certain types of bugs. There
are three main solutions for typechecking in React apps: the proptypes library, Flow, and TypeScript. In the next section, we’ll take a
closer look at how you might set up these tools to increase code
quality.
PropTypes
In the first edition of this book, PropTypes were part of the core React
library and were the recommended way to add typechecking to your
application. Today, due to the emergence of other solutions like Flow
and TypeScript, the functionality has been moved to its own library to
make React’s bundle size smaller. Still, PropTypes are a widely used
solution.
To add PropTypes to your app, install the prop-types library:
npm install prop-types --save-dev
We’ll test this by creating a minimal App component that renders the
name of a library:
import React from "react";
import ReactDOM from "react-dom";
function App({ name }) {
return (
<div>
<h1>{name}</h1>
</div>
);
}
ReactDOM.render(
<App name="React" />,
document.getElementById("root")
);
Then we’ll import the prop-types library and use App.propTypes to
define which type each property should be:
import PropTypes from "prop-types";
function App({ name }) {
return (
<div>
<h1>{name}</h1>
</div>
);
}
App.propTypes = {
name: PropTypes.string
};
The App component has one property name and should always be a
string. If an incorrect type value is passed as the name, an error will be
thrown. For example, if we used a boolean:
ReactDOM.render(
<App name="React" />,
document.getElementById("root")
);
Our console would report a problem back to us:
Warning: Failed prop type: Invalid prop name of type boolean supplied to
App,
expected string. in App
When a value of an incorrect type is provided for a property, the
warning only appears in development mode. The warnings and broken
renders won’t appear in production.
Other types are available, of course, when validating properties. We
could add a boolean for whether or not a technology was used at a
company:
function App({ name, using }) {
return (
<div>
<h1>{name}</h1>
<p>
{using ? "used here" : "not used here"}
</p>
</div>
);
}
App.propTypes = {
name: PropTypes.string,
using: PropTypes.bool
};
ReactDOM.render(
<App name="React" using={true} />,
document.getElementById("root")
);
The longer list of type checks includes:
PropTypes.array
PropTypes.object
PropTypes.bool
PropTypes.func
PropTypes.number
PropTypes.string
PropTypes.symbol
Additionally, if you want to ensure that a value was provided, you can
chain .isRequired onto the end of any of these options. For example,
if a string must be supplied, you’d use:
App.propTypes = {
name: PropTypes.string.isRequired
};
ReactDOM.render(
<App />,
document.getElementById("root")
);
Then, if you fail to provide a value for this field, the following warning
will appear in the console:
index.js:1 Warning: Failed prop type: The prop name is marked as required
in App,
but its value is undefined.
There also may be situations where you don’t care what the value is, as
long as a value is provided. In that case, you can use any. For example:
App.propTypes = {
name: PropTypes.any.isRequired
};
This means that a boolean, string, number––anything––could be
supplied. As long as name is not undefined, the typecheck will
succeed.
In addition to the basic typechecks, there are a few other utilities that
are useful for many real-world situations. Consider a component where
there are two status options: Open and Closed:
function App({ status }) {
return (
<div>
<h1>
We're {status === "Open" ? "Open!" : "Closed!"}
</h1>
</div>
);
}
ReactDOM.render(
<App status="Open" />,
document.getElementById("root")
);
Status is a string, so we might be inclined to use the string check:
App.propTypes = {
status: PropTypes.string.isRequired
};
That works well, but if other string values besides Open and Closed are
passed in, the property will be validated. The type of check we actually
want to enforce is an enum check. An enumeration type is a restricted
list of options for a particular field or property. We’ll adjust the
propTypes object like so:
App.propTypes = {
status: PropTypes.oneOf(["Open", "Closed"])
};
Now if anything other than the values from the array that’s passed to
PropTypes.oneOf is supplied, a warning will appear.
For all the options you can configure for PropTypes in your React app,
check out the documentation.
Flow
Flow is a typechecking library that’s used and maintained by Facebook
Open Source. It’s a tool that checks for errors via static type
annotations. In other words, if you create a variable that’s a particular
type, Flow will check to be sure that that value used is the correct type.
Let’s fire up a Create React App project:
npx create-react-app in-the-flow
Then we’ll add Flow to the project. Create React App doesn’t assume
you want to use Flow, so it doesn’t ship with the library, but it’s
smooth to incorporate:
npm install --save flow-bin
Once installed, we’ll add an npm script to run Flow when we type npm
run flow. In package.json, just add this to the scripts key:
{
"scripts": {
"start": "react-scripts start",
"build": "react-scripts build",
"test": "react-scripts test",
"eject": "react-scripts eject",
"flow": "flow"
}
}
Now running the flow command will run typechecking on our files.
Before we can use it, though, we need to create a .flowconfig file. To
do so, we run:
npm run flow init
This creates a skeleton of a configuration file that looks like this:
[ignore]
[include]
[libs]
[lints]
[options]
[strict]
In most cases, you’ll leave this blank to use Flow’s defaults. If you
want to configure Flow beyond the basics, you can explore more
options in the documentation.
One of the coolest features of Flow is that you can adopt Flow
incrementally. It can feel overwhelming to have to add typechecking to
an entire project. With Flow, this isn’t a requirement. All you need to
do is add the line //@flow to the top of any files you want to
typecheck, then Flow will automatically only check those files.
Another option is to add the VSCode extension for Flow to help with
code completion and parameter hints. If you have Prettier or a linting
tool set up, this will help your editor handle the unexpected syntax of
Flow. You can find that in the marketplace.
Let’s open the index.js file and, for the sake of simplicity, keep
everything in the same file. Make sure to add //@flow to the top of the
file:
//@flow
import React from "react";
import ReactDOM from "react-dom";
function App(props) {
return (
<div>
<h1>{props.item}</h1>
</div>
);
}
ReactDOM.render(
<App item="jacket" />,
document.getElementById("root")
);
Now we’ll define the types for the properties:
type Props = {
item: string
};
function App(props: Props) {
//...
}
Then run Flow npm run flow. In certain versions of Flow, you may
see this warning:
Cannot call ReactDOM.render with root bound to container because null [1]
is
incompatible with Element [2]
This warning exists because if document.getElementById("root")
returns null, the app will crash. To safeguard against this (and to clear
the error), we can do one of two things. The first approach is to use an
if statement to check to see that root is not null:
const root = document.getElementById("root");
if (root !== null) {
ReactDOM.render(<App item="jacket" />, root);
}
Another option is to add a typecheck to the root constant using Flow
syntax:
const root = document.getElementById("root");
ReactDOM.render(<App item="jacket" />, root);
In either case, you’ll clear the error and see that your code is free of
errors!
No errors!
We could trust this fully, but trying to break it feels like a good idea.
Let’s pass a different property type to the app:
ReactDOM.render(<App item={3} />, root);
Cool, we broke it! Now we get an error that reads:
Cannot create App element because number [1] is incompatible with string
[2]
in property item.
Let’s switch it back and add another property for a number. We’ll also
adjust the component and property definitions:
type Props = {
item: string,
cost: number
};
function App(props: Props) {
return (
<div>
<h1>{props.item}</h1>
<p>Cost: {props.cost}</p>
</div>
);
}
ReactDOM.render(
<App item="jacket" cost={249} />,
root
);
Running this works, but what if we removed the cost value?
ReactDOM.render(<App item="jacket" />, root);
We’ll immediately get an error:
Cannot create App element because property cost is missing in props [1]
but
exists in Props [2].
If cost is truly not a required value, we can make it optional in the
property definitions using the question mark after the property name,
cost?:
type Props = {
item: string,
cost?: number
};
If we run it again, we don’t see the error.
That’s the tip of the iceberg with all of the different features that Flow
has to offer. To learn more and to stay on top of the changes in the
library, head over to the documentation site.
TypeScript
TypeScript is another popular tool for typechecking in React
applications. It’s an open source superset of JavaScript, which means
that it adds additional features to the language. Created at Microsoft,
TypeScript is designed to be used for large apps to help developers find
bugs and iterate more quickly on projects.
TypeScript has a growing allegiance of supporters, so the tooling in the
ecosystem continues to improve. One tool that we’re already familiar
with is Create React App, which has a TypeScript template we can use.
Let’s set up some basic typechecking, similar to what we did with
PropTypes and Flow, to get a sense of how we can start using it in our
own apps.
We’ll start by generating yet another Create React App, this time with
some different flags:
npx create-react-app my-type --template typescript
Now let’s tour the features of our scaffolded project. Notice in the src
directory that the file extensions are .ts or .tsx now. We’ll also find a
.tsconfig.json file, which contains all of our TypeScript settings. More
on that in a bit.
Also, if you take a look at the package.json file, there are new
dependencies listed and installed related to TypeScript, like the library
itself and type definitions for Jest, React, ReactDOM, and more. Any
dependency that starts with @types/ describes the type definitions for
a library. That means that the functions and methods in the library are
typed so that we don’t have to describe all of the library’s types.
NOTE
If your project doesn’t include the TypeScript features, you might be using an old
version of Create React App. To get rid of this, you can run npm uninstall -g
create-react-app.
Let’s try dropping our component from the Flow lesson into our
project. Just add the following to the index.ts file:
import React from "react";
import ReactDOM from "react-dom";
function App(props) {
return (
<div>
<h1>{props.item}</h1>
</div>
);
}
ReactDOM.render(
<App item="jacket" />,
document.getElementById("root")
);
If we run the project with npm start, we should see our first
TypeScript error. This is to be expected at this point:
Parameter 'props' implicitly has an 'any' type.
This means we need to add type rules for this App component. We’ll
start by defining types just as we did earlier for the Flow component.
The item is a string, so we’ll add that to the AppProps type:
type AppProps = {
item: string;
};
ReactDOM.render(
<App item="jacket" />,
document.getElementById("root")
);
Then we’ll reference AppProps in the component:
function App(props: AppProps) {
return (
<div>
<h1>{props.item}</h1>
</div>
);
}
Now the component will render with no TypeScript issues. It’s also
possible to destructure props if we’d like to:
function App({ item }: AppProps) {
return (
<div>
<h1>{item}</h1>
</div>
);
}
We can break this by passing a value of a different type as the item
property:
ReactDOM.render(
<App item={1} />,
document.getElementById("root")
);
This immediately triggers an error:
Type 'number' is not assignable to type 'string'.
The error also tells us the exact line where there’s a problem. This is
extremely useful as we’re debugging.
TypeScript helps with more than just property validation, though. We
can use TypeScript’s type inference to help us do typechecking on
hook values.
Consider a state value for a fabricColor with an initial state of
purple. The component might look like this:
type AppProps = {
item: string;
};
function App({ item }: AppProps) {
const [fabricColor, setFabricColor] = useState(
"purple"
);
return (
<div>
<h1>
{fabricColor} {item}
</h1>
<button
onClick={() => setFabricColor("blue")}
>
Make the Jacket Blue
</button>
</div>
);
}
Notice that we haven’t added anything to the type definitions object.
Instead, TypeScript is inferring that the type for the fabricColor
should match the type of its initial state. If we try setting the
fabricColor with a number instead of another string color blue, an
error will be thrown:
<button onClick={() => setFabricColor(3)}>
The error looks like this:
Argument of type '3' is not assignable to parameter of type string.
TypeScript is hooking us up with some pretty low-effort typechecking
for this value. Of course, you can customize this further, but this should
give you a start toward adding typechecking to your applications.
For more on TypeScript, check out the official docs and the amazing
React+TypeScript Cheatsheets on GitHub.
Test-Driven Development
Test-driven development, or TDD, is a practice—not a technology. It
does not mean that you simply have tests for your application. Rather,
it’s the practice of letting the tests drive the development process. In
order to practice TDD, you should follow these steps:
Write the tests first
This is the most critical step. You declare what you’re building and
how it should work first in a test. The steps you’ll use to test are
red, green, and gold.
Run the tests and watch them fail (red)
Run the tests and watch them fail before you write the code.
Write the minimal amount of code required to make the tests pass
(green)
Focus specifically on making each test pass; do not add any
functionality beyond the scope of the test.
Refactor both the code and the tests (gold)
Once the tests pass, it’s time to take a closer look at your code and
your tests. Try to express your code as simply and as beautifully as
possible.
TDD gives us an excellent way to approach a React application,
particularly when testing Hooks. It’s typically easier to think about
how a Hook should work before actually writing it. Practicing TDD
will allow you to build and certify the entire data structure for a feature
or application independent of the UI.
TDD and Learning
If you’re new to TDD, or new to the language you’re testing, you may
find it challenging to write a test before writing code. This is to be
expected, and it’s OK to write the code before the test until you get the
hang of it. Try to work in small batches: a little bit of code, a few tests,
and so on. Once you get used to writing tests, it will be easier to write
the tests first.
For the remainder of this chapter, we’ll be writing tests for code that
already exists. Technically, we’re not practicing TDD. However, in the
next section, we’ll pretend that our code does not already exist so we
can get a feel for the TDD workflow.
Incorporating Jest
Before we can get started writing tests, we’ll need to select a testing
framework. You can write tests for React with any JavaScript testing
2
framework, but the official React docs recommend testing with Jest, a
JavaScript test runner that lets you access the DOM via JSDOM.
Accessing the DOM is important because you want to be able to check
what is rendered with React to ensure your application is working
correctly.
Create React App and Testing
Projects that have been initialized with Create React App already come
with the jest package installed. We can create another Create React
App project to get started, or use an existing one:
npx create-react-app testing
Now we can start thinking about testing with a small example. We’ll
create two new files in the src folder: functions.js and functions.test.js.
Remember, Jest is already configured and installed in Create React
App, so all you need to do is start writing tests. In functions.test.js,
we’ll stub the tests. In other words, we’ll write what we think the
function should do.
We want our function to take in a value, multiply it by two, and return
it. So we’ll model that in the test. The test function is the function that
Jest provides to test a single piece of functionality:
functions.test.js
test("Multiplies by two", () => {
expect();
});
The first argument, Multiplies by two, is the test name. The second
argument is the function that contains what should be tested and the
third (optional) argument specifies a timeout. The default timeout is
five seconds.
The next thing we’ll do is stub the function that will multiply numbers
by two. This function will be referred to as our system under test
(SUT). In functions.js, create the function:
export default function timesTwo() {...}
We’ll export it so that we can use the SUT in the test. In the test file,
we want to import the function, and we’ll use expect to write an
assertion. In the assertion, we’ll say that if we pass 4 to the timesTwo
function, we expect that it should return 8:
import { timesTwo } from "./functions";
test("Multiplies by two", () => {
expect(timesTwo(4)).toBe(8);
});
Jest “matchers” are returned by the expect function and used to verify
results. To test the function, we’ll use the .toBe matcher. This verifies
that the resulting object matches the argument sent to .toBe.
Let’s run the tests and watch them fail using npm test or npm run
test. Jest will provide specific details on each failure, including a
stack trace:
FAIL src/functions.test.js
✕ Multiplies by two (5ms)
● Multiplies by two
expect(received).toBe(expected) // Object.is equality
Expected: 8
Received: undefined
2 |
3 | test("Multiplies by two", () => {
> 4 | expect(timesTwo(4)).toBe(8);
| ^
5 | });
6 |
at Object.<anonymous> (src/functions.test.js:4:23)
Test Suites: 1 failed, 1 total
Tests: 1 failed, 1 total
Snapshots: 0 total
Time: 1.048s
Ran all test suites related to changed files.
Taking the time to write the tests and run them to watch them fail
shows us that our tests are working as intended. This failure feedback
represents our to-do list. It’s our job to write the minimal code required
to make our tests pass.
Now if we add the proper functionality to the functions.js file, we can
make the tests pass:
export function timesTwo(a) {
return a * 2;
}
The .toBe matcher has helped us test for equality with a single value.
If we want to test an object or array, we could use .toEqual. Let’s go
through another cycle with our tests. In the test file, we’ll test for
equality of an array of objects.
We have a list of menu items from the Guy Fieri restaurant in Las
Vegas. It’s important that we build an object of their ordered items so
the customer can get what they want and know what they’re supposed
to pay. We’ll stub the test first:
test("Build an order object", () => {
expect();
});
Then we’ll stub our function:
export function order(items) {
// ...
}
Now we’ll use the order function in the test file. We’ll also assume that
we have a starter list of data for an order that we need to transform:
import { timesTwo, order } from "./functions";
const menuItems = [
{
id: "1",
name: "Tatted Up Turkey Burger",
price: 19.5
},
{
id: "2",
name: "Lobster Lollipops",
price: 16.5
},
{
id: "3",
name: "Motley Que Pulled Pork Sandwich",
price: 21.5
},
{
id: "4",
name: "Trash Can Nachos",
price: 19.5
}
];
test("Build an order object", () => {
expect(order(menuItems));
});
Remember that we’ll use toEqual because we’re checking the value of
an object instead of an array. What do we want the result to equal?
Well, we want to create an object that looks like this:
const result = {
orderItems: menuItems,
total: 77
};
So we just add that to the test and use it in the assertion:
test("Build an order object", () => {
const result = {
orderItems: menuItems,
total: 77
};
expect(order(menuItems)).toEqual(result);
});
Now we’ll complete the function in the functions.js file:
export function order(items) {
const total = items.reduce(
(price, item) => price + item.price,
0
);
return {
orderItems: items,
total
};
}
And when we check out the terminal, we’ll find that are tests are now
passing! Now this might feel like a trivial example, but if you were
fetching data, it’s likely that you’d test for shape matches of arrays and
objects.
Another commonly used function with Jest is describe(). If you’ve
used other testing libraries, you might have seen a similar function
before. This function is typically used to wrap several related tests. For
example, if we had a few tests for similar functions, we could wrap
them in a describe statement:
describe("Math functions", () => {
test("Multiplies by two", () => {
expect(timesTwo(4)).toBe(8);
});
test("Adds two numbers", () => {
expect(sum(4, 2)).toBe(6);
});
test("Subtracts two numbers", () => {
expect(subtract(4, 2)).toBe(2);
});
});
When you wrap tests in the describe statement, the test runner creates
a block of tests, which makes the testing output in the terminal look
more organized and easier to read:
Math functions
✓ Multiplies by two
✓ Adds two numbers
✓ Subtracts two numbers (1ms)
As you write more tests, grouping them in describe blocks might be a
useful enhancement.
This process represents a typical TDD cycle. We wrote the tests first,
then wrote code to make the tests pass. Once the tests pass, we can take
a closer look at the code to see if there’s anything that’s worth
refactoring for clarity or performance. This approach is very effective
when working with JavaScript (or really any other language).
Testing React Components
Now that we have a basic understanding of the process behind writing
tests, we can start to apply these techniques to component testing in
React.
React components provide instructions for React to follow when
creating and managing updates to the DOM. We can test these
components by rendering them and checking the resulting DOM.
We’re not running our tests in a browser; we’re running them in the
terminal with Node.js. Node.js does not have the DOM API that comes
standard with each browser. Jest incorporates an npm package called
jsdom that’s used to simulate a browser environment in Node.js, which
is essential for testing React components.
For each component test, it’s likely that we’ll need to render our React
component tree to a DOM element. To demonstrate this workflow,
let’s revisit our Star component in Star.js:
import { FaStar } from "react-icons/fa";
export default function Star({ selected = false }) {
return (
<FaStar color={selected ? "red" : "grey"} id="star" />
);
}
Then in index.js, we’ll import and render the star:
import Star from "./Star";
ReactDOM.render(
<Star />,
document.getElementById("root")
);
Now let’s write our test. We already wrote the code for the star, so we
won’t be partaking in TDD here. If you had to incorporate tests into
your existing apps, this is how you’d do it. In a new file called
Star.test.js, start by importing React, ReactDOM, and the Star:
import React from "react";
import ReactDOM from "react-dom";
import Star from "./Star";
test("renders a star", () => {
const div = document.createElement("div");
ReactDOM.render(<Star />, div);
});
We’ll also want to write the tests. Remember, the first argument we
supply to test is the name of the test. Then we’re going to perform
some setup by creating a div that we can render the star to with
ReactDOM.render. Once the element is created, we can write the
assertion:
test("renders a star", () => {
const div = document.createElement("div");
ReactDOM.render(<Star />, div);
expect(div.querySelector("svg")).toBeTruthy();
});
We’ll expect that if we try to select an svg element inside of the
created div, the result will be truthy. When we run the test, we should
see that the test passes. Just to verify that we aren’t getting a valid
assertion when we shouldn’t be, we can change the selector to find
something fake and watch the test fail:
expect(
div.querySelector("notrealthing")
).toBeTruthy();
The documentation provides more detail about all of the custom
matchers that are available so that you can test exactly what you want
to test.
When you generated your React project, you may have noticed that a
few packages from @testing-library were installed in addition to
the basics like React and ReactDOM. React Testing Library is a project
that was started by Kent C. Dodds as a way to enforce good testing
practices and to expand the testing utilities that were part of the React
ecosystem. Testing Library is an umbrella over many testing packages
for libraries like Vue, Svelte, Reason, Angular, and more—it’s not just
for React.
One potential reason you might choose React Testing Library is to get
better error messages when a test fails. The current error we see when
we test the assertion:
expect(
div.querySelector("notrealthing")
).toBeTruthy();
is:
expect(received).toBeTruthy()
Received: null
Let’s punch this up by adding React Testing Library. It’s already
installed in our Create React App project. To begin, we’ll import the
toHaveAttribute function from @testing-library/jest-dom:
import { toHaveAttribute } from "@testing-library/jest-dom";
From there, we want to extend the functionality of expect to include
this function:
expect.extend({ toHaveAttribute });
Now instead of using toBeTruthy, which gives us hard-to-read
messages, we can use toHaveAttribute:
test("renders a star", () => {
const div = document.createElement("div");
ReactDOM.render(<Star />, div);
expect(
div.querySelector("svg")
).toHaveAttribute("id", "hotdog");
});
Now when we run the tests, we see an error telling us exactly what’s
what:
expect(element).toHaveAttribute("id", "hotdog")
// element.getAttribute("id") === "hotdog"
Expected the element to have attribute:
id="hotdog"
Received:
id="star"
It should be pretty straightforward to fix this now:
expect(div.querySelector("svg")).toHaveAttribute(
"id",
"star"
);
Using more than one of the custom matchers just means that you need
to import, extend, and use:
import {
toHaveAttribute,
toHaveClass
} from "@testing-library/jest-dom";
expect.extend({ toHaveAttribute, toHaveClass });
expect(you).toHaveClass("evenALittle");
There’s an even faster way to do this, though. If you find yourself
importing too many of these matchers to list or keep track of, you can
import the extend-expect library:
import "@testing-library/jest-dom/extend-expect";
// Remove this --> expect.extend({ toHaveAttribute, toHaveClass });
The assertions will continue to run as expected (pun intended). Another
fun fact about Create React App is that, in a file called setupTests.js
that ships with CRA, there’s a line that has already included the
extend-expect helpers. If you look at the src folder, you’ll see that
setupTests.js contains:
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import "@testing-library/jest-dom/extend-expect";
So if you’re using Create React App, you don’t even have to include
the import in your test files.
Queries
Queries are another feature of the React Testing Library that allow you
to match based on certain criteria. In order to demonstrate using a
query, let’s adjust the Star component to include a title. This will
allow us to write a common style of test—one that matches based on
text:
export default function Star({ selected = false }) {
return (
<>
<h1>Great Star</h1>
<FaStar
id="star"
color={selected ? "red" : "grey"}
/>
</>
);
}
Let’s pause to think about what we’re trying to test. We want the
component to render, and now we want to test to see if the h1 contains
the correct text. A function that’s part of React Testing Library,
render, will help us do just that. render will replace our need to use
ReactDOM.render(), so the test will look a bit different. Start by
importing render from React Testing Library:
import { render } from "@testing-library/react";
render will take in one argument: the component or element that we
want to render. The function returns an object of queries that can be
used to check in with values in that component or element. The query
we’ll use is getByText, which will find the first matching node for a
query and throw an error if no elements match. To return a list of all
matching nodes, use getAllBy to return an array:
test("renders an h1", () => {
const { getByText } = render(<Star />);
const h1 = getByText(/Great Star/);
expect(h1).toHaveTextContent("Great Star");
});
getByText finds the h1 element via the regular expression that’s
passed to it. Then we use the Jest matcher toHaveTextContent to
describe what text the h1 should include.
Run the tests, and they’ll pass. If we change the text passed to the
toHaveTextContent() function, the test will fail.
Testing Events
Another important part of writing tests is testing events that are part of
components. Let’s use and test the Checkbox component we created in
Chapter 7:
export function Checkbox() {
const [checked, setChecked] = useReducer(
checked => !checked,
false
);
return (
<>
<label>
{checked ? "checked" : "not checked"}
<input
type="checkbox"
value={checked}
onChange={setChecked}
/>
</label>
</>
);
}
This component uses useReducer to toggle a checkbox. Our aim here
is to create an automated test that will click this checkbox and change
the value of checked from the default false to true. Writing a test to
check the box will also fire useReducer and test the hook.
Let’s stub the test:
import React from "react";
test("Selecting the checkbox should change the value of checked to true",
() => {
// .. write a test
});
The first thing we need to do is select the element that we want to fire
the event on. In other words, which element do we want to click on
with the automated test? We’ll use one of Testing Library’s queries to
find the element we’re looking for. Since the input has a label, we can
use getByLabelText():
import { render } from "@testing-library/react";
import { Checkbox } from "./Checkbox";
test("Selecting the checkbox should change the value of checked to true",
() => {
const { getByLabelText } = render(<Checkbox />);
});
When the component first renders, its label text reads not checked, so
we can search via a regular expression to find a match with the string:
test("Selecting the checkbox should change the value of checked to true",
() => {
const { getByLabelText } = render(<Checkbox />);
const checkbox = getByLabelText(/not checked/);
});
Currently, this regex is case sensitive, so if you wanted to search for
any case, you could add an i to the end of it. Use that technique with
caution depending on how permissive you want the query selection to
be:
const checkbox = getByLabelText(/not checked/i);
Now we have our checkbox selected. All we need to do now is fire the
event (click the checkbox) and write an assertion to make sure that the
checked property is set to true when the checkbox is clicked:
mport { render, fireEvent } from "@testing-library/react"
test("Selecting the checkbox should change the value of checked to true",
() => {
const { getByLabelText } = render(<Checkbox />);
const checkbox = getByLabelText(/not checked/i);
fireEvent.click(checkbox);
expect(checkbox.checked).toEqual(true);
});
You also could add the reverse toggle to this checkbox test by firing
the event again and checking that the property is set to false on
toggle. We changed the name of the test to be more accurate:
test("Selecting the checkbox should toggle its value", () => {
const { getByLabelText } = render(<Checkbox />);
const checkbox = getByLabelText(/not checked/i);
fireEvent.click(checkbox);
expect(checkbox.checked).toEqual(true);
fireEvent.click(checkbox);
expect(checkbox.checked).toEqual(false);
});
In this case, selecting the checkbox is pretty easy. We have a label we
can use to find the input we want to check. In the event that you don’t
have such an easy way to access a DOM element, Testing Library
gives you another utility you can use to check in with any DOM
element. You’ll start by adding an attribute to the element you want to
select:
<input
type="checkbox"
value={checked}
onChange={setChecked}
data-testid="checkbox" // Add the data-testid= attribute
/>
Then use the query getByTestId:
test("Selecting the checkbox should change the value of checked to true",
() => {
const { getByTestId } = render(<Checkbox />);
const checkbox = getByTestId("checkbox");
fireEvent.click(checkbox);
expect(checkbox.checked).toEqual(true);
});
This will do the same thing but is particularly useful when reaching out
to DOM elements that are otherwise difficult to access.
Once this Checkbox component is tested, we can confidently
incorporate it into the rest of the application and reuse it.
Using Code Coverage
Code coverage is the process of reporting on how many lines of code
have actually been tested. It provides a metric that can help you decide
when you’ve written enough tests.
Jest ships with Istanbul, a JavaScript tool used to review your tests and
generate a report that describes how many statements, branches,
functions, and lines have been covered.
To run Jest with code coverage, simply add the coverage flag when
you run the jest command:
npm test -- --coverage
This report tells you how much of your code in each file has been
executed during the testing process and reports on all files that have
been imported into tests.
Jest also generates a report that you can run in your browser, which
provides more details about what code has been covered by tests. After
running Jest with coverage reporting, you’ll notice that a coverage
folder has been added to the root. In a web browser, open this file:
/coverage/lcov-report/index.html. It will show you your code coverage
in an interactive report.
This report tells you how much of the code has been covered, as well
as the individual coverage based on each subfolder. You can drill down
into a subfolder to see how well the individual files within have been
covered. If you select the components/ui folder, you’ll see how well
your user interface components are covered by testing.
You can see which lines have been covered in an individual file by
clicking on the filename.
Code coverage is a great tool to measure the reach of your tests. It’s
one benchmark to help you understand when you’ve written enough
unit tests for your code. It’s not typical to have 100% code coverage in
every project. Shooting for anything above 85% is a good target.
3
Testing can often feel like an extra step, but the tooling around React
testing has never been better. Even if you don’t test all of your code,
starting to think about how to incorporate testing practices can help you
save time and money when building production-ready applications.
1
For a brief introduction to unit testing, see Martin Fowler’s article, “Unit Testing”.
2
For more on this development pattern, see Jeff McWherter’s and James Bender’s “Red,
Green, Refactor”.
3
See Martin Fowler’s article, “Test-Coverage”.
Chapter 11. React Router
When the web started, most websites consisted of a series of pages that
users could navigate through by requesting and opening separate files.
The location of the current file or resource was listed in the browser’s
location bar. The browser’s forward and back buttons would work as
expected. Bookmarking content deep within a website would allow
users to save a reference to a specific file that could be reloaded at the
user’s request. On a page-based, or server-rendered, website, the
browser’s navigation and history features simply work as expected.
In a single-page app, all of these features become problematic.
Remember, in a single-page app, everything is happening on the same
page. JavaScript is loading information and changing the UI. Features
like browser history, bookmarks, and forward and back buttons will not
work without a routing solution. Routing is the process of defining
endpoints for your client’s requests. These endpoints work in
conjunction with the browser’s location and history objects. They’re
used to identify requested content so that JavaScript can load and
render the appropriate user interface.
Unlike Angular, Ember, or Backbone, React doesn’t come with a
standard router. Recognizing the importance of a routing solution,
engineers Michael Jackson and Ryan Florence created one named
simply React Router. The React Router has been adopted by the
community as a popular routing solution for React apps. It’s used by
1
2
3
companies including Uber, Zendesk, PayPal, and Vimeo.
In this chapter, we’ll introduce React Router and leverage its features
to handle routing on the client.
Incorporating the Router
To demonstrate the capabilities of the React Router, we’ll build a
classic starter website complete with About, Events, Products, and
Contact Us sections. Although this website will feel as though it has
multiple pages, there’s only one—it’s an SPA, a single-page
application (see Figure 11-1).
Figure 11-1. Simple website with link navigation
The sitemap for this website consists of a home page, a page for each
3
section, and an error page to handle 404 Not Found errors (see
Figure 11-2).
Figure 11-2. Sitemap with local links
The router will allow us to set up routes for each section of the website.
Each route is an endpoint that can be entered into the browser’s
location bar. When a route is requested, we can render the appropriate
content.
To start, let’s install React Router and React Router DOM. React
Router DOM is used for regular React applications that use the DOM.
If you’re writing an app for React Native, you’ll use react-routernative. We’re going to install these packages at their experimental
versions because React Router 6 is not officially out at the time of this
printing. Once released, you can use the packages without that
designation.
npm install react-router@experimental react-router-dom@experimental
We’ll also need a few placeholder components for each section or page
in the sitemap. We can export these components from a single file
called pages.js:
import React from "react";
export function Home() {
return (
<div>
<h1>[Company Website]</h1>
</div>
);
}
export function About() {
return (
<div>
<h1>[About]</h1>
</div>
);
}
export function Events() {
return (
<div>
<h1>[Events]</h1>
</div>
);
}
export function Products() {
return (
<div>
<h1>[Products]</h1>
</div>
);
}
export function Contact() {
return (
<div>
<h1>[Contact]</h1>
</div>
);
}
With these pages stubbed out, we need to adjust the index.js file.
Instead of rendering the App component, we’ll render the Router
component. The Router component passes information about the
current location to any children that are nested inside of it. The Router
component should be used once and placed near the root of our
component tree:
import React from "react";
import { render } from "react-dom";
import App from "./App";
import { BrowserRouter as Router } from "react-router-dom";
render(
<Router>
<App />
</Router>,
document.getElementById("root")
);
Notice that we’re importing BrowserRouter as Router. The next
thing we need to do is set up our route configuration. We’re going to
place this in the App.js file. The wrapper component for any routes we
want to render is called Routes. Inside of Routes, we’ll use a Route
component for each page we want to render. We also want to import all
of the pages from the ./pages.js file:
import React from "react";
import { Routes, Route } from "react-router-dom";
import {
Home,
About,
Events,
Products,
Contact
} from "./pages";
function App() {
return (
<div>
<Routes>
<Route path="/" element={<Home />} />
<Route
path="/about"
element={<About />}
/>
<Route
path="/events"
element={<Events />}
/>
<Route
path="/products"
element={<Products />}
/>
<Route
path="/contact"
element={<Contact />}
/>
</Routes>
</div>
);
}
These routes tell the Router which component to render when the
window’s location changes. Each Route component has path and
element properties. When the browser’s location matches the path,
the element will be displayed. When the location is /, the router will
render the Home component. When the location is /products, the
router will render the Products component.
At this point, we can run the app and physically type the routes into the
browser’s location bar to watch the content change. For example, type
http://localhost:3000/about into the location bar and watch the About
component render.
It’s probably not realistic to expect our users to navigate the website by
typing routes into the location bar. The react-router-dom provides a
Link component that we can use to create browser links.
Let’s modify the home page to contain a navigation menu with a link
for each route:
import { Link } from "react-router-dom";
export function Home() {
return (
<div>
<h1>[Company Website]</h1>
<nav>
<Link to="about">About</Link>
<Link to="events">Events</Link>
<Link to="products">Products</Link>
<Link to="contact">Contact Us</Link>
</nav>
</div>
);
}
Now users can access every internal page from the home page by
clicking on a link. The browser’s back button will take them back to
the home page.
Router Properties
The React Router passes properties to the components it renders. For
instance, we can obtain the current location via a property. Let’s use
the current location to help us create a 404 Not Found component.
First, we’ll create the component:
export function Whoops404() {
return (
<div>
<h1>Resource not found</h1>
</div>
);
}
Then we’ll add this to our route configuration in App.js. If we visit a
route that doesn’t exist, like highway, we want to display the
Whoops404 component. We’ll use the * as the path value and the
component as the element:
function App() {
return (
<div>
<Routes>
<Route path="/" element={<Home />} />
<Route
path="/about"
element={<About />}
/>
<Route
path="/events"
element={<Events />}
/>
<Route
path="/products"
element={<Products />}
/>
<Route
path="/contact"
element={<Contact />}
/>
<Route path="*" element={<Whoops404 />} />
</Routes>
</div>
);
}
Now if we visit localhost:3000/highway, we’ll see the 404 page
component render. We also could display the value of the route that
we’ve visited by using the location value. Since we’re living in a world
with React Hooks, there’s a hook for that. In the Whoops404
component, create a variable called location that returns the value of
the current location (i.e., properties about which page you’re navigated
to). Then use the value of location.pathname to display the route
that’s being visited:
export function Whoops404() {
let location = useLocation();
console.log(location);
return (
<div>
<h1>
Resource not found at {location.pathname}
</h1>
</div>
);
}
If you log the location, you can explore that object further.
This section introduced the basics of implementing and working with
the React Router. Router is used once and wraps all components that
will use routing. All Route components need to be wrapped with a
Routes component, which selects the component to render based on
the window’s present location. Link components can be used to
facilitate navigation. These basics can get you pretty far, but they just
scratch the surface of the router’s capabilities.
Nesting Routes
Route components are used with content that should be displayed only
when specific URLs are matched. This feature allows us to organize
our web apps into eloquent hierarchies that promote content reuse.
Sometimes, as users navigate our apps, we want some of the UI to stay
in place. In the past, solutions such as page templates and master pages
have helped web developers reuse UI elements.
Let’s consider the simple starter website. We might want to create
subpages for the About page that will display additional content. When
the user selects the About section, they should be defaulted to the
Company page under that section. The outline looks like this:
Home Page
About the Company
Company (default)
History
Services
Location
Events
Products
Contact Us
404 Error Page
The new routes that we need to create will reflect this hierarchy:
http://localhost:3000/
http://localhost:3000/about
http://localhost:3000/about
http://localhost:3000/about/history
http://localhost:3000/about/services
http://localhost:3000/about/location
http://localhost:3000/events
http://localhost:3000/products
http://localhost:3000/contact
http://localhost:3000/hot-potato
We also need to remember to stub placeholder components for our new
sections: Company, Services, History, and Location. As an example,
here’s some text for the Services component that you can reuse for
the other two:
export function Services() {
<section>
<h2>Our Services</h2>
<p>
Lorem ipsum dolor sit amet, consectetur
adipiscing elit. Integer nec odio. Praesent
libero. Sed cursus ante dapibus diam. Sed
nisi. Nulla quis sem at nibh elementum
imperdiet. Duis sagittis ipsum. Praesent
mauris. Fusce nec tellus sed augue semper
porta. Mauris massa. Vestibulum lacinia arcu
eget nulla. Class aptent taciti sociosqu ad
litora torquent per conubia nostra, per
inceptos himenaeos. Curabitur sodales ligula
in libero.
</p>
</section>;
}
With those components created, we can configure the router starting
with the App.js file. If you want to create a page hierarchy with the
routes, all you need to do is nest the Route components inside of each
other:
import {
Home,
About,
Events,
Products,
Contact,
Whoops404,
Services,
History,
Location
} from "./pages";
function App() {
return (
<div>
<Routes>
<Route path="/" element={<Home />} />
<Route path="about" element={<About />}>
<Route
path="services"
element={<Services />}
/>
<Route
path="history"
element={<History />}
/>
<Route
path="location"
element={<Location />}
/>
</Route>
<Route
path="events"
element={<Events />}
/>
<Route
path="products"
element={<Products />}
/>
<Route
path="contact"
element={<Contact />}
/>
<Route path="*" element={<Whoops404 />} />
</Routes>
</div>
);
}
Once you’ve wrapped the nested routes with the About Route
component, you can visit these pages. If you open
http://localhost:3000/about/history, you’ll just see the content from the
About page, but the History component doesn’t display. In order to
get that to display, we’ll use another feature of React Router DOM: the
Outlet component. Outlet will let us render these nested components.
We’ll just place it anywhere we want to render child content.
In the About component in pages.js, we’ll add this under the <h1>:
import {
Link,
useLocation,
Outlet
} from "react-router-dom";
export function About() {
return (
<div>
<h1>[About]</h1>
<Outlet />
</div>
);
}
Now this About component will be reused across the entire section and
will display the nested components. The location will tell the app
which subsection to render. For example, when the location is
http://localhost:3000/about/history, the History component will be
rendered inside of the About component.
Using Redirects
Sometimes you want to redirect users from one route to another. For
instance, we can make sure that if users try to access content via
http://localhost:3000/services, they get redirected to the correct route:
http://localhost:3000/about/services.
Let’s modify our application to include redirects to ensure that our
users can access the correct content:
import {
Routes,
Route,
Redirect
} from "react-router-dom";
function App() {
return (
<div>
<Routes>
<Route path="/" element={<Home />} />
// Other Routes
<Redirect
from="services"
to="about/services"
/>
</Routes>
</div>
);
}
The Redirect component allows us to redirect the user to a specific
route.
When routes are changed in a production application, users will still try
to access old content via old routes. This typically happens because of
bookmarks. The Redirect component provides us with a way to load
the appropriate content for users, even if they’re accessing our site via
an old bookmark.
Throughout this section, we’ve created a route configuration using the
Route component. If you love this structure, feel free to ignore this
next section, but we wanted to make sure that you knew how to create
a route configuration a different way. It’s also possible to use the hook
useRoutes to configure your application’s routing.
If we wanted to refactor our application to use useRoutes, we’d make
the adjustments in the App component (or anywhere where the routes
are set up). Let’s refactor it:
import { useRoutes } from "react-router-dom";
function App() {
let element = useRoutes([
{ path: "/", element: <Home /> },
{
path: "about",
element: <About />,
children: [
{
path: "services",
element: <Services />
},
{ path: "history", element: <History /> },
{
path: "location",
element: <Location />
}
]
},
{ path: "events", element: <Events /> },
{ path: "products", element: <Products /> },
{ path: "contact", element: <Contact /> },
{ path: "*", element: <Whoops404 /> },
{
path: "services",
redirectTo: "about/services"
}
]);
return element;
}
The official docs call the config element, but you can choose to call it
whatever you like. It’s also totally optional to use this syntax. Route is
a wrapper around useRoutes, so you’re actually using this either way.
Choose whichever syntax and style works best for you!
Routing Parameters
Another useful feature of the React Router is the ability to set up
routing parameters. Routing parameters are variables that obtain their
values from the URL. They’re extremely useful in data-driven web
applications for filtering content or managing display preferences.
Let’s revisit the color organizer and improve it by adding the ability to
select and display one color at a time using React Router. When a user
selects a color by clicking on it, the app should render that color and
display its title and hex value.
Using the router, we can obtain the color ID via the URL. For example,
this is the URL we’ll use to display the color “lawn” because the ID for
lawn is being passed within the URL:
http://localhost:3000/58d9caee-6ea6-4d7b-9984-65b145031979
To start, let’s set up the router in the index.js file. We’ll import the
Router and wrap the App component:
import { BrowserRouter as Router } from "react-router-dom";
render(
<Router>
<App />
</Router>,
document.getElementById("root")
);
Wrapping the App passes all of the router’s properties to the component
and any other components nested inside of it. From there, we can set up
the route configuration. We’ll use the Routes and Route components
instead of useRoutes, but remember that this is always an option if
you prefer that syntax. Start by importing Routes and Route:
import { Routes, Route } from "react-router-dom";
Then add to the App. This application will have two routes: the
ColorList and the ColorDetails. We haven’t built ColorDetails
yet, but let’s import it:
import { ColorDetails } from "./ColorDetails";
export default function App() {
return (
<ColorProvider>
<AddColorForm />
<Routes>
<Route
path="/"
element={<ColorList />}
/>
<Route
path=":id"
element={<ColorDetails />}
/>
</Routes>
</ColorProvider>
);
}
The ColorDetails component will display dynamically based on the
id of the color. Let’s create the ColorDetails component in a new file
called ColorDetails.js. To start, it’ll be a placeholder:
import React from "react";
export function ColorDetails() {
return (
<div>
<h1>Details</h1>
</div>
);
}
How do we know if this is working? The easiest way to check is to
open the React Developer tools and find the id of one of the colors that
is being rendered. If you don’t have a color yet, then add one and take a
look at its id. Once you have the id, you can append that to the
localhost:3000 URL. For example, localhost:3000/00fdb4c5-
c5bd-4087-a48f-4ff7a9d90af8.
Now, you should see the ColorDetails page appear. Now we know
that the router and our routes are working, but we want this to be more
dynamic. On the ColorDetails page, we want to display the correct
color based on the id that’s found in the URL. To do that, we’ll use the
useParams hook:
import { useParams } from "react-router-dom";
export function ColorDetails() {
let params = useParams();
console.log(params);
return (
<div>
<h1>Details</h1>
</div>
);
}
If we log params, we’ll see that this is an object that contains any
parameters that are available on the router. We’ll destructure this object
to grab the id, then we can use that id to find the correct color in the
colors array. Let’s use our useColors hook to make this happen:
import { useColors } from "./";
export function ColorDetails() {
let { id } = useParams(); // destructure id
let { colors } = useColors();
let foundColor = colors.find(
color => color.id === id
);
console.log(foundColor);
return (
<div>
<h1>Details</h1>
</div>
);
}
Logging foundColor shows us that we’ve found the correct color.
Now all we need to do is display the data about that color in the
component:
export function ColorDetails() {
let { id } = useParams();
let { colors } = useColors();
let foundColor = colors.find(
color => color.id === id
);
return (
<div>
<div
style={{
backgroundColor: foundColor.color,
height: 100,
width: 100
}}
></div>
<h1>{foundColor.title}</h1>
<h1>{foundColor.color}</h1>
</div>
);
}
Another feature we want to add to the color organizer is the ability to
navigate to the ColorDetails page by clicking on the color in the list.
Let’s add this functionality to the Color component. We’re going to
use another router hook called useNavigate to open the details page
when we click on the component. We’ll import it first from reactrouter-dom:
import { useNavigate } from "react-router-dom";
Then we’ll call useNavigate, which will return a function we can use
to navigate to another page:
let navigate = useNavigate();
Now in the section, we’ll add an onClick handler to navigate to the
route based on the color id:
let navigate = useNavigate();
return (
<section
className="color"
onClick={() => navigate(`/${id}`)}
>
// Color component
</section>
);
Now, when we click on the section, we’ll be routed to the correct
page.
Routing parameters are an ideal tool to obtain data that affects the
presentation of your user interface. However, they should only be used
when you want users to capture these details in a URL. For example, in
the case of the color organizer, users can send other users links to
specific colors or all the colors sorted by a specific field. Users can also
bookmark those links to return specific data.
In this chapter, we reviewed the basic usage of the React Router. In the
next chapter, we’ll learn how to use routing on the server.
1
Express.js documentation, “Basic routing”.
2
The project has been starred over 20,000 times on GitHub.
3
See “Sites Using React Router”.
Chapter 12. React and the
Server
So far, we’ve built small applications with React that run entirely in the
browser. They’ve collected data in the browser and saved the data
using browser storage. This makes sense because React is a view layer;
it’s intended to render UI. However, most applications require at least
the existence of some sort of a backend, and we will need to
understand how to structure applications with a server in mind.
Even if you have a client application that’s relying entirely on cloud
services for the backend, you still need to get and send data to these
services. There are specific places where these transactions should be
made and libraries that can help you deal with the latency associated
with HTTP requests.
Additionally, React can be rendered isomorphically, which means that
it can be in platforms other than the browser. This means we can render
our UI on the server before it ever gets to the browser. Taking
advantage of server rendering, we can improve the performance,
portability, and security of our applications.
We start this chapter with a look at the differences between
isomorphism and universalism and how both concepts relate to React.
Next, we’ll look at how to make an isomorphic application using
universal JavaScript. Finally, we’ll improve the color organizer by
adding a server and rendering the UI on the server first.
Isomorphic Versus Universal
The terms isomorphic and universal are often used to describe
applications that work on both the client and the server. Although these
terms are used interchangeably to describe the same application, there’s
a subtle difference between them that’s worth investigating.
Isomorphic applications are applications that can be rendered on
multiple platforms. Universal code means that the exact same code can
run in multiple environments.
Node.js will allow us to reuse the same code we’ve written in the
browser in other applications such as servers, CLIs, and even native
applications. Let’s take a look at some universal JavaScript:
const userDetails = response => {
const login = response.login;
console.log(login);
};
The printNames function is universal. The exact same code can be
invoked in the browser or on a server. This means that if we
constructed a server with Node.js, we could potentially reuse code
between the two environments. Universal JavaScript is JavaScript that
can run on the server or in the browser without error (see Figure 12-1).
1
Figure 12-1. Client and server domains
Client and Server Domains
The server and the client are completely different domains, so all of our
JavaScript code won’t automatically work between them. Let’s take a
look at creating an AJAX request with the browser:
fetch("https://api.github.com/users/moonhighway")
.then(res => res.json())
.then(console.log);
Here, we’re making a fetch request to the GitHub API, converting the
response to JSON, then calling a function on the JSON results to parse
it.
However, if we try to run the exact same code with Node.js, we get an
error:
fetch("https://api.github.com/users/moonhighway")
^
ReferenceError: fetch is not defined
at Object.<anonymous> (/Users/eveporcello/Desktop/index.js:7:1)
at Module.\_compile (internal/modules/cjs/loader.js:1063:30)
at Object.Module.\_extensions..js
(internal/modules/cjs/loader.js:1103:10)
at Module.load (internal/modules/cjs/loader.js:914:32)
at Function.Module.\_load (internal/modules/cjs/loader.js:822:14)
at Function.Module.runMain (internal/modules/cjs/loader.js:1143:12)
at internal/main/run_main_module.js:16:11
This error occurs because Node.js does not have a built-in fetch
function like the browser does. With Node.js, we can use isomorphicfetch from npm, or use the built-in https module. Since we’ve
already used the fetch syntax, let’s incorporate isomorphic-fetch:
npm install isomorphic-fetch
Then we’ll just import isomorphic-fetch with no changes to the
code:
const fetch = require("isomorphic-fetch");
const userDetails = response => {
const login = response.login;
console.log(login);
};
fetch("https://api.github.com/users/moonhighway")
.then(res => res.json())
.then(userDetails);
Loading data from an API with Node.js requires the use of core
modules. It requires different code. In these samples, the userDetails
function is universal, so the same function works in both environments.
This JavaScript file is now isomorphic. It contains universal JavaScript.
All of the code is not universal, but the file itself will work in both
environments. It can run it with Node.js or include it in a <script> tag
in the browser.
Let’s take a look at the Star component. Is this component universal?
function Star({
selected = false,
onClick = f => f
}) {
return (
<div
className={
selected ? "star selected" : "star"
}
onClick={onClick}
></div>
);
}
Sure it is; remember, the JSX compiles to JavaScript. The Star
component is simply a function:
function Star({
selected = false,
onClick = f => f
}) {
return React.createElement("div", {
className: selected
? "star selected"
: "star",
onClick: onClick
});
}
We can render this component directly in the browser, or render it in a
different environment and capture the HTML output as a string.
ReactDOM has a renderToString method that we can use to render UI
to an HTML string:
// Renders html directly in the browser
ReactDOM.render(<Star />);
// Renders html as a string
let html = ReactDOM.renderToString(<Star />);
We can build isomorphic applications that render components on
different platforms, and we can architect these applications in a way
that reuses JavaScript code universally across multiple environments.
Additionally, we can build isomorphic applications using other
languages such as Go or Python—we’re not restricted to Node.js.
Server Rendering React
Using the ReactDOM.renderToString method allows us to render UI
on the server. Servers are powerful; they have access to all kinds of
resources that browsers do not. Servers can be secure and access secure
data. You can use all of these added benefits to your advantage by
rendering initial content on the server.
The app we’ll server render is our Recipes app that we built in
Chapter 5. You can run Create React App and place this code over the
contents of the index.js file:
import React from "react";
import ReactDOM from "react-dom";
import "./index.css";
import { Menu } from "./Menu";
const data = [
{
name: "Baked Salmon",
ingredients: [
{
name: "Salmon",
amount: 1,
measurement: "lb"
},
{
name: "Pine Nuts",
amount: 1,
measurement: "cup"
},
{
name: "Butter Lettuce",
amount: 2,
measurement: "cups"
},
{
name: "Yellow Squash",
amount: 1,
measurement: "med"
},
{
name: "Olive Oil",
amount: 0.5,
measurement: "cup"
},
{
name: "Garlic",
amount: 3,
measurement: "cloves"
}
],
steps: [
"Preheat the oven to 350 degrees.",
"Spread the olive oil around a glass baking dish.",
"Add the yellow squash and place in the oven for 30 mins.",
"Add the salmon, garlic, and pine nuts to the dish.",
"Bake for 15 minutes.",
"Remove from oven. Add the lettuce and serve."
]
},
{
name: "Fish Tacos",
ingredients: [
{
name: "Whitefish",
amount: 1,
measurement: "l lb"
},
{
name: "Cheese",
amount: 1,
measurement: "cup"
},
{
name: "Iceberg Lettuce",
amount: 2,
measurement: "cups"
},
{
name: "Tomatoes",
amount: 2,
measurement: "large"
},
{
name: "Tortillas",
amount: 3,
measurement: "med"
}
],
steps: [
"Cook the fish on the grill until hot.",
"Place the fish on the 3 tortillas.",
"Top them with lettuce, tomatoes, and cheese."
]
}
];
ReactDOM.render(
<Menu
recipes={data}
title="Delicious Recipes"
/>,
document.getElementById("root")
);
The components will live in a new file called Menu.js:
function Recipe({ name, ingredients, steps }) {
return (
<section
id={name.toLowerCase().replace(/ /g, "-")}
>
<h1>{name}</h1>
<ul className="ingredients">
{ingredients.map((ingredient, i) => (
<li key={i}>{ingredient.name}</li>
))}
</ul>
<section className="instructions">
<h2>Cooking Instructions</h2>
{steps.map((step, i) => (
<p key={i}>{step}</p>
))}
</section>
</section>
);
}
export function Menu({ title, recipes }) {
return (
<article>
<header>
<h1>{title}</h1>
</header>
<div className="recipes">
{recipes.map((recipe, i) => (
<Recipe key={i} {...recipe} />
))}
</div>
</article>
);
}
Throughout the book, we’ve rendered components on the client. Clientside rendering is typically the first approach we’ll use when building an
app. We serve up the Create React App build folder, and the browser
runs the HTML and makes calls to the script.js file to load any
JavaScript.
Doing this can be time consuming. The user might have to wait to see
anything load for a few seconds depending on their network speed.
Using Create React App with an Express server, we can create a hybrid
experience of client- and server-side rendering.
We’re rendering a Menu component that renders several recipes. The
first change we’ll make to this app is to use ReactDOM.hydrate instead
of ReactDOM.render.
These two functions are the same except hydrate is used to add
content to a container that was rendered by ReactDOMServer. The
order of operations will look like this:
1. Render a static version of the app, allowing users to see that
something has happened and the page has “loaded.”
2. Make the request for the dynamic JavaScript.
3. Replace the static content with the dynamic content.
4. User clicks on something and it works.
We’re rehydrating the app after a server-side render. By rehydrate, we
mean statically loading the content as static HTML and then loading
the JavaScript. This allows users to experience perceived performance.
They’ll see that something is happening on the page, and that makes
them want to stay on the page.
Next, we need to set up our project’s server, and we’ll use Express, a
lightweight Node server. Install it first:
npm install express
Then we’ll create a server folder called server and create an index.js
file inside of that. This file will build a server that will serve up the
build folder but also preload some static HTML content:
import express from "express";
const app = express();
app.use(express.static("./build"));
This imports and statically serves the build folder. Next, we want to
use renderToString from ReactDOM to render the app as a static
HTML string:
import React from "react";
import ReactDOMServer from "react-dom/server";
import { Menu } from "../src/Menu.js";
const PORT = process.env.PORT || 4000;
app.get("/*", (req, res) => {
const app = ReactDOMServer.renderToString(
<Menu />
);
});
app.listen(PORT, () =>
console.log(
`Server is listening on port ${PORT}`
)
);
We’ll pass the Menu component to this function because that’s what we
want to render statically. We then want to read the static index.html file
from the built client app, inject the app’s content in the div, and send
that as the response to the request:
app.get("/*", (req, res) => {
const app = ReactDOMServer.renderToString(
<Menu />
);
const indexFile = path.resolve(
"./build/index.html"
);
fs.readFile(indexFile, "utf8", (err, data) => {
return res.send(
data.replace(
'<div id="root"></div>',
`<div id="root">${app}</div>`
)
);
});
});
Once we’ve completed this, we’ll need to do some configuration with
webpack and Babel. Remember, Create React App can take care of
compiling and building out of the box, but we need to set up and
enforce different rules with the server project.
Start by installing a few dependencies (OK, a lot of dependencies):
npm install @babel/core @babel/preset-env babel-loader nodemon npm-runall
webpack webpack-cli webpack-node-externals
With Babel installed, let’s create a .babelrc with some presets:
{
"presets": ["@babel/preset-env", "react-app"]
}
You’ll add react-app because the project uses Create React App, and
it has already been installed.
Next, add a webpack configuration file for the server called
webpack.server.js:
const path = require("path");
const nodeExternals = require("webpack-node-externals");
module.exports = {
entry: "./server/index.js",
target: "node",
externals: [nodeExternals()],
output: {
path: path.resolve("build-server"),
filename: "index.js"
},
module: {
rules: [
{
test: /\.js$/,
use: "babel-loader"
}
]
}
};
The babel-loader will transform JavaScript files as expected, and
nodeExternals will scan the node_modules folder for all
node_modules names. Then, it will build an external function that tells
webpack not to bundle those modules or any submodules.
Also, you might run into a webpack error due to a version conflict
between the version you’ve installed with Create React App and the
version we just installed. To fix the conflict, just add a .env file to the
root of the project and add:
SKIP_PREFLIGHT_CHECK=true
Finally, we can add a few extra npm scripts to run our dev commands:
{
"scripts": {
//...
"dev:build-server": "NODE_ENV=development webpack --config
webpack.server.js
--mode=development -w",
"dev:start": "nodemon ./server-build/index.js",
"dev": "npm-run-all --parallel build dev:*"
}
}
1. dev:build-server: Passes development as an environment
variable and runs webpack with the new server config.
2. dev:start: Runs the server file with nodemon, which will
listen for any changes.
3. dev: Runs both processes in parallel.
Now when we run npm run dev, both of the processes will run. You
should be able to see the app running on localhost:4000. When the
app runs, the content will load in sequence, first as prerendered HTML
and then with the JavaScript bundle.
Using a technique like this can mean faster load times and will yield a
boost in perceived performance. With users expecting page-load times
of two seconds or less, any improved performance can mean the
difference between users using your website or bouncing to a
competitor.
Server Rendering with Next.js
Another powerful and widely used tool in the server rendering
ecosystem is Next.js. Next is an open source technology that was
released by Zeit to help engineers write server-rendered apps more
easily. This includes features for intuitive routing, statically optimizing,
automatic splitting, and more. In the next section, we’ll take a closer
look at how to work with Next.js to enable server rendering in our app.
To start, we’ll create a whole new project, running the following
commands:
mkdir project-next
cd project-next
npm init -y
npm install --save react react-dom next
mkdir pages
Then we’ll create some npm scripts to run common commands more
easily:
{
//...
"scripts": {
"dev": "next",
"build": "next build",
"start": "next start"
}
}
In the pages folder, we’ll create an index.js file. We’ll write our
component, but we won’t worry about importing React or ReactDOM.
Instead, we’ll just write a component:
export default function Index() {
return (
<div>
<p>Hello everyone!</p>
</div>
);
}
Once we’ve created this, we can run npm run dev to see the page
running on localhost:3000. It displays the expected component.
You’ll also notice there’s a small lightning bolt icon in the lower
righthand corner of the screen. Hovering over this will display a button
that reads Prerendered Page. When you click on it, it will take you to
documentation about the Static Optimization Indicator. This means that
the page fits the criteria for automatic static optimization, meaning that
it can be prerendered. There are no data requirements that block it. If a
page is automatically statically optimized (a mouthful, but useful!), the
page is faster to load because there’s no server-side effort needed. The
page can be streamed from a CDN, yielding a super-fast user
experience. You don’t have to do anything to pick up on this
performance enhancement.
What if the page does have data requirements? What if the page cannot
be prerendered? To explore this, let’s make our app a bit more robust
and build toward a component that fetches some remote data from an
API. In a new file called Pets.js:
export default function Pets() {
return <h1>Pets!</h1>;
}
To start, we’ll render an h1. Now we can visit localhost:3000/pets
to see that our page is now loaded on that route. That’s good, but we
can improve this by adding links and a layout component that will
display the correct content for each page. We’ll create a header that can
be used on both pages and will display links:
import Link from "next/link";
export default function Header() {
return (
<div>
<Link href="/">
<a>Home</a>
</Link>
<Link href="/pets">
<a>Pets</a>
</Link>
</div>
);
}
The Link component is a wrapper around a couple of links. These look
similar to the links we created with React Router. We can also add a
style to each of the <a> tags:
const linkStyle = {
marginRight: 15,
color: "salmon"
};
export default function Header() {
return (
<div>
<Link href="/">
<a style={linkStyle}>Home</a>
</Link>
<Link href="/pets">
<a style={linkStyle}>Pets</a>
</Link>
</div>
);
}
Next, we’ll incorporate the Header component into a new file called
Layout.js. This will dynamically display the component based on the
correct route:
import Header from "./Header";
export function Layout(props) {
return (
<div>
<Header />
{props.children}
</div>
);
}
The Layout component will take in props and display any additional
content in the component underneath the Header. Then in each page,
we can create content blocks that can be passed to the Layout
component when rendered. For example, the index.js file would now
look like this:
import Layout from "./Layout";
export default function Index() {
return (
<Layout>
<div>
<h1>Hello everyone!</h1>
</div>
</Layout>
);
}
We’ll do the same in the Pets.js file:
import Layout from "./Layout";
export default function Pets() {
return (
<Layout>
<div>
<h1>Hey pets!</h1>
</div>
</Layout>
);
}
Now if we visit the homepage, we should see the header, then when we
click the Pets link, we should see the Pets page.
When we click on the lightning bolt button in the lower righthand
corner, we’ll notice that these pages are still being prerendered. This is
to be expected as we continue to render static content. Let’s use the
Pets page to load some data and see how this changes.
To start, we’ll install isomorphic-unfetch like we did earlier in the
chapter:
npm install isomorphic-unfetch
We’ll use this to make a fetch call to the Pet Library API. Start by
importing it in the Pages.js file:
import fetch from "isomorphic-unfetch";
Then we’re going to add a function called getInitialProps. This will
handle fetching and loading the data:
Pets.getInitialProps = async function() {
const res = await fetch(
`http://pet-library.moonhighway.com/api/pets`
);
const data = await res.json();
return {
pets: data
};
};
When we return the data as the value for pets, we then can map over
the data in the component.
Adjust the component to map over the pets property:
export default function Pets(props) {
return (
<Layout>
<div>
<h1>Pets!</h1>
<ul>
{props.pets.map(pet => (
<li key={pet.id}>{pet.name}</li>
))}
</ul>
</div>
</Layout>
);
}
If getInitialProps is present in the component, Next.js will render
the page in response to each request. This means that the page will be
server-side rendered instead of statically prerendered, so the data from
the API will be current on each request.
Once we’re satisfied with the state of the application, we can run a
build with npm run build. Next.js is concerned with performance, so
it will give us a full rundown of the number of kilobytes present for
each file. This is a quick spot-check for unusually large files.
Next to each file, we’ll see an icon for whether a site is server-rendered
at runtime (λ), automatically rendered as HTML (○), or automatically
generated as static HTML + JSON (●).
Once you’ve built the app, you can deploy it. Next.js is an open source
product of Zeit, a cloud-hosting provider, so the experience of
deploying with Zeit is the most straightforward. However, you can use
many different hosting providers to deploy your application.
To recap, there are some important bits of terminology that are
important to understand when setting out to build your own apps:
CSR (client-side rendering)
Rendering an app in a browser, generally using the DOM. This is
what we do with an unmodified Create React App.
SSR (server-side rendering)
Rendering a client-side or universal app to HTML on the server.
Rehydration
Loading JavaScript views on the client to reuse the server-rendered
HTML’s DOM tree and data.
Prerendering
Running a client-side application at build time and capturing initial
state as static HTML.
Gatsby
Another popular site generator that’s based on React is Gatsby. Gatsby
is taking over the world as a straightforward way to create a contentdriven website. It aims to offer smarter defaults to manage concerns
like performance, accessibility, image handling, and more. And if
you’re reading this book, it’s likely that you might work on a Gatsby
project at some point!
Gatsby is used for a range of projects, but it’s often used to build
content-driven websites. In other words, if you have a blog or static
content, Gatsby is a great choice, particularly now that you know
React. Gatsby can also handle dynamic content like loading data from
APIs, integration with frameworks, and more.
In this section, we’ll start building a quick Gatsby site to demonstrate
how it works. Essentially, we’ll build our small Next.js app as a Gatsby
app:
npm install -g gatsby-cli
gatsby new pets
If you have yarn installed globally, the CLI will ask you whether to use
yarn or npm. Either is fine. Then you’ll change directory into the pets
folder:
cd pets
Now you can start the project with gatsby develop. When you visit
localhost:8000, you’ll see your Gatsby starter site running. Now you
can take a tour of the files.
If you open up the project’s src folder, you’ll see three subfolders:
components, images, and pages.
Within the pages folder, you’ll find a 404.js error page, an index.js
page (the page that renders when you visit localhost:8000), and a
page-2.js that renders the content of the second page.
If you visit the components folder, this where the magic of Gatsby is
located. Remember when we built the Header and Layout components
with Next.js? Both of these components are already created as
templates in the components folder.
A few particularly interesting things to note:
layout.js
This contains the Layout component. It uses the useStaticQuery
hook to query some data about the site using GraphQL.
seo.js
This component lets us access the page’s metadata for search
engine optimization purposes.
If you add additional pages to the pages folder, this will add additional
pages to your site. Let’s try it and add a page-3.js file to the pages
folder. Then we’ll add the following code to that file to stand up a
quick page:
import React from "react";
import { Link } from "gatsby";
import Layout from "../components/layout";
import SEO from "../components/seo";
const ThirdPage = () => (
<Layout>
<SEO title="Page three" />
<h1>Hi from the third page</h1>
<Link to="/">Go back to the homepage</Link>
</Layout>
);
export default ThirdPage;
We’ll use the Layout component to wrap the content so that it’s
displayed as children. Not only does Layout display the dynamic
content, but as soon as we create it, the page is autogenerated.
That’s the tip of the iceberg with what you can do with Gatsby, but
we’ll leave you with some information about some of its additional
features:
Static content
You can build your site as static files, which can be deployed
without a server.
CDN support
It’s possible to cache your site on CDNs all over the world to
improve performance and availability.
Responsive and progressive images
Gatsby loads images as blurry placeholders, then fades in the full
assets. This tactic, popularized by Medium, allows users to see
something rendering before the full resource is available.
Prefetching of linked pages
All of the content needed to load the next page will load in the
background before you click on the next link.
All of these features and more are used to ensure a seamless user
experience. Gatsby has made a lot of decisions for you. That could be
good or bad, but these constraints aim to let you focus on your content.
React in the Future
While Angular, Ember, and Vue continue to have substantial
marketshare in the JavaScript ecosystem, it’s hard to argue with the
fact that React is currently the most widely used and influential library
for building JavaScript apps. In addition to the library itself, the wider
JavaScript community, as evidenced particularly by Next.js and
Gatsby, has embraced React as the tool of choice.
So where do we go from here? We’d encourage you to use these skills
to build your own projects. If you’re looking to build mobile
applications, you can check out React Native. If you’re looking to
declaratively fetch data, you can check out GraphQL. If you’re looking
to build content-based websites, dig deeper into Next.js and Gatsby.
There are a number of avenues you can travel down, but these skills
you’ve picked up in React will serve you well as you set out to build
your own applications. When you’re doing so, we hope that this book
will serve as a reference and a foundation. Although React and its
related libraries will almost certainly go through changes, these are
stable tools that you can feel confident about using right away.
Building apps with React and functional, declarative JavaScript is a lot
of fun, and we can’t wait to see what you’ll build.
1
Gert Hengeveld, “Isomorphism vs Universal JavaScript”, Medium.
Index
A
Array.filter function, Data Transformations
Array.join function, Data Transformations
Array.map function, Data Transformations, Data Transformations-Data
Transformations
Array.pop function, Data Transformations
Array.reduce function, Data Transformations, Data TransformationsData Transformations, Improving Code with useReducer
Array.reduceRight function, Data Transformations-Data
Transformations
Array.splice function, Data Transformations
arrays
destructuring, Destructuring Arrays
mapping with JSX, Mapping Arrays with JSX
spread operator (…), The Spread Operator
arrow functions, Arrow Functions-Arrow functions and scope
async function, Async/Await, Requesting Data
asynchronous programming
async and await functions, Async/Await, Requesting Data
building promises, Building Promises
fetch() function, Simple Promises with Fetch, Requesting Data,
Requesting Data
render props pattern, Render Props
versus synchronous, Asynchronous JavaScript
authorization, Authorized Requests
await function, Async/Await, Requesting Data
B
Babel
benefits of, Compiling JavaScript
history of, Babel
working with, Babel
bundling, Intro to webpack
C
checkboxes, Introducing useEffect-Introducing useEffect, Improving
Code with useReducer
child elements, Children-Children
class components, The useState Hook
classes, Classes-Classes
className, Children, className
code coverage, Using Code Coverage
code examples, obtaining and using, Using Code Examples, File
Repository
code splitting
benefits of, Code Splitting
building Suspenseful data sources, Building Suspenseful Data
Sources
definition of term, Intro to webpack
example of, Code Splitting
Suspense component, Introducing: The Suspense Component
throwing promises, Throwing Promises
using Suspense with data, Using Suspense with Data
colors
adding to state, Adding Colors to State
placing in context, Placing Colors in Context
retrieving with useContext, Retrieving Colors with useContext
CommonJS, CommonJS
component trees
building, Constructing elements with data
definition of term, React State Management
inspecting, React Developer Tools, Recipes as JSX
managing state from one location, State in Component Trees
sending interactions back up, Sending Interactions Back up a
Component Tree-Sending Interactions Back up a Component Tree
sending state down, Sending State Down a Component Tree
components
controlled components, Controlled Components
creating fetch components, Creating a Fetch Component
enhancing with hooks, Enhancing Components with Hooks
improving component performance, Improving Component
Performance
pure components, Improving Component Performance
shouldComponentUpdate method, shouldComponentUpdate and
PureComponent
testing React components, Testing React Components-Using Code
Coverage
composition, Composition-Composition
concurrent mode, Fiber
const keyword, The const Keyword
context
context providers and consumers, React Context
createContext function, Placing Colors in Context
custom hooks with, Custom Hooks with Context
purpose of, React Context
stateful context providers, Stateful Context Providers
useContext hook, Retrieving Colors with useContext
controlled components, Controlled Components
Create React App, Create React App, Throwing Promises, Create React
App and Testing
createContext function, Placing Colors in Context
D
data management
challenges of, Incorporating Data
GraphQL, Introducing GraphQL-Making a GraphQL Request
render props, Render Props
requesting data
async/await and, Requesting Data
authorized requests, Authorized Requests
fetch requests, Requesting Data
handling promise states, Handling Promise States
saving data locally, Saving Data Locally
sending data with requests, Sending Data with a Request
uploading files with fetch, Uploading Files with fetch
virtualized lists
canceling requests, Canceling Requests
creating fetch components, Creating a Fetch Component
creating fetch hooks, Creating a Fetch Hook
handling multiple requests, Handling Multiple Requests
implementing, Virtualized Lists
memoizing values, Memozing Values
parallel requests, Parallel Requests
purpose of, Virtualized Lists
throttling network speed, Throttling the Network Speed
waiting for values, Waiting for Values
waterfall requests, Waterfall Requests
data transformations, Data Transformations-Data Transformations
declarative programming, Imperative Versus Declarative-Imperative
Versus Declarative, Putting It All Together
dependencies
deep checking, Deep Checking Dependencies-Deep Checking
Dependencies
dependency arrays, The Dependency Array-The Dependency
Array
development environment
GitHub file repository, File Repository
Node package manager, npm
Node.js, Installing Node.js
React Developer Tools, React Developer Tools, Page Setup
Yarn, Yarn
E
ECMAScript, JavaScript for React
element trees, Children
error boundaries, Error Boundaries-Error Boundaries
ES6 modules, ES6 Modules-CommonJS
ESLint, ESLint-ESLint Plug-Ins
ESNext, compatibility table, CommonJS
European Computer Manufacturers Association (ECMA), JavaScript
for React
F
fake data, Virtualized Lists
feature flagging, Intro to webpack
fetch() function, Simple Promises with Fetch, Requesting Data
Fiber algorithm, Fiber-Fiber
first-class members/functions, Functional Programming with
JavaScript
Flow, Flow
forms
adding colors to state, Adding Colors to State
building with refs, Using Refs
controlled components, Controlled Components
custom hooks, Creating Custom Hooks
form and child elements, Building Forms
rendering with JSX, Building Forms
fragments, React Fragments-React Fragments
functional programming
core concepts
composition, Composition-Composition
data transformations, Data Transformations-Data
Transformations
higher-order functions, Higher-Order Functions
immutability, Immutability
pure functions, Pure Functions
recursion, Recursion-Recursion
ticking clock program example, Putting It All TogetherPutting It All Together
definition of term, What It Means to Be Functional
imperative versus declarative programming, Imperative Versus
Declarative-Imperative Versus Declarative, Putting It All
Together
introduction to, Functional Programming with JavaScript
functions
arrow functions, Arrow Functions-Arrow functions and scope
creating, Creating Functions
default parameters, Default Parameters
function declarations, Function Declarations
function expressions, Function Expressions
function returns, Function returns
higher-order, Functional Programming with JavaScript, What It
Means to Be Functional, Higher-Order Functions
passing arguments, Passing arguments
pure functions, Pure Functions
reducer functions, Improving Code with useReducer
G
Gatsby, Gatsby
GitHub file repository, File Repository
GraphQL, Introducing GraphQL-Making a GraphQL Request
H
higher-order functions, Functional Programming with JavaScript, What
It Means to Be Functional, Higher-Order Functions
hinting, ESLint
hooks
benefits of, Custom Hooks with Context
creating fetch hooks, Creating a Fetch Hook
custom hooks, Creating Custom Hooks, Creating a Fetch Hook,
Handling Multiple Requests
custom with context, Custom Hooks with Context
enhancing components with, Enhancing Components with Hooks
purpose of, The useState Hook
rules to follow with hooks, Rules to Follow with Hooks-Rules to
Follow with Hooks
useCallback hook, Deep Checking Dependencies, Improving
Component Performance
useContext hook, Retrieving Colors with useContext
useEffect hook
data requests, Authorized Requests
deep checking dependencies, Deep Checking DependenciesDeep Checking Dependencies
dependency arrays, The Dependency Array-The Dependency
Array
improving component performance, Improving Component
Performance
introduction to, Introducing useEffect-Introducing useEffect
refactoring, When to Refactor
shouldComponentUpdate method, shouldComponentUpdate
and PureComponent
useLayoutEffect hook, When to useLayoutEffect
useReducer hook, Improving Code with useReduceruseReducer to Handle Complex State
useInput hook, Creating Custom Hooks
useMemo hook, Deep Checking Dependencies-Deep Checking
Dependencies, Improving Component Performance
useRef hook, Using Refs
useState hook, The useState Hook-The useState Hook, Creating
Custom Hooks, Authorized Requests-Making a GraphQL Request
Hot Module Replacement (HMR), Intro to webpack
I
immutability, Immutability
imperative programming, Imperative Versus Declarative-Imperative
Versus Declarative
import statements, ES6 Modules, 3. Creating the webpack build
isomorphic applications, Isomorphic Versus Universal
J
JavaScript
asynchronous, Asynchronous JavaScript-Building Promises
classes, Classes-Classes
compiling, Compiling JavaScript
ES6 modules, ES6 Modules-CommonJS
evolution of, JavaScript for React
expressions, React Elements as JSX-JavaScript expressions
functions, Creating Functions-Arrow functions and scope
objects and arrays, Objects and Arrays-Asynchronous JavaScript
variables, Declaring Variables-Template Strings
Jest, Incorporating Jest-Create React App and Testing
JSHint, ESLint
JSLint, ESLint
JSX language extension
Babel, Babel
JSX tips
className, className
evaluation, Evaluation
JavaScript expressions, JavaScript expressions
nested components, Nested components
mapping arrays with, Mapping Arrays with JSX
purpose of, React with JSX
React elements as JSX, React Elements as JSX
React fragments, React Fragments-React Fragments
recipe examples, Recipes as JSX-Recipes as JSX
rendering forms with, Building Forms
webpack
app creation, Create React App
bundle loading, Loading the Bundle
introduction to, Intro to webpack
project creation, Creating the Project-3. Creating the
webpack build
source mapping, Source Mapping
L
layers, Intro to webpack
let keyword, The let Keyword
lexical variable scope, The let Keyword
linting, ESLint
M
map and reduce, Data Transformations-Data Transformations
memoization, shouldComponentUpdate and PureComponent,
Memozing Values
minification, Intro to webpack
module bundlers, Intro to webpack
modules, ES6 Modules-CommonJS, Intro to webpack
multipart-formdata requests, Uploading Files with fetch
N
network speed, throttling, Throttling the Network Speed
Next.js, Server Rendering with Next.js-Server Rendering with Next.js
Node package manager (npm), installing, npm
Node.js
code reuse with, Isomorphic Versus Universal
installing, Installing Node.js
O
objects
destructuring, Destructuring Objects
object literal enhancement, Object Literal Enhancement
P
package.json file, npm, 1. Create the project
page setup, Page Setup
parallel requests, Parallel Requests
Personal Access tokens, Authorized Requests
Personal User tokens, Authorized Requests
POST requests, Sending Data with a Request
predicates, Data Transformations
Prettier, Prettier
promises
building, Building Promises
code splitting and, Throwing Promises
handling promise states, Handling Promise States
simple with fetch() function, Simple Promises with Fetch,
Requesting Data
PropTypes library, PropTypes
prototypical inheritance, Classes
pure components, Improving Component Performance
pure functions, Pure Functions
PureComponent, shouldComponentUpdate and PureComponent
PUT requests, Sending Data with a Request
Q
queries (React Testing Library), Queries
R
React
development environment
GitHub repository, File Repository
Node package manager, npm
Node.js, Installing Node.js
React Developer Tools, React Developer Tools
Yarn, Yarn
future of, React’s Past and Future, React in the Future
how it works
page setup, Page Setup
React components, React Components-Tour stop 2: class
components
React elements, React Elements-React Elements
ReactDOM, ReactDOM-Constructing elements with data
installing, 1. Create the project
introduction to
approach to learning, A Strong Foundation
benefits of, Welcome to React
deprecated features, Learning React: Second Edition
Changes
history of, React’s Past and Future
prerequisites to learning, Preface
versions, React’s Past and Future, Page Setup
React blog, React’s Past and Future
React components, React Components-Tour stop 2: class components,
Testing React Components-Using Code Coverage
React Developer Tools, React Developer Tools, Recipes as JSX, When
to Refactor
React elements, React Elements-React Elements
React fragments, React Fragments-React Fragments
React Native, React’s Past and Future
React Profiler, When to Refactor
React Router
incorporating, Incorporating the Router-Incorporating the Router
nesting routes, Nesting Routes
purpose of, React Router
router properties, Router Properties-Nesting Routes
routing parameters, Routing Parameters
using redirects, Using Redirects-Routing Parameters
React Spinners library, Introducing: The Suspense Component
react-icons library, Building a Star Rating Component
React.Component API, Tour stop 2: class components
React.createClass, Tour stop 1: createClass
React.createElement, React Elements-Tour stop 2: class components
React.memo, shouldComponentUpdate and PureComponent
ReactDOM
constructing elements with data, Constructing elements with data
installing, 1. Create the project
purpose of, Page Setup
ReactDOM package, ReactDOM
render method, ReactDOM
rendering child elements, Children-Children
ReactDOM.renderToString method, Server Rendering React
reconciliation algorithm, Fiber, Fiber-Fiber
recursion, Recursion-Recursion
redirects, Using Redirects-Routing Parameters
reducer functions, Improving Code with useReducer
refactoring, When to Refactor
refs, building forms with, Using Refs
render props pattern, Retrieving Colors with useContext, Render Props
rollups, Intro to webpack
routing, React Router
(see also React Router)
S
server-side rendering
isomorphic versus universal rendering, Isomorphic Versus
Universal
need for, React and the Server
with Gatsby, Gatsby
with Next.js, Server Rendering with Next.js-Server Rendering
with Next.js
with React, Server Rendering React-Server Rendering React
setState function, useReducer to Handle Complex State
shouldComponentUpdate method, shouldComponentUpdate and
PureComponent
spread operator (…), The Spread Operator
spreading props, Refactoring for Advanced Reusability
state management
building forms, Building Forms-Adding Colors to State
building star rating components, Building a Star Rating
Component
component trees, State in Component Trees-Sending Interactions
Back up a Component Tree
handling complex state, useReducer to Handle Complex State
handling promise states, Handling Promise States
importance of, React State Management
legacy setState function, useReducer to Handle Complex State
prior to release of hooks, The useState Hook
React context, React Context-Custom Hooks with Context
useState hook, The useState Hook-The useState Hook, Creating
Custom Hooks, Authorized Requests-Making a GraphQL Request
string templates, Template Strings
Suspense component
benefits and drawbacks of, Suspense
code splitting
benefits of, Code Splitting
building Suspenseful data sources, Building Suspenseful
Data Sources
example of, Code Splitting
how it works, Introducing: The Suspense Component
throwing promises, Throwing Promises
using Suspense with data, Using Suspense with Data
error boundaries, Error Boundaries-Error Boundaries
future of, Building Suspenseful Data Sources
system under test (SUT), Create React App and Testing
T
template strings, Template Strings
test-driven development (TDD), Test-Driven Development
type inference, TypeScript
typechecking
Flow, Flow
PropTypes library, PropTypes
TypeScript, TypeScript
TypeScript, TypeScript
U
unit testing
benefits of, React Testing, Using Code Coverage
ESLint, ESLint-ESLint Plug-Ins
Jest, Incorporating Jest-Create React App and Testing
Prettier, Prettier
test-driven development, Test-Driven Development
testing React components, Testing React Components-Using Code
Coverage
typechecking
Flow, Flow
PropTypes library, PropTypes
TypeScript, TypeScript
universal code, Isomorphic Versus Universal
useCallback hook, Deep Checking Dependencies, Improving
Component Performance
useContext hook, Retrieving Colors with useContext
useEffect hook
data requests, Authorized Requests
deep checking dependencies, Deep Checking Dependencies-Deep
Checking Dependencies
dependency arrays, The Dependency Array-The Dependency
Array
improving component performance, Improving Component
Performance
introduction to, Introducing useEffect-Introducing useEffect
refactoring, When to Refactor
rules to follow with hooks, Rules to Follow with Hooks-Rules to
Follow with Hooks
shouldComponentUpdate method, shouldComponentUpdate and
PureComponent
useLayoutEffect, When to useLayoutEffect
useReducer hook
handling complex state with, useReducer to Handle Complex
State
improving code with, Improving Code with useReducer
legacy setState function and, useReducer to Handle Complex
State
useFetch hook, Creating a Fetch Hook
useInput hook, Creating Custom Hooks
useLayoutEffect hook, When to useLayoutEffect
useMemo hook, Deep Checking Dependencies-Deep Checking
Dependencies, Improving Component Performance
useReducer hook
handling complex state with, useReducer to Handle Complex
State
improving code with, Improving Code with useReducer
legacy setState function and, useReducer to Handle Complex
State
useRef hook
building components, Using Refs
useState hook, The useState Hook-The useState Hook, Creating
Custom Hooks, Authorized Requests-Making a GraphQL Request
V
variables
const keyword, The const Keyword
declaring, Declaring Variables
let keyword, The let Keyword
template strings, Template Strings
virtualization, Virtualized Lists
virtualized lists
canceling requests, Canceling Requests
creating fetch components, Creating a Fetch Component
creating fetch hooks, Creating a Fetch Hook
handling multiple requests, Handling Multiple Requests
implementing, Virtualized Lists
memoizing values, Memozing Values
parallel requests, Parallel Requests
purpose of, Virtualized Lists
throttling network speed, Throttling the Network Speed
waiting for values, Waiting for Values
waterfall requests, Waterfall Requests
VSCode, Prettier in VSCode
W
waterfall requests, Waterfall Requests
Web Storage API, Saving Data Locally
webpack
app creation, Create React App
bundle loading, Loading the Bundle
installing, 1. Create the project
introduction to, Intro to webpack
project creation, Creating the Project-3. Creating the webpack
build
source mapping, Source Mapping
window.localStorage object, Saving Data Locally
window.sessionStorage object, Saving Data Locally
windowing, Virtualized Lists
Y
Yarn, installing, Yarn
About the Authors
Alex Banks and Eve Porcello are software engineers, instructors, and
cofounders of Moon Highway, a curriculum development company in
Northern California. They’ve created courses for LinkedIn Learning
and egghead.io, are frequent conference speakers, and teach workshops
to engineers all over the world.
Colophon
The animal on the cover of Learning React is a wild boar and its babies
(Sus scrofa). The wild boar, also known as wild swine or Eurasian wild
pig, is native to Eurasia, North Africa, and the Greater Sunda Islands.
Because of human intervention, they are one of the widest-ranging
mammals in the world.
Wild boars have short thin legs and bulky bodies with short, massive
trunks. Their necks are short and thick, leading to a large head that
accounts for up to a third of the body’s length. Adult sizes and weights
vary depending on environmental factors such as access to food and
water. Despite their size, they can run up to 25 miles per hour and jump
to a height of 55–59 inches. In the winter, their coat consists of coarse
bristles that overlay short brown downy fur. These bristles are longer
along the boar’s back and shortest around the face and limbs.
Wild boars have a highly developed sense of smell; they have been
used for drug detection in Germany. They also have an acute sense of
hearing, which contrasts with their weak eyesight and lack of color
vision. The boars are unable to recognize a human standing 30 feet
away.
Boars are social animals that live in female-dominated groups.
Breeding lasts from around November to January. Males go through
several bodily changes in preparation of mating, including the
development of a subcutaneous armor that helps during confrontations
with rivals; they travel long distances, eating very little on the way, to
locate a sow. Average litters contain four to six piglets.
Many of the animals on O’Reilly covers are endangered; all of them
are important to the world.
The cover illustration is by Karen Montgomery, based on a black-andwhite engraving from Meyers Kleines Lexicon. The cover fonts are
Gilroy Semibold and Guardian Sans. The text font is Adobe Minion
Pro; the heading font is Adobe Myriad Condensed; and the code font is
Dalton Maag’s Ubuntu Mono.
